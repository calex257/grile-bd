<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Grile BD 2023</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
      integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
      crossorigin="anonymous"
    />
    <script
      defer="defer"
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
      integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
      crossorigin="anonymous"
    ></script>
    <script
      defer="defer"
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
      integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
      crossorigin="anonymous"
      onload="renderMathInElement(document.body)"
    ></script>
    <script defer="defer" src="/static/js/main.d4ebf292.js"></script>
    <link href="/static/css/main.23453909.css" rel="stylesheet" />
    <style>
      body {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
          Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
        margin: 0;
      }
      code {
        font-family: source-code-pro, Menlo, Monaco, Consolas, Courier New,
          monospace;
      }
      .App {
        align-items: center;
        gap: 1rem;
        justify-content: center;
        margin: 0 auto;
        min-height: 90vh;
        width: 100%;
      }
      .App,
      .quiz {
        display: flex;
        flex-direction: column;
      }
      .quiz {
        background-color: hsla(0, 0%, 100%, 0.3);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.35);
        box-sizing: border-box;
        color: #232933;
        margin-left: auto;
        margin-right: auto;
        max-width: 900px;
        min-width: 150px;
        overflow: hidden;
        padding: 0.2rem 1.2rem 1.2rem;
        position: relative;
        text-align: left;
        width: calc(100% - 1em);
      }
      .quiz:first-child {
        margin-top: 10px;
      }
      .quiz:last-child {
        margin-bottom: 10px;
      }
      .question {
        align-items: center;
        border-radius: 10px;
        cursor: pointer;
        cursor: text;
        display: flex;
        font-size: 1.05rem;
        font-weight: 600;
        margin-bottom: 0.2rem;
        margin-top: 0;
        padding: 0.8rem 0 0.7rem 1rem;
        text-align: left;
      }
      .question:hover {
        background-color: #faf9f9;
      }
      .option {
        align-items: center;
        background-color: #f2f2f3;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        display: flex;
        font-size: 1rem;
        gap: 0.5rem;
        margin: 0.3rem auto;
        padding: 0.7rem 1rem;
        text-align: left;
        width: 100%;
      }
      .option:hover {
        background-color: #ebebeb;
      }
      .option.correct {
        background: linear-gradient(
          90deg,
          #39ad54 0,
          #39ad54 10px,
          #f0fff4 0,
          #f0fff4 calc(100% - 10px),
          #39ad54 calc(100% - 10px),
          #39ad54
        );
        color: #2d3748;
      }
      .option.incorrect {
        background: linear-gradient(
          90deg,
          #d33f4e 0,
          #d33f4e 10px,
          #fff5f5 0,
          #fff5f5 calc(100% - 10px),
          #d33f4e calc(100% - 10px),
          #d33f4e
        );
        color: #2d3748;
      }
      .checkmark {
        color: #39ad54;
      }
      .checkmark,
      .crossed {
        display: inline-block;
        font-weight: 700;
        line-height: 1;
        margin-right: 0.5rem;
      }
      .crossed {
        color: #d33f4e;
      }
      .feedback {
        border-radius: 10px;
        margin-bottom: 0.3rem;
        margin-top: 1rem;
        max-height: 150px;
        overflow: auto;
        padding: 0;
        text-align: left;
        transition: all 0.3s ease;
      }
      .feedback::-webkit-scrollbar {
        width: 10px;
      }
      .feedback::-webkit-scrollbar-track {
        background-color: #f1f1f1;
      }
      .feedback::-webkit-scrollbar-thumb {
        background-color: #e9e9e9;
        border-radius: 5px;
      }
      .feedback::-webkit-scrollbar-thumb:hover {
        background-color: #c4c4c4;
      }
      .info-icon {
        background-color: #e45820;
        border-radius: 10%;
        color: #fff;
        cursor: pointer;
        display: inline-flex;
        font-size: 0.7rem;
        font-weight: 600;
        margin-left: auto;
        max-height: 10px;
        max-width: 30px;
        min-width: 30px;
        overflow: hidden;
        padding: 0.5rem;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .info-icon,
      .popup-overlay {
        align-items: center;
        justify-content: center;
      }
      .popup-overlay {
        background-color: rgba(0, 0, 0, 0.5);
        bottom: 0;
        display: flex;
        left: 0;
        position: fixed;
        right: 0;
        top: 0;
        z-index: 1000;
      }
      .popup-content {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        display: block;
        max-height: 90vh;
        max-width: 850px;
        min-width: 150px;
        overflow: auto;
        padding: 1.2rem 1rem 1rem;
        position: relative;
        text-align: center;
        width: calc(100% - 5rem);
      }
      .close-btn {
        background-color: initial;
        background-color: #d6b7b7;
        border: 1px solid #ccc;
        border-radius: 10%;
        cursor: pointer;
        font-size: 1.5rem;
        padding: 0 1rem;
        position: absolute;
        right: 1rem;
        top: 0.3rem;
      }
      .close-btn:hover {
        color: red;
      }
      .ok-btn {
        background-color: #e45820;
        border: none;
        border-radius: 5px;
        color: #fff;
        cursor: pointer;
        font-size: 1rem;
        margin-top: 1rem;
        padding: 1rem;
        width: 100%;
      }
      .ok-btn:hover {
        background-color: #ec703f;
      }
      .explanation {
        border: none;
        border-radius: 5px;
        margin-bottom: 0.3rem;
        margin-top: 0.3rem;
        padding: 0.7rem 1rem;
        text-align: left;
      }
      .explanation:first-of-type {
        margin-top: 1.5rem;
        transition: all 0.3s ease;
      }
      .no-scroll {
        overflow: hidden;
        position: fixed;
        width: 100%;
      }
      .try-again {
        cursor: pointer;
        font-size: 1.2rem;
        margin-bottom: 20px;
        margin-left: auto;
        margin-right: auto;
        padding: 1.5rem;
        text-align: center;
      }
      .infoBox,
      .try-again {
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.35);
        box-sizing: border-box;
        max-width: 900px;
        min-width: 150px;
        width: calc(100% - 1rem);
      }
      .infoBox {
        margin: 1rem auto 0;
        overflow: hidden;
        padding: 1.2rem;
        text-align: left;
      }
      .infoBox,
      .infoContent {
        display: flex;
        flex-direction: column;
      }
      .infoContent {
        align-items: center;
        justify-content: flex-start;
        margin-bottom: -10px;
        padding-top: 10px;
        width: 100%;
      }
      .infoRow {
        border-bottom: 1px solid #ddd;
        display: flex;
        justify-content: space-between;
        padding: 10px 0;
        width: 100%;
      }
      .infoKey {
        flex: 1 1;
        font-weight: 700;
        text-align: left;
      }
      .infoValue {
        flex: 2 1;
        text-align: right;
      }
      .pagination-buttons {
        grid-gap: 4px;
        box-sizing: border-box;
        display: grid;
        gap: 4px;
        grid-template-columns: repeat(3, 1fr);
        max-width: 915px;
        padding: 5px;
        width: 100%;
      }
      .page-button {
        background-color: #e45820;
        border: none;
        border-radius: 5px;
        box-sizing: border-box;
        color: #fff;
        cursor: pointer;
        font-weight: 700;
        padding: 15px 5px;
        text-align: center;
      }
      .page-button:hover {
        background-color: #ec703f;
      }
      .page-button.wide-button {
        grid-column: span 3 / auto;
      }
      @media (min-width: 3000px) {
        .pagination-buttons {
          gap: 2px;
          grid-template-columns: repeat(9, 1fr);
          padding: 10px;
        }
        .page-button {
          padding: 10px 20px;
        }
        .page-button.wide-button {
          grid-column: span 3 / auto;
        }
      }
      /*# sourceMappingURL=main.23453909.css.map*/
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      /*! For license information please see main.d4ebf292.js.LICENSE.txt */
      !(function () {
        "use strict";
        var e = {
            470: function (e, t, a) {
              var n = a(390),
                i = a(124);
              function r(e) {
                for (
                  var t =
                      "https://reactjs.org/docs/error-decoder.html?invariant=" +
                      e,
                    a = 1;
                  a < arguments.length;
                  a++
                )
                  t += "&args[]=" + encodeURIComponent(arguments[a]);
                return (
                  "Minified React error #" +
                  e +
                  "; visit " +
                  t +
                  " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                );
              }
              var l = new Set(),
                o = {};
              function u(e, t) {
                s(e, t), s(e + "Capture", t);
              }
              function s(e, t) {
                for (o[e] = t, e = 0; e < t.length; e++) l.add(t[e]);
              }
              var c = !(
                  "undefined" === typeof window ||
                  "undefined" === typeof window.document ||
                  "undefined" === typeof window.document.createElement
                ),
                d = Object.prototype.hasOwnProperty,
                p =
                  /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                m = {},
                f = {};
              function g(e, t, a, n, i, r, l) {
                (this.acceptsBooleans = 2 === t || 3 === t || 4 === t),
                  (this.attributeName = n),
                  (this.attributeNamespace = i),
                  (this.mustUseProperty = a),
                  (this.propertyName = e),
                  (this.type = t),
                  (this.sanitizeURL = r),
                  (this.removeEmptyString = l);
              }
              var h = {};
              "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
                .split(" ")
                .forEach(function (e) {
                  h[e] = new g(e, 0, !1, e, null, !1, !1);
                }),
                [
                  ["acceptCharset", "accept-charset"],
                  ["className", "class"],
                  ["htmlFor", "for"],
                  ["httpEquiv", "http-equiv"],
                ].forEach(function (e) {
                  var t = e[0];
                  h[t] = new g(t, 1, !1, e[1], null, !1, !1);
                }),
                ["contentEditable", "draggable", "spellCheck", "value"].forEach(
                  function (e) {
                    h[e] = new g(e, 2, !1, e.toLowerCase(), null, !1, !1);
                  }
                ),
                [
                  "autoReverse",
                  "externalResourcesRequired",
                  "focusable",
                  "preserveAlpha",
                ].forEach(function (e) {
                  h[e] = new g(e, 2, !1, e, null, !1, !1);
                }),
                "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
                  .split(" ")
                  .forEach(function (e) {
                    h[e] = new g(e, 3, !1, e.toLowerCase(), null, !1, !1);
                  }),
                ["checked", "multiple", "muted", "selected"].forEach(function (
                  e
                ) {
                  h[e] = new g(e, 3, !0, e, null, !1, !1);
                }),
                ["capture", "download"].forEach(function (e) {
                  h[e] = new g(e, 4, !1, e, null, !1, !1);
                }),
                ["cols", "rows", "size", "span"].forEach(function (e) {
                  h[e] = new g(e, 6, !1, e, null, !1, !1);
                }),
                ["rowSpan", "start"].forEach(function (e) {
                  h[e] = new g(e, 5, !1, e.toLowerCase(), null, !1, !1);
                });
              var b = /[\-:]([a-z])/g;
              function v(e) {
                return e[1].toUpperCase();
              }
              function x(e, t, a, n) {
                var i = h.hasOwnProperty(t) ? h[t] : null;
                (null !== i
                  ? 0 !== i.type
                  : n ||
                    !(2 < t.length) ||
                    ("o" !== t[0] && "O" !== t[0]) ||
                    ("n" !== t[1] && "N" !== t[1])) &&
                  ((function (e, t, a, n) {
                    if (
                      null === t ||
                      "undefined" === typeof t ||
                      (function (e, t, a, n) {
                        if (null !== a && 0 === a.type) return !1;
                        switch (typeof t) {
                          case "function":
                          case "symbol":
                            return !0;
                          case "boolean":
                            return (
                              !n &&
                              (null !== a
                                ? !a.acceptsBooleans
                                : "data-" !==
                                    (e = e.toLowerCase().slice(0, 5)) &&
                                  "aria-" !== e)
                            );
                          default:
                            return !1;
                        }
                      })(e, t, a, n)
                    )
                      return !0;
                    if (n) return !1;
                    if (null !== a)
                      switch (a.type) {
                        case 3:
                          return !t;
                        case 4:
                          return !1 === t;
                        case 5:
                          return isNaN(t);
                        case 6:
                          return isNaN(t) || 1 > t;
                      }
                    return !1;
                  })(t, a, i, n) && (a = null),
                  n || null === i
                    ? (function (e) {
                        return (
                          !!d.call(f, e) ||
                          (!d.call(m, e) &&
                            (p.test(e) ? (f[e] = !0) : ((m[e] = !0), !1)))
                        );
                      })(t) &&
                      (null === a
                        ? e.removeAttribute(t)
                        : e.setAttribute(t, "" + a))
                    : i.mustUseProperty
                    ? (e[i.propertyName] = null === a ? 3 !== i.type && "" : a)
                    : ((t = i.attributeName),
                      (n = i.attributeNamespace),
                      null === a
                        ? e.removeAttribute(t)
                        : ((a =
                            3 === (i = i.type) || (4 === i && !0 === a)
                              ? ""
                              : "" + a),
                          n
                            ? e.setAttributeNS(n, t, a)
                            : e.setAttribute(t, a))));
              }
              "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
                .split(" ")
                .forEach(function (e) {
                  var t = e.replace(b, v);
                  h[t] = new g(t, 1, !1, e, null, !1, !1);
                }),
                "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
                  .split(" ")
                  .forEach(function (e) {
                    var t = e.replace(b, v);
                    h[t] = new g(
                      t,
                      1,
                      !1,
                      e,
                      "http://www.w3.org/1999/xlink",
                      !1,
                      !1
                    );
                  }),
                ["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
                  var t = e.replace(b, v);
                  h[t] = new g(
                    t,
                    1,
                    !1,
                    e,
                    "http://www.w3.org/XML/1998/namespace",
                    !1,
                    !1
                  );
                }),
                ["tabIndex", "crossOrigin"].forEach(function (e) {
                  h[e] = new g(e, 1, !1, e.toLowerCase(), null, !1, !1);
                }),
                (h.xlinkHref = new g(
                  "xlinkHref",
                  1,
                  !1,
                  "xlink:href",
                  "http://www.w3.org/1999/xlink",
                  !0,
                  !1
                )),
                ["src", "href", "action", "formAction"].forEach(function (e) {
                  h[e] = new g(e, 1, !1, e.toLowerCase(), null, !0, !0);
                });
              var z = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                y = Symbol.for("react.element"),
                A = Symbol.for("react.portal"),
                E = Symbol.for("react.fragment"),
                C = Symbol.for("react.strict_mode"),
                N = Symbol.for("react.profiler"),
                S = Symbol.for("react.provider"),
                R = Symbol.for("react.context"),
                w = Symbol.for("react.forward_ref"),
                D = Symbol.for("react.suspense"),
                F = Symbol.for("react.suspense_list"),
                _ = Symbol.for("react.memo"),
                k = Symbol.for("react.lazy");
              Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
              var B = Symbol.for("react.offscreen");
              Symbol.for("react.legacy_hidden"),
                Symbol.for("react.cache"),
                Symbol.for("react.tracing_marker");
              var O = Symbol.iterator;
              function P(e) {
                return null === e || "object" !== typeof e
                  ? null
                  : "function" === typeof (e = (O && e[O]) || e["@@iterator"])
                  ? e
                  : null;
              }
              var I,
                L = Object.assign;
              function T(e) {
                if (void 0 === I)
                  try {
                    throw Error();
                  } catch (a) {
                    var t = a.stack.trim().match(/\n( *(at )?)/);
                    I = (t && t[1]) || "";
                  }
                return "\n" + I + e;
              }
              var q = !1;
              function M(e, t) {
                if (!e || q) return "";
                q = !0;
                var a = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                  if (t)
                    if (
                      ((t = function () {
                        throw Error();
                      }),
                      Object.defineProperty(t.prototype, "props", {
                        set: function () {
                          throw Error();
                        },
                      }),
                      "object" === typeof Reflect && Reflect.construct)
                    ) {
                      try {
                        Reflect.construct(t, []);
                      } catch (s) {
                        var n = s;
                      }
                      Reflect.construct(e, [], t);
                    } else {
                      try {
                        t.call();
                      } catch (s) {
                        n = s;
                      }
                      e.call(t.prototype);
                    }
                  else {
                    try {
                      throw Error();
                    } catch (s) {
                      n = s;
                    }
                    e();
                  }
                } catch (s) {
                  if (s && n && "string" === typeof s.stack) {
                    for (
                      var i = s.stack.split("\n"),
                        r = n.stack.split("\n"),
                        l = i.length - 1,
                        o = r.length - 1;
                      1 <= l && 0 <= o && i[l] !== r[o];

                    )
                      o--;
                    for (; 1 <= l && 0 <= o; l--, o--)
                      if (i[l] !== r[o]) {
                        if (1 !== l || 1 !== o)
                          do {
                            if ((l--, 0 > --o || i[l] !== r[o])) {
                              var u = "\n" + i[l].replace(" at new ", " at ");
                              return (
                                e.displayName &&
                                  u.includes("<anonymous>") &&
                                  (u = u.replace("<anonymous>", e.displayName)),
                                u
                              );
                            }
                          } while (1 <= l && 0 <= o);
                        break;
                      }
                  }
                } finally {
                  (q = !1), (Error.prepareStackTrace = a);
                }
                return (e = e ? e.displayName || e.name : "") ? T(e) : "";
              }
              function j(e) {
                switch (e.tag) {
                  case 5:
                    return T(e.type);
                  case 16:
                    return T("Lazy");
                  case 13:
                    return T("Suspense");
                  case 19:
                    return T("SuspenseList");
                  case 0:
                  case 2:
                  case 15:
                    return (e = M(e.type, !1));
                  case 11:
                    return (e = M(e.type.render, !1));
                  case 1:
                    return (e = M(e.type, !0));
                  default:
                    return "";
                }
              }
              function U(e) {
                if (null == e) return null;
                if ("function" === typeof e)
                  return e.displayName || e.name || null;
                if ("string" === typeof e) return e;
                switch (e) {
                  case E:
                    return "Fragment";
                  case A:
                    return "Portal";
                  case N:
                    return "Profiler";
                  case C:
                    return "StrictMode";
                  case D:
                    return "Suspense";
                  case F:
                    return "SuspenseList";
                }
                if ("object" === typeof e)
                  switch (e.$$typeof) {
                    case R:
                      return (e.displayName || "Context") + ".Consumer";
                    case S:
                      return (
                        (e._context.displayName || "Context") + ".Provider"
                      );
                    case w:
                      var t = e.render;
                      return (
                        (e = e.displayName) ||
                          (e =
                            "" !== (e = t.displayName || t.name || "")
                              ? "ForwardRef(" + e + ")"
                              : "ForwardRef"),
                        e
                      );
                    case _:
                      return null !== (t = e.displayName || null)
                        ? t
                        : U(e.type) || "Memo";
                    case k:
                      (t = e._payload), (e = e._init);
                      try {
                        return U(e(t));
                      } catch (a) {}
                  }
                return null;
              }
              function Q(e) {
                var t = e.type;
                switch (e.tag) {
                  case 24:
                    return "Cache";
                  case 9:
                    return (t.displayName || "Context") + ".Consumer";
                  case 10:
                    return (t._context.displayName || "Context") + ".Provider";
                  case 18:
                    return "DehydratedFragment";
                  case 11:
                    return (
                      (e = (e = t.render).displayName || e.name || ""),
                      t.displayName ||
                        ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef")
                    );
                  case 7:
                    return "Fragment";
                  case 5:
                    return t;
                  case 4:
                    return "Portal";
                  case 3:
                    return "Root";
                  case 6:
                    return "Text";
                  case 16:
                    return U(t);
                  case 8:
                    return t === C ? "StrictMode" : "Mode";
                  case 22:
                    return "Offscreen";
                  case 12:
                    return "Profiler";
                  case 21:
                    return "Scope";
                  case 13:
                    return "Suspense";
                  case 19:
                    return "SuspenseList";
                  case 25:
                    return "TracingMarker";
                  case 1:
                  case 0:
                  case 17:
                  case 2:
                  case 14:
                  case 15:
                    if ("function" === typeof t)
                      return t.displayName || t.name || null;
                    if ("string" === typeof t) return t;
                }
                return null;
              }
              function Y(e) {
                switch (typeof e) {
                  case "boolean":
                  case "number":
                  case "string":
                  case "undefined":
                  case "object":
                    return e;
                  default:
                    return "";
                }
              }
              function H(e) {
                var t = e.type;
                return (
                  (e = e.nodeName) &&
                  "input" === e.toLowerCase() &&
                  ("checkbox" === t || "radio" === t)
                );
              }
              function X(e) {
                e._valueTracker ||
                  (e._valueTracker = (function (e) {
                    var t = H(e) ? "checked" : "value",
                      a = Object.getOwnPropertyDescriptor(
                        e.constructor.prototype,
                        t
                      ),
                      n = "" + e[t];
                    if (
                      !e.hasOwnProperty(t) &&
                      "undefined" !== typeof a &&
                      "function" === typeof a.get &&
                      "function" === typeof a.set
                    ) {
                      var i = a.get,
                        r = a.set;
                      return (
                        Object.defineProperty(e, t, {
                          configurable: !0,
                          get: function () {
                            return i.call(this);
                          },
                          set: function (e) {
                            (n = "" + e), r.call(this, e);
                          },
                        }),
                        Object.defineProperty(e, t, {
                          enumerable: a.enumerable,
                        }),
                        {
                          getValue: function () {
                            return n;
                          },
                          setValue: function (e) {
                            n = "" + e;
                          },
                          stopTracking: function () {
                            (e._valueTracker = null), delete e[t];
                          },
                        }
                      );
                    }
                  })(e));
              }
              function G(e) {
                if (!e) return !1;
                var t = e._valueTracker;
                if (!t) return !0;
                var a = t.getValue(),
                  n = "";
                return (
                  e && (n = H(e) ? (e.checked ? "true" : "false") : e.value),
                  (e = n) !== a && (t.setValue(e), !0)
                );
              }
              function W(e) {
                if (
                  "undefined" ===
                  typeof (e =
                    e || ("undefined" !== typeof document ? document : void 0))
                )
                  return null;
                try {
                  return e.activeElement || e.body;
                } catch (t) {
                  return e.body;
                }
              }
              function V(e, t) {
                var a = t.checked;
                return L({}, t, {
                  defaultChecked: void 0,
                  defaultValue: void 0,
                  value: void 0,
                  checked: null != a ? a : e._wrapperState.initialChecked,
                });
              }
              function $(e, t) {
                var a = null == t.defaultValue ? "" : t.defaultValue,
                  n = null != t.checked ? t.checked : t.defaultChecked;
                (a = Y(null != t.value ? t.value : a)),
                  (e._wrapperState = {
                    initialChecked: n,
                    initialValue: a,
                    controlled:
                      "checkbox" === t.type || "radio" === t.type
                        ? null != t.checked
                        : null != t.value,
                  });
              }
              function J(e, t) {
                null != (t = t.checked) && x(e, "checked", t, !1);
              }
              function K(e, t) {
                J(e, t);
                var a = Y(t.value),
                  n = t.type;
                if (null != a)
                  "number" === n
                    ? ((0 === a && "" === e.value) || e.value != a) &&
                      (e.value = "" + a)
                    : e.value !== "" + a && (e.value = "" + a);
                else if ("submit" === n || "reset" === n)
                  return void e.removeAttribute("value");
                t.hasOwnProperty("value")
                  ? ee(e, t.type, a)
                  : t.hasOwnProperty("defaultValue") &&
                    ee(e, t.type, Y(t.defaultValue)),
                  null == t.checked &&
                    null != t.defaultChecked &&
                    (e.defaultChecked = !!t.defaultChecked);
              }
              function Z(e, t, a) {
                if (
                  t.hasOwnProperty("value") ||
                  t.hasOwnProperty("defaultValue")
                ) {
                  var n = t.type;
                  if (
                    !(
                      ("submit" !== n && "reset" !== n) ||
                      (void 0 !== t.value && null !== t.value)
                    )
                  )
                    return;
                  (t = "" + e._wrapperState.initialValue),
                    a || t === e.value || (e.value = t),
                    (e.defaultValue = t);
                }
                "" !== (a = e.name) && (e.name = ""),
                  (e.defaultChecked = !!e._wrapperState.initialChecked),
                  "" !== a && (e.name = a);
              }
              function ee(e, t, a) {
                ("number" === t && W(e.ownerDocument) === e) ||
                  (null == a
                    ? (e.defaultValue = "" + e._wrapperState.initialValue)
                    : e.defaultValue !== "" + a && (e.defaultValue = "" + a));
              }
              var te = Array.isArray;
              function ae(e, t, a, n) {
                if (((e = e.options), t)) {
                  t = {};
                  for (var i = 0; i < a.length; i++) t["$" + a[i]] = !0;
                  for (a = 0; a < e.length; a++)
                    (i = t.hasOwnProperty("$" + e[a].value)),
                      e[a].selected !== i && (e[a].selected = i),
                      i && n && (e[a].defaultSelected = !0);
                } else {
                  for (a = "" + Y(a), t = null, i = 0; i < e.length; i++) {
                    if (e[i].value === a)
                      return (
                        (e[i].selected = !0),
                        void (n && (e[i].defaultSelected = !0))
                      );
                    null !== t || e[i].disabled || (t = e[i]);
                  }
                  null !== t && (t.selected = !0);
                }
              }
              function ne(e, t) {
                if (null != t.dangerouslySetInnerHTML) throw Error(r(91));
                return L({}, t, {
                  value: void 0,
                  defaultValue: void 0,
                  children: "" + e._wrapperState.initialValue,
                });
              }
              function ie(e, t) {
                var a = t.value;
                if (null == a) {
                  if (((a = t.children), (t = t.defaultValue), null != a)) {
                    if (null != t) throw Error(r(92));
                    if (te(a)) {
                      if (1 < a.length) throw Error(r(93));
                      a = a[0];
                    }
                    t = a;
                  }
                  null == t && (t = ""), (a = t);
                }
                e._wrapperState = { initialValue: Y(a) };
              }
              function re(e, t) {
                var a = Y(t.value),
                  n = Y(t.defaultValue);
                null != a &&
                  ((a = "" + a) !== e.value && (e.value = a),
                  null == t.defaultValue &&
                    e.defaultValue !== a &&
                    (e.defaultValue = a)),
                  null != n && (e.defaultValue = "" + n);
              }
              function le(e) {
                var t = e.textContent;
                t === e._wrapperState.initialValue &&
                  "" !== t &&
                  null !== t &&
                  (e.value = t);
              }
              function oe(e) {
                switch (e) {
                  case "svg":
                    return "http://www.w3.org/2000/svg";
                  case "math":
                    return "http://www.w3.org/1998/Math/MathML";
                  default:
                    return "http://www.w3.org/1999/xhtml";
                }
              }
              function ue(e, t) {
                return null == e || "http://www.w3.org/1999/xhtml" === e
                  ? oe(t)
                  : "http://www.w3.org/2000/svg" === e && "foreignObject" === t
                  ? "http://www.w3.org/1999/xhtml"
                  : e;
              }
              var se,
                ce,
                de =
                  ((ce = function (e, t) {
                    if (
                      "http://www.w3.org/2000/svg" !== e.namespaceURI ||
                      "innerHTML" in e
                    )
                      e.innerHTML = t;
                    else {
                      for (
                        (se = se || document.createElement("div")).innerHTML =
                          "<svg>" + t.valueOf().toString() + "</svg>",
                          t = se.firstChild;
                        e.firstChild;

                      )
                        e.removeChild(e.firstChild);
                      for (; t.firstChild; ) e.appendChild(t.firstChild);
                    }
                  }),
                  "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction
                    ? function (e, t, a, n) {
                        MSApp.execUnsafeLocalFunction(function () {
                          return ce(e, t);
                        });
                      }
                    : ce);
              function pe(e, t) {
                if (t) {
                  var a = e.firstChild;
                  if (a && a === e.lastChild && 3 === a.nodeType)
                    return void (a.nodeValue = t);
                }
                e.textContent = t;
              }
              var me = {
                  animationIterationCount: !0,
                  aspectRatio: !0,
                  borderImageOutset: !0,
                  borderImageSlice: !0,
                  borderImageWidth: !0,
                  boxFlex: !0,
                  boxFlexGroup: !0,
                  boxOrdinalGroup: !0,
                  columnCount: !0,
                  columns: !0,
                  flex: !0,
                  flexGrow: !0,
                  flexPositive: !0,
                  flexShrink: !0,
                  flexNegative: !0,
                  flexOrder: !0,
                  gridArea: !0,
                  gridRow: !0,
                  gridRowEnd: !0,
                  gridRowSpan: !0,
                  gridRowStart: !0,
                  gridColumn: !0,
                  gridColumnEnd: !0,
                  gridColumnSpan: !0,
                  gridColumnStart: !0,
                  fontWeight: !0,
                  lineClamp: !0,
                  lineHeight: !0,
                  opacity: !0,
                  order: !0,
                  orphans: !0,
                  tabSize: !0,
                  widows: !0,
                  zIndex: !0,
                  zoom: !0,
                  fillOpacity: !0,
                  floodOpacity: !0,
                  stopOpacity: !0,
                  strokeDasharray: !0,
                  strokeDashoffset: !0,
                  strokeMiterlimit: !0,
                  strokeOpacity: !0,
                  strokeWidth: !0,
                },
                fe = ["Webkit", "ms", "Moz", "O"];
              function ge(e, t, a) {
                return null == t || "boolean" === typeof t || "" === t
                  ? ""
                  : a ||
                    "number" !== typeof t ||
                    0 === t ||
                    (me.hasOwnProperty(e) && me[e])
                  ? ("" + t).trim()
                  : t + "px";
              }
              function he(e, t) {
                for (var a in ((e = e.style), t))
                  if (t.hasOwnProperty(a)) {
                    var n = 0 === a.indexOf("--"),
                      i = ge(a, t[a], n);
                    "float" === a && (a = "cssFloat"),
                      n ? e.setProperty(a, i) : (e[a] = i);
                  }
              }
              Object.keys(me).forEach(function (e) {
                fe.forEach(function (t) {
                  (t = t + e.charAt(0).toUpperCase() + e.substring(1)),
                    (me[t] = me[e]);
                });
              });
              var be = L(
                { menuitem: !0 },
                {
                  area: !0,
                  base: !0,
                  br: !0,
                  col: !0,
                  embed: !0,
                  hr: !0,
                  img: !0,
                  input: !0,
                  keygen: !0,
                  link: !0,
                  meta: !0,
                  param: !0,
                  source: !0,
                  track: !0,
                  wbr: !0,
                }
              );
              function ve(e, t) {
                if (t) {
                  if (
                    be[e] &&
                    (null != t.children || null != t.dangerouslySetInnerHTML)
                  )
                    throw Error(r(137, e));
                  if (null != t.dangerouslySetInnerHTML) {
                    if (null != t.children) throw Error(r(60));
                    if (
                      "object" !== typeof t.dangerouslySetInnerHTML ||
                      !("__html" in t.dangerouslySetInnerHTML)
                    )
                      throw Error(r(61));
                  }
                  if (null != t.style && "object" !== typeof t.style)
                    throw Error(r(62));
                }
              }
              function xe(e, t) {
                if (-1 === e.indexOf("-")) return "string" === typeof t.is;
                switch (e) {
                  case "annotation-xml":
                  case "color-profile":
                  case "font-face":
                  case "font-face-src":
                  case "font-face-uri":
                  case "font-face-format":
                  case "font-face-name":
                  case "missing-glyph":
                    return !1;
                  default:
                    return !0;
                }
              }
              var ze = null;
              function ye(e) {
                return (
                  (e = e.target || e.srcElement || window)
                    .correspondingUseElement && (e = e.correspondingUseElement),
                  3 === e.nodeType ? e.parentNode : e
                );
              }
              var Ae = null,
                Ee = null,
                Ce = null;
              function Ne(e) {
                if ((e = xi(e))) {
                  if ("function" !== typeof Ae) throw Error(r(280));
                  var t = e.stateNode;
                  t && ((t = yi(t)), Ae(e.stateNode, e.type, t));
                }
              }
              function Se(e) {
                Ee ? (Ce ? Ce.push(e) : (Ce = [e])) : (Ee = e);
              }
              function Re() {
                if (Ee) {
                  var e = Ee,
                    t = Ce;
                  if (((Ce = Ee = null), Ne(e), t))
                    for (e = 0; e < t.length; e++) Ne(t[e]);
                }
              }
              function we(e, t) {
                return e(t);
              }
              function De() {}
              var Fe = !1;
              function _e(e, t, a) {
                if (Fe) return e(t, a);
                Fe = !0;
                try {
                  return we(e, t, a);
                } finally {
                  (Fe = !1), (null !== Ee || null !== Ce) && (De(), Re());
                }
              }
              function ke(e, t) {
                var a = e.stateNode;
                if (null === a) return null;
                var n = yi(a);
                if (null === n) return null;
                a = n[t];
                e: switch (t) {
                  case "onClick":
                  case "onClickCapture":
                  case "onDoubleClick":
                  case "onDoubleClickCapture":
                  case "onMouseDown":
                  case "onMouseDownCapture":
                  case "onMouseMove":
                  case "onMouseMoveCapture":
                  case "onMouseUp":
                  case "onMouseUpCapture":
                  case "onMouseEnter":
                    (n = !n.disabled) ||
                      (n = !(
                        "button" === (e = e.type) ||
                        "input" === e ||
                        "select" === e ||
                        "textarea" === e
                      )),
                      (e = !n);
                    break e;
                  default:
                    e = !1;
                }
                if (e) return null;
                if (a && "function" !== typeof a)
                  throw Error(r(231, t, typeof a));
                return a;
              }
              var Be = !1;
              if (c)
                try {
                  var Oe = {};
                  Object.defineProperty(Oe, "passive", {
                    get: function () {
                      Be = !0;
                    },
                  }),
                    window.addEventListener("test", Oe, Oe),
                    window.removeEventListener("test", Oe, Oe);
                } catch (ce) {
                  Be = !1;
                }
              function Pe(e, t, a, n, i, r, l, o, u) {
                var s = Array.prototype.slice.call(arguments, 3);
                try {
                  t.apply(a, s);
                } catch (c) {
                  this.onError(c);
                }
              }
              var Ie = !1,
                Le = null,
                Te = !1,
                qe = null,
                Me = {
                  onError: function (e) {
                    (Ie = !0), (Le = e);
                  },
                };
              function je(e, t, a, n, i, r, l, o, u) {
                (Ie = !1), (Le = null), Pe.apply(Me, arguments);
              }
              function Ue(e) {
                var t = e,
                  a = e;
                if (e.alternate) for (; t.return; ) t = t.return;
                else {
                  e = t;
                  do {
                    0 !== (4098 & (t = e).flags) && (a = t.return),
                      (e = t.return);
                  } while (e);
                }
                return 3 === t.tag ? a : null;
              }
              function Qe(e) {
                if (13 === e.tag) {
                  var t = e.memoizedState;
                  if (
                    (null === t &&
                      null !== (e = e.alternate) &&
                      (t = e.memoizedState),
                    null !== t)
                  )
                    return t.dehydrated;
                }
                return null;
              }
              function Ye(e) {
                if (Ue(e) !== e) throw Error(r(188));
              }
              function He(e) {
                return null !==
                  (e = (function (e) {
                    var t = e.alternate;
                    if (!t) {
                      if (null === (t = Ue(e))) throw Error(r(188));
                      return t !== e ? null : e;
                    }
                    for (var a = e, n = t; ; ) {
                      var i = a.return;
                      if (null === i) break;
                      var l = i.alternate;
                      if (null === l) {
                        if (null !== (n = i.return)) {
                          a = n;
                          continue;
                        }
                        break;
                      }
                      if (i.child === l.child) {
                        for (l = i.child; l; ) {
                          if (l === a) return Ye(i), e;
                          if (l === n) return Ye(i), t;
                          l = l.sibling;
                        }
                        throw Error(r(188));
                      }
                      if (a.return !== n.return) (a = i), (n = l);
                      else {
                        for (var o = !1, u = i.child; u; ) {
                          if (u === a) {
                            (o = !0), (a = i), (n = l);
                            break;
                          }
                          if (u === n) {
                            (o = !0), (n = i), (a = l);
                            break;
                          }
                          u = u.sibling;
                        }
                        if (!o) {
                          for (u = l.child; u; ) {
                            if (u === a) {
                              (o = !0), (a = l), (n = i);
                              break;
                            }
                            if (u === n) {
                              (o = !0), (n = l), (a = i);
                              break;
                            }
                            u = u.sibling;
                          }
                          if (!o) throw Error(r(189));
                        }
                      }
                      if (a.alternate !== n) throw Error(r(190));
                    }
                    if (3 !== a.tag) throw Error(r(188));
                    return a.stateNode.current === a ? e : t;
                  })(e))
                  ? Xe(e)
                  : null;
              }
              function Xe(e) {
                if (5 === e.tag || 6 === e.tag) return e;
                for (e = e.child; null !== e; ) {
                  var t = Xe(e);
                  if (null !== t) return t;
                  e = e.sibling;
                }
                return null;
              }
              var Ge = i.unstable_scheduleCallback,
                We = i.unstable_cancelCallback,
                Ve = i.unstable_shouldYield,
                $e = i.unstable_requestPaint,
                Je = i.unstable_now,
                Ke = i.unstable_getCurrentPriorityLevel,
                Ze = i.unstable_ImmediatePriority,
                et = i.unstable_UserBlockingPriority,
                tt = i.unstable_NormalPriority,
                at = i.unstable_LowPriority,
                nt = i.unstable_IdlePriority,
                it = null,
                rt = null;
              var lt = Math.clz32
                  ? Math.clz32
                  : function (e) {
                      return (
                        (e >>>= 0), 0 === e ? 32 : (31 - ((ot(e) / ut) | 0)) | 0
                      );
                    },
                ot = Math.log,
                ut = Math.LN2;
              var st = 64,
                ct = 4194304;
              function dt(e) {
                switch (e & -e) {
                  case 1:
                    return 1;
                  case 2:
                    return 2;
                  case 4:
                    return 4;
                  case 8:
                    return 8;
                  case 16:
                    return 16;
                  case 32:
                    return 32;
                  case 64:
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                    return 4194240 & e;
                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                  case 67108864:
                    return 130023424 & e;
                  case 134217728:
                    return 134217728;
                  case 268435456:
                    return 268435456;
                  case 536870912:
                    return 536870912;
                  case 1073741824:
                    return 1073741824;
                  default:
                    return e;
                }
              }
              function pt(e, t) {
                var a = e.pendingLanes;
                if (0 === a) return 0;
                var n = 0,
                  i = e.suspendedLanes,
                  r = e.pingedLanes,
                  l = 268435455 & a;
                if (0 !== l) {
                  var o = l & ~i;
                  0 !== o ? (n = dt(o)) : 0 !== (r &= l) && (n = dt(r));
                } else
                  0 !== (l = a & ~i) ? (n = dt(l)) : 0 !== r && (n = dt(r));
                if (0 === n) return 0;
                if (
                  0 !== t &&
                  t !== n &&
                  0 === (t & i) &&
                  ((i = n & -n) >= (r = t & -t) ||
                    (16 === i && 0 !== (4194240 & r)))
                )
                  return t;
                if (
                  (0 !== (4 & n) && (n |= 16 & a), 0 !== (t = e.entangledLanes))
                )
                  for (e = e.entanglements, t &= n; 0 < t; )
                    (i = 1 << (a = 31 - lt(t))), (n |= e[a]), (t &= ~i);
                return n;
              }
              function mt(e, t) {
                switch (e) {
                  case 1:
                  case 2:
                  case 4:
                    return t + 250;
                  case 8:
                  case 16:
                  case 32:
                  case 64:
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                    return t + 5e3;
                  default:
                    return -1;
                }
              }
              function ft(e) {
                return 0 !== (e = -1073741825 & e.pendingLanes)
                  ? e
                  : 1073741824 & e
                  ? 1073741824
                  : 0;
              }
              function gt() {
                var e = st;
                return 0 === (4194240 & (st <<= 1)) && (st = 64), e;
              }
              function ht(e) {
                for (var t = [], a = 0; 31 > a; a++) t.push(e);
                return t;
              }
              function bt(e, t, a) {
                (e.pendingLanes |= t),
                  536870912 !== t &&
                    ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
                  ((e = e.eventTimes)[(t = 31 - lt(t))] = a);
              }
              function vt(e, t) {
                var a = (e.entangledLanes |= t);
                for (e = e.entanglements; a; ) {
                  var n = 31 - lt(a),
                    i = 1 << n;
                  (i & t) | (e[n] & t) && (e[n] |= t), (a &= ~i);
                }
              }
              var xt = 0;
              function zt(e) {
                return 1 < (e &= -e)
                  ? 4 < e
                    ? 0 !== (268435455 & e)
                      ? 16
                      : 536870912
                    : 4
                  : 1;
              }
              var yt,
                At,
                Et,
                Ct,
                Nt,
                St = !1,
                Rt = [],
                wt = null,
                Dt = null,
                Ft = null,
                _t = new Map(),
                kt = new Map(),
                Bt = [],
                Ot =
                  "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
                    " "
                  );
              function Pt(e, t) {
                switch (e) {
                  case "focusin":
                  case "focusout":
                    wt = null;
                    break;
                  case "dragenter":
                  case "dragleave":
                    Dt = null;
                    break;
                  case "mouseover":
                  case "mouseout":
                    Ft = null;
                    break;
                  case "pointerover":
                  case "pointerout":
                    _t.delete(t.pointerId);
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                    kt.delete(t.pointerId);
                }
              }
              function It(e, t, a, n, i, r) {
                return null === e || e.nativeEvent !== r
                  ? ((e = {
                      blockedOn: t,
                      domEventName: a,
                      eventSystemFlags: n,
                      nativeEvent: r,
                      targetContainers: [i],
                    }),
                    null !== t && null !== (t = xi(t)) && At(t),
                    e)
                  : ((e.eventSystemFlags |= n),
                    (t = e.targetContainers),
                    null !== i && -1 === t.indexOf(i) && t.push(i),
                    e);
              }
              function Lt(e) {
                var t = vi(e.target);
                if (null !== t) {
                  var a = Ue(t);
                  if (null !== a)
                    if (13 === (t = a.tag)) {
                      if (null !== (t = Qe(a)))
                        return (
                          (e.blockedOn = t),
                          void Nt(e.priority, function () {
                            Et(a);
                          })
                        );
                    } else if (
                      3 === t &&
                      a.stateNode.current.memoizedState.isDehydrated
                    )
                      return void (e.blockedOn =
                        3 === a.tag ? a.stateNode.containerInfo : null);
                }
                e.blockedOn = null;
              }
              function Tt(e) {
                if (null !== e.blockedOn) return !1;
                for (var t = e.targetContainers; 0 < t.length; ) {
                  var a = Vt(
                    e.domEventName,
                    e.eventSystemFlags,
                    t[0],
                    e.nativeEvent
                  );
                  if (null !== a)
                    return null !== (t = xi(a)) && At(t), (e.blockedOn = a), !1;
                  var n = new (a = e.nativeEvent).constructor(a.type, a);
                  (ze = n), a.target.dispatchEvent(n), (ze = null), t.shift();
                }
                return !0;
              }
              function qt(e, t, a) {
                Tt(e) && a.delete(t);
              }
              function Mt() {
                (St = !1),
                  null !== wt && Tt(wt) && (wt = null),
                  null !== Dt && Tt(Dt) && (Dt = null),
                  null !== Ft && Tt(Ft) && (Ft = null),
                  _t.forEach(qt),
                  kt.forEach(qt);
              }
              function jt(e, t) {
                e.blockedOn === t &&
                  ((e.blockedOn = null),
                  St ||
                    ((St = !0),
                    i.unstable_scheduleCallback(
                      i.unstable_NormalPriority,
                      Mt
                    )));
              }
              function Ut(e) {
                function t(t) {
                  return jt(t, e);
                }
                if (0 < Rt.length) {
                  jt(Rt[0], e);
                  for (var a = 1; a < Rt.length; a++) {
                    var n = Rt[a];
                    n.blockedOn === e && (n.blockedOn = null);
                  }
                }
                for (
                  null !== wt && jt(wt, e),
                    null !== Dt && jt(Dt, e),
                    null !== Ft && jt(Ft, e),
                    _t.forEach(t),
                    kt.forEach(t),
                    a = 0;
                  a < Bt.length;
                  a++
                )
                  (n = Bt[a]).blockedOn === e && (n.blockedOn = null);
                for (; 0 < Bt.length && null === (a = Bt[0]).blockedOn; )
                  Lt(a), null === a.blockedOn && Bt.shift();
              }
              var Qt = z.ReactCurrentBatchConfig,
                Yt = !0;
              function Ht(e, t, a, n) {
                var i = xt,
                  r = Qt.transition;
                Qt.transition = null;
                try {
                  (xt = 1), Gt(e, t, a, n);
                } finally {
                  (xt = i), (Qt.transition = r);
                }
              }
              function Xt(e, t, a, n) {
                var i = xt,
                  r = Qt.transition;
                Qt.transition = null;
                try {
                  (xt = 4), Gt(e, t, a, n);
                } finally {
                  (xt = i), (Qt.transition = r);
                }
              }
              function Gt(e, t, a, n) {
                if (Yt) {
                  var i = Vt(e, t, a, n);
                  if (null === i) Yn(e, t, n, Wt, a), Pt(e, n);
                  else if (
                    (function (e, t, a, n, i) {
                      switch (t) {
                        case "focusin":
                          return (wt = It(wt, e, t, a, n, i)), !0;
                        case "dragenter":
                          return (Dt = It(Dt, e, t, a, n, i)), !0;
                        case "mouseover":
                          return (Ft = It(Ft, e, t, a, n, i)), !0;
                        case "pointerover":
                          var r = i.pointerId;
                          return (
                            _t.set(r, It(_t.get(r) || null, e, t, a, n, i)), !0
                          );
                        case "gotpointercapture":
                          return (
                            (r = i.pointerId),
                            kt.set(r, It(kt.get(r) || null, e, t, a, n, i)),
                            !0
                          );
                      }
                      return !1;
                    })(i, e, t, a, n)
                  )
                    n.stopPropagation();
                  else if ((Pt(e, n), 4 & t && -1 < Ot.indexOf(e))) {
                    for (; null !== i; ) {
                      var r = xi(i);
                      if (
                        (null !== r && yt(r),
                        null === (r = Vt(e, t, a, n)) && Yn(e, t, n, Wt, a),
                        r === i)
                      )
                        break;
                      i = r;
                    }
                    null !== i && n.stopPropagation();
                  } else Yn(e, t, n, null, a);
                }
              }
              var Wt = null;
              function Vt(e, t, a, n) {
                if (((Wt = null), null !== (e = vi((e = ye(n))))))
                  if (null === (t = Ue(e))) e = null;
                  else if (13 === (a = t.tag)) {
                    if (null !== (e = Qe(t))) return e;
                    e = null;
                  } else if (3 === a) {
                    if (t.stateNode.current.memoizedState.isDehydrated)
                      return 3 === t.tag ? t.stateNode.containerInfo : null;
                    e = null;
                  } else t !== e && (e = null);
                return (Wt = e), null;
              }
              function $t(e) {
                switch (e) {
                  case "cancel":
                  case "click":
                  case "close":
                  case "contextmenu":
                  case "copy":
                  case "cut":
                  case "auxclick":
                  case "dblclick":
                  case "dragend":
                  case "dragstart":
                  case "drop":
                  case "focusin":
                  case "focusout":
                  case "input":
                  case "invalid":
                  case "keydown":
                  case "keypress":
                  case "keyup":
                  case "mousedown":
                  case "mouseup":
                  case "paste":
                  case "pause":
                  case "play":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointerup":
                  case "ratechange":
                  case "reset":
                  case "resize":
                  case "seeked":
                  case "submit":
                  case "touchcancel":
                  case "touchend":
                  case "touchstart":
                  case "volumechange":
                  case "change":
                  case "selectionchange":
                  case "textInput":
                  case "compositionstart":
                  case "compositionend":
                  case "compositionupdate":
                  case "beforeblur":
                  case "afterblur":
                  case "beforeinput":
                  case "blur":
                  case "fullscreenchange":
                  case "focus":
                  case "hashchange":
                  case "popstate":
                  case "select":
                  case "selectstart":
                    return 1;
                  case "drag":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "mousemove":
                  case "mouseout":
                  case "mouseover":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "scroll":
                  case "toggle":
                  case "touchmove":
                  case "wheel":
                  case "mouseenter":
                  case "mouseleave":
                  case "pointerenter":
                  case "pointerleave":
                    return 4;
                  case "message":
                    switch (Ke()) {
                      case Ze:
                        return 1;
                      case et:
                        return 4;
                      case tt:
                      case at:
                        return 16;
                      case nt:
                        return 536870912;
                      default:
                        return 16;
                    }
                  default:
                    return 16;
                }
              }
              var Jt = null,
                Kt = null,
                Zt = null;
              function ea() {
                if (Zt) return Zt;
                var e,
                  t,
                  a = Kt,
                  n = a.length,
                  i = "value" in Jt ? Jt.value : Jt.textContent,
                  r = i.length;
                for (e = 0; e < n && a[e] === i[e]; e++);
                var l = n - e;
                for (t = 1; t <= l && a[n - t] === i[r - t]; t++);
                return (Zt = i.slice(e, 1 < t ? 1 - t : void 0));
              }
              function ta(e) {
                var t = e.keyCode;
                return (
                  "charCode" in e
                    ? 0 === (e = e.charCode) && 13 === t && (e = 13)
                    : (e = t),
                  10 === e && (e = 13),
                  32 <= e || 13 === e ? e : 0
                );
              }
              function aa() {
                return !0;
              }
              function na() {
                return !1;
              }
              function ia(e) {
                function t(t, a, n, i, r) {
                  for (var l in ((this._reactName = t),
                  (this._targetInst = n),
                  (this.type = a),
                  (this.nativeEvent = i),
                  (this.target = r),
                  (this.currentTarget = null),
                  e))
                    e.hasOwnProperty(l) &&
                      ((t = e[l]), (this[l] = t ? t(i) : i[l]));
                  return (
                    (this.isDefaultPrevented = (
                      null != i.defaultPrevented
                        ? i.defaultPrevented
                        : !1 === i.returnValue
                    )
                      ? aa
                      : na),
                    (this.isPropagationStopped = na),
                    this
                  );
                }
                return (
                  L(t.prototype, {
                    preventDefault: function () {
                      this.defaultPrevented = !0;
                      var e = this.nativeEvent;
                      e &&
                        (e.preventDefault
                          ? e.preventDefault()
                          : "unknown" !== typeof e.returnValue &&
                            (e.returnValue = !1),
                        (this.isDefaultPrevented = aa));
                    },
                    stopPropagation: function () {
                      var e = this.nativeEvent;
                      e &&
                        (e.stopPropagation
                          ? e.stopPropagation()
                          : "unknown" !== typeof e.cancelBubble &&
                            (e.cancelBubble = !0),
                        (this.isPropagationStopped = aa));
                    },
                    persist: function () {},
                    isPersistent: aa,
                  }),
                  t
                );
              }
              var ra,
                la,
                oa,
                ua = {
                  eventPhase: 0,
                  bubbles: 0,
                  cancelable: 0,
                  timeStamp: function (e) {
                    return e.timeStamp || Date.now();
                  },
                  defaultPrevented: 0,
                  isTrusted: 0,
                },
                sa = ia(ua),
                ca = L({}, ua, { view: 0, detail: 0 }),
                da = ia(ca),
                pa = L({}, ca, {
                  screenX: 0,
                  screenY: 0,
                  clientX: 0,
                  clientY: 0,
                  pageX: 0,
                  pageY: 0,
                  ctrlKey: 0,
                  shiftKey: 0,
                  altKey: 0,
                  metaKey: 0,
                  getModifierState: Ca,
                  button: 0,
                  buttons: 0,
                  relatedTarget: function (e) {
                    return void 0 === e.relatedTarget
                      ? e.fromElement === e.srcElement
                        ? e.toElement
                        : e.fromElement
                      : e.relatedTarget;
                  },
                  movementX: function (e) {
                    return "movementX" in e
                      ? e.movementX
                      : (e !== oa &&
                          (oa && "mousemove" === e.type
                            ? ((ra = e.screenX - oa.screenX),
                              (la = e.screenY - oa.screenY))
                            : (la = ra = 0),
                          (oa = e)),
                        ra);
                  },
                  movementY: function (e) {
                    return "movementY" in e ? e.movementY : la;
                  },
                }),
                ma = ia(pa),
                fa = ia(L({}, pa, { dataTransfer: 0 })),
                ga = ia(L({}, ca, { relatedTarget: 0 })),
                ha = ia(
                  L({}, ua, {
                    animationName: 0,
                    elapsedTime: 0,
                    pseudoElement: 0,
                  })
                ),
                ba = L({}, ua, {
                  clipboardData: function (e) {
                    return "clipboardData" in e
                      ? e.clipboardData
                      : window.clipboardData;
                  },
                }),
                va = ia(ba),
                xa = ia(L({}, ua, { data: 0 })),
                za = {
                  Esc: "Escape",
                  Spacebar: " ",
                  Left: "ArrowLeft",
                  Up: "ArrowUp",
                  Right: "ArrowRight",
                  Down: "ArrowDown",
                  Del: "Delete",
                  Win: "OS",
                  Menu: "ContextMenu",
                  Apps: "ContextMenu",
                  Scroll: "ScrollLock",
                  MozPrintableKey: "Unidentified",
                },
                ya = {
                  8: "Backspace",
                  9: "Tab",
                  12: "Clear",
                  13: "Enter",
                  16: "Shift",
                  17: "Control",
                  18: "Alt",
                  19: "Pause",
                  20: "CapsLock",
                  27: "Escape",
                  32: " ",
                  33: "PageUp",
                  34: "PageDown",
                  35: "End",
                  36: "Home",
                  37: "ArrowLeft",
                  38: "ArrowUp",
                  39: "ArrowRight",
                  40: "ArrowDown",
                  45: "Insert",
                  46: "Delete",
                  112: "F1",
                  113: "F2",
                  114: "F3",
                  115: "F4",
                  116: "F5",
                  117: "F6",
                  118: "F7",
                  119: "F8",
                  120: "F9",
                  121: "F10",
                  122: "F11",
                  123: "F12",
                  144: "NumLock",
                  145: "ScrollLock",
                  224: "Meta",
                },
                Aa = {
                  Alt: "altKey",
                  Control: "ctrlKey",
                  Meta: "metaKey",
                  Shift: "shiftKey",
                };
              function Ea(e) {
                var t = this.nativeEvent;
                return t.getModifierState
                  ? t.getModifierState(e)
                  : !!(e = Aa[e]) && !!t[e];
              }
              function Ca() {
                return Ea;
              }
              var Na = L({}, ca, {
                  key: function (e) {
                    if (e.key) {
                      var t = za[e.key] || e.key;
                      if ("Unidentified" !== t) return t;
                    }
                    return "keypress" === e.type
                      ? 13 === (e = ta(e))
                        ? "Enter"
                        : String.fromCharCode(e)
                      : "keydown" === e.type || "keyup" === e.type
                      ? ya[e.keyCode] || "Unidentified"
                      : "";
                  },
                  code: 0,
                  location: 0,
                  ctrlKey: 0,
                  shiftKey: 0,
                  altKey: 0,
                  metaKey: 0,
                  repeat: 0,
                  locale: 0,
                  getModifierState: Ca,
                  charCode: function (e) {
                    return "keypress" === e.type ? ta(e) : 0;
                  },
                  keyCode: function (e) {
                    return "keydown" === e.type || "keyup" === e.type
                      ? e.keyCode
                      : 0;
                  },
                  which: function (e) {
                    return "keypress" === e.type
                      ? ta(e)
                      : "keydown" === e.type || "keyup" === e.type
                      ? e.keyCode
                      : 0;
                  },
                }),
                Sa = ia(Na),
                Ra = ia(
                  L({}, pa, {
                    pointerId: 0,
                    width: 0,
                    height: 0,
                    pressure: 0,
                    tangentialPressure: 0,
                    tiltX: 0,
                    tiltY: 0,
                    twist: 0,
                    pointerType: 0,
                    isPrimary: 0,
                  })
                ),
                wa = ia(
                  L({}, ca, {
                    touches: 0,
                    targetTouches: 0,
                    changedTouches: 0,
                    altKey: 0,
                    metaKey: 0,
                    ctrlKey: 0,
                    shiftKey: 0,
                    getModifierState: Ca,
                  })
                ),
                Da = ia(
                  L({}, ua, {
                    propertyName: 0,
                    elapsedTime: 0,
                    pseudoElement: 0,
                  })
                ),
                Fa = L({}, pa, {
                  deltaX: function (e) {
                    return "deltaX" in e
                      ? e.deltaX
                      : "wheelDeltaX" in e
                      ? -e.wheelDeltaX
                      : 0;
                  },
                  deltaY: function (e) {
                    return "deltaY" in e
                      ? e.deltaY
                      : "wheelDeltaY" in e
                      ? -e.wheelDeltaY
                      : "wheelDelta" in e
                      ? -e.wheelDelta
                      : 0;
                  },
                  deltaZ: 0,
                  deltaMode: 0,
                }),
                _a = ia(Fa),
                ka = [9, 13, 27, 32],
                Ba = c && "CompositionEvent" in window,
                Oa = null;
              c && "documentMode" in document && (Oa = document.documentMode);
              var Pa = c && "TextEvent" in window && !Oa,
                Ia = c && (!Ba || (Oa && 8 < Oa && 11 >= Oa)),
                La = String.fromCharCode(32),
                Ta = !1;
              function qa(e, t) {
                switch (e) {
                  case "keyup":
                    return -1 !== ka.indexOf(t.keyCode);
                  case "keydown":
                    return 229 !== t.keyCode;
                  case "keypress":
                  case "mousedown":
                  case "focusout":
                    return !0;
                  default:
                    return !1;
                }
              }
              function Ma(e) {
                return "object" === typeof (e = e.detail) && "data" in e
                  ? e.data
                  : null;
              }
              var ja = !1;
              var Ua = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0,
              };
              function Qa(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return "input" === t ? !!Ua[e.type] : "textarea" === t;
              }
              function Ya(e, t, a, n) {
                Se(n),
                  0 < (t = Xn(t, "onChange")).length &&
                    ((a = new sa("onChange", "change", null, a, n)),
                    e.push({ event: a, listeners: t }));
              }
              var Ha = null,
                Xa = null;
              function Ga(e) {
                Tn(e, 0);
              }
              function Wa(e) {
                if (G(zi(e))) return e;
              }
              function Va(e, t) {
                if ("change" === e) return t;
              }
              var $a = !1;
              if (c) {
                var Ja;
                if (c) {
                  var Ka = "oninput" in document;
                  if (!Ka) {
                    var Za = document.createElement("div");
                    Za.setAttribute("oninput", "return;"),
                      (Ka = "function" === typeof Za.oninput);
                  }
                  Ja = Ka;
                } else Ja = !1;
                $a =
                  Ja && (!document.documentMode || 9 < document.documentMode);
              }
              function en() {
                Ha &&
                  (Ha.detachEvent("onpropertychange", tn), (Xa = Ha = null));
              }
              function tn(e) {
                if ("value" === e.propertyName && Wa(Xa)) {
                  var t = [];
                  Ya(t, Xa, e, ye(e)), _e(Ga, t);
                }
              }
              function an(e, t, a) {
                "focusin" === e
                  ? (en(),
                    (Xa = a),
                    (Ha = t).attachEvent("onpropertychange", tn))
                  : "focusout" === e && en();
              }
              function nn(e) {
                if ("selectionchange" === e || "keyup" === e || "keydown" === e)
                  return Wa(Xa);
              }
              function rn(e, t) {
                if ("click" === e) return Wa(t);
              }
              function ln(e, t) {
                if ("input" === e || "change" === e) return Wa(t);
              }
              var on =
                "function" === typeof Object.is
                  ? Object.is
                  : function (e, t) {
                      return (
                        (e === t && (0 !== e || 1 / e === 1 / t)) ||
                        (e !== e && t !== t)
                      );
                    };
              function un(e, t) {
                if (on(e, t)) return !0;
                if (
                  "object" !== typeof e ||
                  null === e ||
                  "object" !== typeof t ||
                  null === t
                )
                  return !1;
                var a = Object.keys(e),
                  n = Object.keys(t);
                if (a.length !== n.length) return !1;
                for (n = 0; n < a.length; n++) {
                  var i = a[n];
                  if (!d.call(t, i) || !on(e[i], t[i])) return !1;
                }
                return !0;
              }
              function sn(e) {
                for (; e && e.firstChild; ) e = e.firstChild;
                return e;
              }
              function cn(e, t) {
                var a,
                  n = sn(e);
                for (e = 0; n; ) {
                  if (3 === n.nodeType) {
                    if (((a = e + n.textContent.length), e <= t && a >= t))
                      return { node: n, offset: t - e };
                    e = a;
                  }
                  e: {
                    for (; n; ) {
                      if (n.nextSibling) {
                        n = n.nextSibling;
                        break e;
                      }
                      n = n.parentNode;
                    }
                    n = void 0;
                  }
                  n = sn(n);
                }
              }
              function dn(e, t) {
                return (
                  !(!e || !t) &&
                  (e === t ||
                    ((!e || 3 !== e.nodeType) &&
                      (t && 3 === t.nodeType
                        ? dn(e, t.parentNode)
                        : "contains" in e
                        ? e.contains(t)
                        : !!e.compareDocumentPosition &&
                          !!(16 & e.compareDocumentPosition(t)))))
                );
              }
              function pn() {
                for (
                  var e = window, t = W();
                  t instanceof e.HTMLIFrameElement;

                ) {
                  try {
                    var a = "string" === typeof t.contentWindow.location.href;
                  } catch (n) {
                    a = !1;
                  }
                  if (!a) break;
                  t = W((e = t.contentWindow).document);
                }
                return t;
              }
              function mn(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return (
                  t &&
                  (("input" === t &&
                    ("text" === e.type ||
                      "search" === e.type ||
                      "tel" === e.type ||
                      "url" === e.type ||
                      "password" === e.type)) ||
                    "textarea" === t ||
                    "true" === e.contentEditable)
                );
              }
              function fn(e) {
                var t = pn(),
                  a = e.focusedElem,
                  n = e.selectionRange;
                if (
                  t !== a &&
                  a &&
                  a.ownerDocument &&
                  dn(a.ownerDocument.documentElement, a)
                ) {
                  if (null !== n && mn(a))
                    if (
                      ((t = n.start),
                      void 0 === (e = n.end) && (e = t),
                      "selectionStart" in a)
                    )
                      (a.selectionStart = t),
                        (a.selectionEnd = Math.min(e, a.value.length));
                    else if (
                      (e =
                        ((t = a.ownerDocument || document) && t.defaultView) ||
                        window).getSelection
                    ) {
                      e = e.getSelection();
                      var i = a.textContent.length,
                        r = Math.min(n.start, i);
                      (n = void 0 === n.end ? r : Math.min(n.end, i)),
                        !e.extend && r > n && ((i = n), (n = r), (r = i)),
                        (i = cn(a, r));
                      var l = cn(a, n);
                      i &&
                        l &&
                        (1 !== e.rangeCount ||
                          e.anchorNode !== i.node ||
                          e.anchorOffset !== i.offset ||
                          e.focusNode !== l.node ||
                          e.focusOffset !== l.offset) &&
                        ((t = t.createRange()).setStart(i.node, i.offset),
                        e.removeAllRanges(),
                        r > n
                          ? (e.addRange(t), e.extend(l.node, l.offset))
                          : (t.setEnd(l.node, l.offset), e.addRange(t)));
                    }
                  for (t = [], e = a; (e = e.parentNode); )
                    1 === e.nodeType &&
                      t.push({
                        element: e,
                        left: e.scrollLeft,
                        top: e.scrollTop,
                      });
                  for (
                    "function" === typeof a.focus && a.focus(), a = 0;
                    a < t.length;
                    a++
                  )
                    ((e = t[a]).element.scrollLeft = e.left),
                      (e.element.scrollTop = e.top);
                }
              }
              var gn =
                  c &&
                  "documentMode" in document &&
                  11 >= document.documentMode,
                hn = null,
                bn = null,
                vn = null,
                xn = !1;
              function zn(e, t, a) {
                var n =
                  a.window === a
                    ? a.document
                    : 9 === a.nodeType
                    ? a
                    : a.ownerDocument;
                xn ||
                  null == hn ||
                  hn !== W(n) ||
                  ("selectionStart" in (n = hn) && mn(n)
                    ? (n = { start: n.selectionStart, end: n.selectionEnd })
                    : (n = {
                        anchorNode: (n = (
                          (n.ownerDocument && n.ownerDocument.defaultView) ||
                          window
                        ).getSelection()).anchorNode,
                        anchorOffset: n.anchorOffset,
                        focusNode: n.focusNode,
                        focusOffset: n.focusOffset,
                      }),
                  (vn && un(vn, n)) ||
                    ((vn = n),
                    0 < (n = Xn(bn, "onSelect")).length &&
                      ((t = new sa("onSelect", "select", null, t, a)),
                      e.push({ event: t, listeners: n }),
                      (t.target = hn))));
              }
              function yn(e, t) {
                var a = {};
                return (
                  (a[e.toLowerCase()] = t.toLowerCase()),
                  (a["Webkit" + e] = "webkit" + t),
                  (a["Moz" + e] = "moz" + t),
                  a
                );
              }
              var An = {
                  animationend: yn("Animation", "AnimationEnd"),
                  animationiteration: yn("Animation", "AnimationIteration"),
                  animationstart: yn("Animation", "AnimationStart"),
                  transitionend: yn("Transition", "TransitionEnd"),
                },
                En = {},
                Cn = {};
              function Nn(e) {
                if (En[e]) return En[e];
                if (!An[e]) return e;
                var t,
                  a = An[e];
                for (t in a)
                  if (a.hasOwnProperty(t) && t in Cn) return (En[e] = a[t]);
                return e;
              }
              c &&
                ((Cn = document.createElement("div").style),
                "AnimationEvent" in window ||
                  (delete An.animationend.animation,
                  delete An.animationiteration.animation,
                  delete An.animationstart.animation),
                "TransitionEvent" in window ||
                  delete An.transitionend.transition);
              var Sn = Nn("animationend"),
                Rn = Nn("animationiteration"),
                wn = Nn("animationstart"),
                Dn = Nn("transitionend"),
                Fn = new Map(),
                _n =
                  "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
                    " "
                  );
              function kn(e, t) {
                Fn.set(e, t), u(t, [e]);
              }
              for (var Bn = 0; Bn < _n.length; Bn++) {
                var On = _n[Bn];
                kn(
                  On.toLowerCase(),
                  "on" + (On[0].toUpperCase() + On.slice(1))
                );
              }
              kn(Sn, "onAnimationEnd"),
                kn(Rn, "onAnimationIteration"),
                kn(wn, "onAnimationStart"),
                kn("dblclick", "onDoubleClick"),
                kn("focusin", "onFocus"),
                kn("focusout", "onBlur"),
                kn(Dn, "onTransitionEnd"),
                s("onMouseEnter", ["mouseout", "mouseover"]),
                s("onMouseLeave", ["mouseout", "mouseover"]),
                s("onPointerEnter", ["pointerout", "pointerover"]),
                s("onPointerLeave", ["pointerout", "pointerover"]),
                u(
                  "onChange",
                  "change click focusin focusout input keydown keyup selectionchange".split(
                    " "
                  )
                ),
                u(
                  "onSelect",
                  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
                    " "
                  )
                ),
                u("onBeforeInput", [
                  "compositionend",
                  "keypress",
                  "textInput",
                  "paste",
                ]),
                u(
                  "onCompositionEnd",
                  "compositionend focusout keydown keypress keyup mousedown".split(
                    " "
                  )
                ),
                u(
                  "onCompositionStart",
                  "compositionstart focusout keydown keypress keyup mousedown".split(
                    " "
                  )
                ),
                u(
                  "onCompositionUpdate",
                  "compositionupdate focusout keydown keypress keyup mousedown".split(
                    " "
                  )
                );
              var Pn =
                  "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
                    " "
                  ),
                In = new Set(
                  "cancel close invalid load scroll toggle"
                    .split(" ")
                    .concat(Pn)
                );
              function Ln(e, t, a) {
                var n = e.type || "unknown-event";
                (e.currentTarget = a),
                  (function (e, t, a, n, i, l, o, u, s) {
                    if ((je.apply(this, arguments), Ie)) {
                      if (!Ie) throw Error(r(198));
                      var c = Le;
                      (Ie = !1), (Le = null), Te || ((Te = !0), (qe = c));
                    }
                  })(n, t, void 0, e),
                  (e.currentTarget = null);
              }
              function Tn(e, t) {
                t = 0 !== (4 & t);
                for (var a = 0; a < e.length; a++) {
                  var n = e[a],
                    i = n.event;
                  n = n.listeners;
                  e: {
                    var r = void 0;
                    if (t)
                      for (var l = n.length - 1; 0 <= l; l--) {
                        var o = n[l],
                          u = o.instance,
                          s = o.currentTarget;
                        if (
                          ((o = o.listener),
                          u !== r && i.isPropagationStopped())
                        )
                          break e;
                        Ln(i, o, s), (r = u);
                      }
                    else
                      for (l = 0; l < n.length; l++) {
                        if (
                          ((u = (o = n[l]).instance),
                          (s = o.currentTarget),
                          (o = o.listener),
                          u !== r && i.isPropagationStopped())
                        )
                          break e;
                        Ln(i, o, s), (r = u);
                      }
                  }
                }
                if (Te) throw ((e = qe), (Te = !1), (qe = null), e);
              }
              function qn(e, t) {
                var a = t[gi];
                void 0 === a && (a = t[gi] = new Set());
                var n = e + "__bubble";
                a.has(n) || (Qn(t, e, 2, !1), a.add(n));
              }
              function Mn(e, t, a) {
                var n = 0;
                t && (n |= 4), Qn(a, e, n, t);
              }
              var jn = "_reactListening" + Math.random().toString(36).slice(2);
              function Un(e) {
                if (!e[jn]) {
                  (e[jn] = !0),
                    l.forEach(function (t) {
                      "selectionchange" !== t &&
                        (In.has(t) || Mn(t, !1, e), Mn(t, !0, e));
                    });
                  var t = 9 === e.nodeType ? e : e.ownerDocument;
                  null === t ||
                    t[jn] ||
                    ((t[jn] = !0), Mn("selectionchange", !1, t));
                }
              }
              function Qn(e, t, a, n) {
                switch ($t(t)) {
                  case 1:
                    var i = Ht;
                    break;
                  case 4:
                    i = Xt;
                    break;
                  default:
                    i = Gt;
                }
                (a = i.bind(null, t, a, e)),
                  (i = void 0),
                  !Be ||
                    ("touchstart" !== t &&
                      "touchmove" !== t &&
                      "wheel" !== t) ||
                    (i = !0),
                  n
                    ? void 0 !== i
                      ? e.addEventListener(t, a, { capture: !0, passive: i })
                      : e.addEventListener(t, a, !0)
                    : void 0 !== i
                    ? e.addEventListener(t, a, { passive: i })
                    : e.addEventListener(t, a, !1);
              }
              function Yn(e, t, a, n, i) {
                var r = n;
                if (0 === (1 & t) && 0 === (2 & t) && null !== n)
                  e: for (;;) {
                    if (null === n) return;
                    var l = n.tag;
                    if (3 === l || 4 === l) {
                      var o = n.stateNode.containerInfo;
                      if (o === i || (8 === o.nodeType && o.parentNode === i))
                        break;
                      if (4 === l)
                        for (l = n.return; null !== l; ) {
                          var u = l.tag;
                          if (
                            (3 === u || 4 === u) &&
                            ((u = l.stateNode.containerInfo) === i ||
                              (8 === u.nodeType && u.parentNode === i))
                          )
                            return;
                          l = l.return;
                        }
                      for (; null !== o; ) {
                        if (null === (l = vi(o))) return;
                        if (5 === (u = l.tag) || 6 === u) {
                          n = r = l;
                          continue e;
                        }
                        o = o.parentNode;
                      }
                    }
                    n = n.return;
                  }
                _e(function () {
                  var n = r,
                    i = ye(a),
                    l = [];
                  e: {
                    var o = Fn.get(e);
                    if (void 0 !== o) {
                      var u = sa,
                        s = e;
                      switch (e) {
                        case "keypress":
                          if (0 === ta(a)) break e;
                        case "keydown":
                        case "keyup":
                          u = Sa;
                          break;
                        case "focusin":
                          (s = "focus"), (u = ga);
                          break;
                        case "focusout":
                          (s = "blur"), (u = ga);
                          break;
                        case "beforeblur":
                        case "afterblur":
                          u = ga;
                          break;
                        case "click":
                          if (2 === a.button) break e;
                        case "auxclick":
                        case "dblclick":
                        case "mousedown":
                        case "mousemove":
                        case "mouseup":
                        case "mouseout":
                        case "mouseover":
                        case "contextmenu":
                          u = ma;
                          break;
                        case "drag":
                        case "dragend":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "dragstart":
                        case "drop":
                          u = fa;
                          break;
                        case "touchcancel":
                        case "touchend":
                        case "touchmove":
                        case "touchstart":
                          u = wa;
                          break;
                        case Sn:
                        case Rn:
                        case wn:
                          u = ha;
                          break;
                        case Dn:
                          u = Da;
                          break;
                        case "scroll":
                          u = da;
                          break;
                        case "wheel":
                          u = _a;
                          break;
                        case "copy":
                        case "cut":
                        case "paste":
                          u = va;
                          break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerup":
                          u = Ra;
                      }
                      var c = 0 !== (4 & t),
                        d = !c && "scroll" === e,
                        p = c ? (null !== o ? o + "Capture" : null) : o;
                      c = [];
                      for (var m, f = n; null !== f; ) {
                        var g = (m = f).stateNode;
                        if (
                          (5 === m.tag &&
                            null !== g &&
                            ((m = g),
                            null !== p &&
                              null != (g = ke(f, p)) &&
                              c.push(Hn(f, g, m))),
                          d)
                        )
                          break;
                        f = f.return;
                      }
                      0 < c.length &&
                        ((o = new u(o, s, null, a, i)),
                        l.push({ event: o, listeners: c }));
                    }
                  }
                  if (0 === (7 & t)) {
                    if (
                      ((u = "mouseout" === e || "pointerout" === e),
                      (!(o = "mouseover" === e || "pointerover" === e) ||
                        a === ze ||
                        !(s = a.relatedTarget || a.fromElement) ||
                        (!vi(s) && !s[fi])) &&
                        (u || o) &&
                        ((o =
                          i.window === i
                            ? i
                            : (o = i.ownerDocument)
                            ? o.defaultView || o.parentWindow
                            : window),
                        u
                          ? ((u = n),
                            null !==
                              (s = (s = a.relatedTarget || a.toElement)
                                ? vi(s)
                                : null) &&
                              (s !== (d = Ue(s)) ||
                                (5 !== s.tag && 6 !== s.tag)) &&
                              (s = null))
                          : ((u = null), (s = n)),
                        u !== s))
                    ) {
                      if (
                        ((c = ma),
                        (g = "onMouseLeave"),
                        (p = "onMouseEnter"),
                        (f = "mouse"),
                        ("pointerout" !== e && "pointerover" !== e) ||
                          ((c = Ra),
                          (g = "onPointerLeave"),
                          (p = "onPointerEnter"),
                          (f = "pointer")),
                        (d = null == u ? o : zi(u)),
                        (m = null == s ? o : zi(s)),
                        ((o = new c(g, f + "leave", u, a, i)).target = d),
                        (o.relatedTarget = m),
                        (g = null),
                        vi(i) === n &&
                          (((c = new c(p, f + "enter", s, a, i)).target = m),
                          (c.relatedTarget = d),
                          (g = c)),
                        (d = g),
                        u && s)
                      )
                        e: {
                          for (p = s, f = 0, m = c = u; m; m = Gn(m)) f++;
                          for (m = 0, g = p; g; g = Gn(g)) m++;
                          for (; 0 < f - m; ) (c = Gn(c)), f--;
                          for (; 0 < m - f; ) (p = Gn(p)), m--;
                          for (; f--; ) {
                            if (c === p || (null !== p && c === p.alternate))
                              break e;
                            (c = Gn(c)), (p = Gn(p));
                          }
                          c = null;
                        }
                      else c = null;
                      null !== u && Wn(l, o, u, c, !1),
                        null !== s && null !== d && Wn(l, d, s, c, !0);
                    }
                    if (
                      "select" ===
                        (u =
                          (o = n ? zi(n) : window).nodeName &&
                          o.nodeName.toLowerCase()) ||
                      ("input" === u && "file" === o.type)
                    )
                      var h = Va;
                    else if (Qa(o))
                      if ($a) h = ln;
                      else {
                        h = nn;
                        var b = an;
                      }
                    else
                      (u = o.nodeName) &&
                        "input" === u.toLowerCase() &&
                        ("checkbox" === o.type || "radio" === o.type) &&
                        (h = rn);
                    switch (
                      (h && (h = h(e, n))
                        ? Ya(l, h, a, i)
                        : (b && b(e, o, n),
                          "focusout" === e &&
                            (b = o._wrapperState) &&
                            b.controlled &&
                            "number" === o.type &&
                            ee(o, "number", o.value)),
                      (b = n ? zi(n) : window),
                      e)
                    ) {
                      case "focusin":
                        (Qa(b) || "true" === b.contentEditable) &&
                          ((hn = b), (bn = n), (vn = null));
                        break;
                      case "focusout":
                        vn = bn = hn = null;
                        break;
                      case "mousedown":
                        xn = !0;
                        break;
                      case "contextmenu":
                      case "mouseup":
                      case "dragend":
                        (xn = !1), zn(l, a, i);
                        break;
                      case "selectionchange":
                        if (gn) break;
                      case "keydown":
                      case "keyup":
                        zn(l, a, i);
                    }
                    var v;
                    if (Ba)
                      e: {
                        switch (e) {
                          case "compositionstart":
                            var x = "onCompositionStart";
                            break e;
                          case "compositionend":
                            x = "onCompositionEnd";
                            break e;
                          case "compositionupdate":
                            x = "onCompositionUpdate";
                            break e;
                        }
                        x = void 0;
                      }
                    else
                      ja
                        ? qa(e, a) && (x = "onCompositionEnd")
                        : "keydown" === e &&
                          229 === a.keyCode &&
                          (x = "onCompositionStart");
                    x &&
                      (Ia &&
                        "ko" !== a.locale &&
                        (ja || "onCompositionStart" !== x
                          ? "onCompositionEnd" === x && ja && (v = ea())
                          : ((Kt =
                              "value" in (Jt = i) ? Jt.value : Jt.textContent),
                            (ja = !0))),
                      0 < (b = Xn(n, x)).length &&
                        ((x = new xa(x, e, null, a, i)),
                        l.push({ event: x, listeners: b }),
                        v
                          ? (x.data = v)
                          : null !== (v = Ma(a)) && (x.data = v))),
                      (v = Pa
                        ? (function (e, t) {
                            switch (e) {
                              case "compositionend":
                                return Ma(t);
                              case "keypress":
                                return 32 !== t.which ? null : ((Ta = !0), La);
                              case "textInput":
                                return (e = t.data) === La && Ta ? null : e;
                              default:
                                return null;
                            }
                          })(e, a)
                        : (function (e, t) {
                            if (ja)
                              return "compositionend" === e || (!Ba && qa(e, t))
                                ? ((e = ea()),
                                  (Zt = Kt = Jt = null),
                                  (ja = !1),
                                  e)
                                : null;
                            switch (e) {
                              case "paste":
                              default:
                                return null;
                              case "keypress":
                                if (
                                  !(t.ctrlKey || t.altKey || t.metaKey) ||
                                  (t.ctrlKey && t.altKey)
                                ) {
                                  if (t.char && 1 < t.char.length)
                                    return t.char;
                                  if (t.which)
                                    return String.fromCharCode(t.which);
                                }
                                return null;
                              case "compositionend":
                                return Ia && "ko" !== t.locale ? null : t.data;
                            }
                          })(e, a)) &&
                        0 < (n = Xn(n, "onBeforeInput")).length &&
                        ((i = new xa(
                          "onBeforeInput",
                          "beforeinput",
                          null,
                          a,
                          i
                        )),
                        l.push({ event: i, listeners: n }),
                        (i.data = v));
                  }
                  Tn(l, t);
                });
              }
              function Hn(e, t, a) {
                return { instance: e, listener: t, currentTarget: a };
              }
              function Xn(e, t) {
                for (var a = t + "Capture", n = []; null !== e; ) {
                  var i = e,
                    r = i.stateNode;
                  5 === i.tag &&
                    null !== r &&
                    ((i = r),
                    null != (r = ke(e, a)) && n.unshift(Hn(e, r, i)),
                    null != (r = ke(e, t)) && n.push(Hn(e, r, i))),
                    (e = e.return);
                }
                return n;
              }
              function Gn(e) {
                if (null === e) return null;
                do {
                  e = e.return;
                } while (e && 5 !== e.tag);
                return e || null;
              }
              function Wn(e, t, a, n, i) {
                for (var r = t._reactName, l = []; null !== a && a !== n; ) {
                  var o = a,
                    u = o.alternate,
                    s = o.stateNode;
                  if (null !== u && u === n) break;
                  5 === o.tag &&
                    null !== s &&
                    ((o = s),
                    i
                      ? null != (u = ke(a, r)) && l.unshift(Hn(a, u, o))
                      : i || (null != (u = ke(a, r)) && l.push(Hn(a, u, o)))),
                    (a = a.return);
                }
                0 !== l.length && e.push({ event: t, listeners: l });
              }
              var Vn = /\r\n?/g,
                $n = /\u0000|\uFFFD/g;
              function Jn(e) {
                return ("string" === typeof e ? e : "" + e)
                  .replace(Vn, "\n")
                  .replace($n, "");
              }
              function Kn(e, t, a) {
                if (((t = Jn(t)), Jn(e) !== t && a)) throw Error(r(425));
              }
              function Zn() {}
              var ei = null,
                ti = null;
              function ai(e, t) {
                return (
                  "textarea" === e ||
                  "noscript" === e ||
                  "string" === typeof t.children ||
                  "number" === typeof t.children ||
                  ("object" === typeof t.dangerouslySetInnerHTML &&
                    null !== t.dangerouslySetInnerHTML &&
                    null != t.dangerouslySetInnerHTML.__html)
                );
              }
              var ni = "function" === typeof setTimeout ? setTimeout : void 0,
                ii = "function" === typeof clearTimeout ? clearTimeout : void 0,
                ri = "function" === typeof Promise ? Promise : void 0,
                li =
                  "function" === typeof queueMicrotask
                    ? queueMicrotask
                    : "undefined" !== typeof ri
                    ? function (e) {
                        return ri.resolve(null).then(e).catch(oi);
                      }
                    : ni;
              function oi(e) {
                setTimeout(function () {
                  throw e;
                });
              }
              function ui(e, t) {
                var a = t,
                  n = 0;
                do {
                  var i = a.nextSibling;
                  if ((e.removeChild(a), i && 8 === i.nodeType))
                    if ("/$" === (a = i.data)) {
                      if (0 === n) return e.removeChild(i), void Ut(t);
                      n--;
                    } else ("$" !== a && "$?" !== a && "$!" !== a) || n++;
                  a = i;
                } while (a);
                Ut(t);
              }
              function si(e) {
                for (; null != e; e = e.nextSibling) {
                  var t = e.nodeType;
                  if (1 === t || 3 === t) break;
                  if (8 === t) {
                    if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
                    if ("/$" === t) return null;
                  }
                }
                return e;
              }
              function ci(e) {
                e = e.previousSibling;
                for (var t = 0; e; ) {
                  if (8 === e.nodeType) {
                    var a = e.data;
                    if ("$" === a || "$!" === a || "$?" === a) {
                      if (0 === t) return e;
                      t--;
                    } else "/$" === a && t++;
                  }
                  e = e.previousSibling;
                }
                return null;
              }
              var di = Math.random().toString(36).slice(2),
                pi = "__reactFiber$" + di,
                mi = "__reactProps$" + di,
                fi = "__reactContainer$" + di,
                gi = "__reactEvents$" + di,
                hi = "__reactListeners$" + di,
                bi = "__reactHandles$" + di;
              function vi(e) {
                var t = e[pi];
                if (t) return t;
                for (var a = e.parentNode; a; ) {
                  if ((t = a[fi] || a[pi])) {
                    if (
                      ((a = t.alternate),
                      null !== t.child || (null !== a && null !== a.child))
                    )
                      for (e = ci(e); null !== e; ) {
                        if ((a = e[pi])) return a;
                        e = ci(e);
                      }
                    return t;
                  }
                  a = (e = a).parentNode;
                }
                return null;
              }
              function xi(e) {
                return !(e = e[pi] || e[fi]) ||
                  (5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag)
                  ? null
                  : e;
              }
              function zi(e) {
                if (5 === e.tag || 6 === e.tag) return e.stateNode;
                throw Error(r(33));
              }
              function yi(e) {
                return e[mi] || null;
              }
              var Ai = [],
                Ei = -1;
              function Ci(e) {
                return { current: e };
              }
              function Ni(e) {
                0 > Ei || ((e.current = Ai[Ei]), (Ai[Ei] = null), Ei--);
              }
              function Si(e, t) {
                Ei++, (Ai[Ei] = e.current), (e.current = t);
              }
              var Ri = {},
                wi = Ci(Ri),
                Di = Ci(!1),
                Fi = Ri;
              function _i(e, t) {
                var a = e.type.contextTypes;
                if (!a) return Ri;
                var n = e.stateNode;
                if (n && n.__reactInternalMemoizedUnmaskedChildContext === t)
                  return n.__reactInternalMemoizedMaskedChildContext;
                var i,
                  r = {};
                for (i in a) r[i] = t[i];
                return (
                  n &&
                    (((e =
                      e.stateNode).__reactInternalMemoizedUnmaskedChildContext =
                      t),
                    (e.__reactInternalMemoizedMaskedChildContext = r)),
                  r
                );
              }
              function ki(e) {
                return null !== (e = e.childContextTypes) && void 0 !== e;
              }
              function Bi() {
                Ni(Di), Ni(wi);
              }
              function Oi(e, t, a) {
                if (wi.current !== Ri) throw Error(r(168));
                Si(wi, t), Si(Di, a);
              }
              function Pi(e, t, a) {
                var n = e.stateNode;
                if (
                  ((t = t.childContextTypes),
                  "function" !== typeof n.getChildContext)
                )
                  return a;
                for (var i in (n = n.getChildContext()))
                  if (!(i in t)) throw Error(r(108, Q(e) || "Unknown", i));
                return L({}, a, n);
              }
              function Ii(e) {
                return (
                  (e =
                    ((e = e.stateNode) &&
                      e.__reactInternalMemoizedMergedChildContext) ||
                    Ri),
                  (Fi = wi.current),
                  Si(wi, e),
                  Si(Di, Di.current),
                  !0
                );
              }
              function Li(e, t, a) {
                var n = e.stateNode;
                if (!n) throw Error(r(169));
                a
                  ? ((e = Pi(e, t, Fi)),
                    (n.__reactInternalMemoizedMergedChildContext = e),
                    Ni(Di),
                    Ni(wi),
                    Si(wi, e))
                  : Ni(Di),
                  Si(Di, a);
              }
              var Ti = null,
                qi = !1,
                Mi = !1;
              function ji(e) {
                null === Ti ? (Ti = [e]) : Ti.push(e);
              }
              function Ui() {
                if (!Mi && null !== Ti) {
                  Mi = !0;
                  var e = 0,
                    t = xt;
                  try {
                    var a = Ti;
                    for (xt = 1; e < a.length; e++) {
                      var n = a[e];
                      do {
                        n = n(!0);
                      } while (null !== n);
                    }
                    (Ti = null), (qi = !1);
                  } catch (i) {
                    throw (
                      (null !== Ti && (Ti = Ti.slice(e + 1)), Ge(Ze, Ui), i)
                    );
                  } finally {
                    (xt = t), (Mi = !1);
                  }
                }
                return null;
              }
              var Qi = [],
                Yi = 0,
                Hi = null,
                Xi = 0,
                Gi = [],
                Wi = 0,
                Vi = null,
                $i = 1,
                Ji = "";
              function Ki(e, t) {
                (Qi[Yi++] = Xi), (Qi[Yi++] = Hi), (Hi = e), (Xi = t);
              }
              function Zi(e, t, a) {
                (Gi[Wi++] = $i), (Gi[Wi++] = Ji), (Gi[Wi++] = Vi), (Vi = e);
                var n = $i;
                e = Ji;
                var i = 32 - lt(n) - 1;
                (n &= ~(1 << i)), (a += 1);
                var r = 32 - lt(t) + i;
                if (30 < r) {
                  var l = i - (i % 5);
                  (r = (n & ((1 << l) - 1)).toString(32)),
                    (n >>= l),
                    (i -= l),
                    ($i = (1 << (32 - lt(t) + i)) | (a << i) | n),
                    (Ji = r + e);
                } else ($i = (1 << r) | (a << i) | n), (Ji = e);
              }
              function er(e) {
                null !== e.return && (Ki(e, 1), Zi(e, 1, 0));
              }
              function tr(e) {
                for (; e === Hi; )
                  (Hi = Qi[--Yi]),
                    (Qi[Yi] = null),
                    (Xi = Qi[--Yi]),
                    (Qi[Yi] = null);
                for (; e === Vi; )
                  (Vi = Gi[--Wi]),
                    (Gi[Wi] = null),
                    (Ji = Gi[--Wi]),
                    (Gi[Wi] = null),
                    ($i = Gi[--Wi]),
                    (Gi[Wi] = null);
              }
              var ar = null,
                nr = null,
                ir = !1,
                rr = null;
              function lr(e, t) {
                var a = ks(5, null, null, 0);
                (a.elementType = "DELETED"),
                  (a.stateNode = t),
                  (a.return = e),
                  null === (t = e.deletions)
                    ? ((e.deletions = [a]), (e.flags |= 16))
                    : t.push(a);
              }
              function or(e, t) {
                switch (e.tag) {
                  case 5:
                    var a = e.type;
                    return (
                      null !==
                        (t =
                          1 !== t.nodeType ||
                          a.toLowerCase() !== t.nodeName.toLowerCase()
                            ? null
                            : t) &&
                      ((e.stateNode = t), (ar = e), (nr = si(t.firstChild)), !0)
                    );
                  case 6:
                    return (
                      null !==
                        (t =
                          "" === e.pendingProps || 3 !== t.nodeType
                            ? null
                            : t) &&
                      ((e.stateNode = t), (ar = e), (nr = null), !0)
                    );
                  case 13:
                    return (
                      null !== (t = 8 !== t.nodeType ? null : t) &&
                      ((a = null !== Vi ? { id: $i, overflow: Ji } : null),
                      (e.memoizedState = {
                        dehydrated: t,
                        treeContext: a,
                        retryLane: 1073741824,
                      }),
                      ((a = ks(18, null, null, 0)).stateNode = t),
                      (a.return = e),
                      (e.child = a),
                      (ar = e),
                      (nr = null),
                      !0)
                    );
                  default:
                    return !1;
                }
              }
              function ur(e) {
                return 0 !== (1 & e.mode) && 0 === (128 & e.flags);
              }
              function sr(e) {
                if (ir) {
                  var t = nr;
                  if (t) {
                    var a = t;
                    if (!or(e, t)) {
                      if (ur(e)) throw Error(r(418));
                      t = si(a.nextSibling);
                      var n = ar;
                      t && or(e, t)
                        ? lr(n, a)
                        : ((e.flags = (-4097 & e.flags) | 2),
                          (ir = !1),
                          (ar = e));
                    }
                  } else {
                    if (ur(e)) throw Error(r(418));
                    (e.flags = (-4097 & e.flags) | 2), (ir = !1), (ar = e);
                  }
                }
              }
              function cr(e) {
                for (
                  e = e.return;
                  null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;

                )
                  e = e.return;
                ar = e;
              }
              function dr(e) {
                if (e !== ar) return !1;
                if (!ir) return cr(e), (ir = !0), !1;
                var t;
                if (
                  ((t = 3 !== e.tag) &&
                    !(t = 5 !== e.tag) &&
                    (t =
                      "head" !== (t = e.type) &&
                      "body" !== t &&
                      !ai(e.type, e.memoizedProps)),
                  t && (t = nr))
                ) {
                  if (ur(e)) throw (pr(), Error(r(418)));
                  for (; t; ) lr(e, t), (t = si(t.nextSibling));
                }
                if ((cr(e), 13 === e.tag)) {
                  if (
                    !(e = null !== (e = e.memoizedState) ? e.dehydrated : null)
                  )
                    throw Error(r(317));
                  e: {
                    for (e = e.nextSibling, t = 0; e; ) {
                      if (8 === e.nodeType) {
                        var a = e.data;
                        if ("/$" === a) {
                          if (0 === t) {
                            nr = si(e.nextSibling);
                            break e;
                          }
                          t--;
                        } else ("$" !== a && "$!" !== a && "$?" !== a) || t++;
                      }
                      e = e.nextSibling;
                    }
                    nr = null;
                  }
                } else nr = ar ? si(e.stateNode.nextSibling) : null;
                return !0;
              }
              function pr() {
                for (var e = nr; e; ) e = si(e.nextSibling);
              }
              function mr() {
                (nr = ar = null), (ir = !1);
              }
              function fr(e) {
                null === rr ? (rr = [e]) : rr.push(e);
              }
              var gr = z.ReactCurrentBatchConfig;
              function hr(e, t) {
                if (e && e.defaultProps) {
                  for (var a in ((t = L({}, t)), (e = e.defaultProps)))
                    void 0 === t[a] && (t[a] = e[a]);
                  return t;
                }
                return t;
              }
              var br = Ci(null),
                vr = null,
                xr = null,
                zr = null;
              function yr() {
                zr = xr = vr = null;
              }
              function Ar(e) {
                var t = br.current;
                Ni(br), (e._currentValue = t);
              }
              function Er(e, t, a) {
                for (; null !== e; ) {
                  var n = e.alternate;
                  if (
                    ((e.childLanes & t) !== t
                      ? ((e.childLanes |= t), null !== n && (n.childLanes |= t))
                      : null !== n &&
                        (n.childLanes & t) !== t &&
                        (n.childLanes |= t),
                    e === a)
                  )
                    break;
                  e = e.return;
                }
              }
              function Cr(e, t) {
                (vr = e),
                  (zr = xr = null),
                  null !== (e = e.dependencies) &&
                    null !== e.firstContext &&
                    (0 !== (e.lanes & t) && (zo = !0), (e.firstContext = null));
              }
              function Nr(e) {
                var t = e._currentValue;
                if (zr !== e)
                  if (
                    ((e = { context: e, memoizedValue: t, next: null }),
                    null === xr)
                  ) {
                    if (null === vr) throw Error(r(308));
                    (xr = e), (vr.dependencies = { lanes: 0, firstContext: e });
                  } else xr = xr.next = e;
                return t;
              }
              var Sr = null;
              function Rr(e) {
                null === Sr ? (Sr = [e]) : Sr.push(e);
              }
              function wr(e, t, a, n) {
                var i = t.interleaved;
                return (
                  null === i
                    ? ((a.next = a), Rr(t))
                    : ((a.next = i.next), (i.next = a)),
                  (t.interleaved = a),
                  Dr(e, n)
                );
              }
              function Dr(e, t) {
                e.lanes |= t;
                var a = e.alternate;
                for (
                  null !== a && (a.lanes |= t), a = e, e = e.return;
                  null !== e;

                )
                  (e.childLanes |= t),
                    null !== (a = e.alternate) && (a.childLanes |= t),
                    (a = e),
                    (e = e.return);
                return 3 === a.tag ? a.stateNode : null;
              }
              var Fr = !1;
              function _r(e) {
                e.updateQueue = {
                  baseState: e.memoizedState,
                  firstBaseUpdate: null,
                  lastBaseUpdate: null,
                  shared: { pending: null, interleaved: null, lanes: 0 },
                  effects: null,
                };
              }
              function kr(e, t) {
                (e = e.updateQueue),
                  t.updateQueue === e &&
                    (t.updateQueue = {
                      baseState: e.baseState,
                      firstBaseUpdate: e.firstBaseUpdate,
                      lastBaseUpdate: e.lastBaseUpdate,
                      shared: e.shared,
                      effects: e.effects,
                    });
              }
              function Br(e, t) {
                return {
                  eventTime: e,
                  lane: t,
                  tag: 0,
                  payload: null,
                  callback: null,
                  next: null,
                };
              }
              function Or(e, t, a) {
                var n = e.updateQueue;
                if (null === n) return null;
                if (((n = n.shared), 0 !== (2 & Du))) {
                  var i = n.pending;
                  return (
                    null === i
                      ? (t.next = t)
                      : ((t.next = i.next), (i.next = t)),
                    (n.pending = t),
                    Dr(e, a)
                  );
                }
                return (
                  null === (i = n.interleaved)
                    ? ((t.next = t), Rr(n))
                    : ((t.next = i.next), (i.next = t)),
                  (n.interleaved = t),
                  Dr(e, a)
                );
              }
              function Pr(e, t, a) {
                if (
                  null !== (t = t.updateQueue) &&
                  ((t = t.shared), 0 !== (4194240 & a))
                ) {
                  var n = t.lanes;
                  (a |= n &= e.pendingLanes), (t.lanes = a), vt(e, a);
                }
              }
              function Ir(e, t) {
                var a = e.updateQueue,
                  n = e.alternate;
                if (null !== n && a === (n = n.updateQueue)) {
                  var i = null,
                    r = null;
                  if (null !== (a = a.firstBaseUpdate)) {
                    do {
                      var l = {
                        eventTime: a.eventTime,
                        lane: a.lane,
                        tag: a.tag,
                        payload: a.payload,
                        callback: a.callback,
                        next: null,
                      };
                      null === r ? (i = r = l) : (r = r.next = l), (a = a.next);
                    } while (null !== a);
                    null === r ? (i = r = t) : (r = r.next = t);
                  } else i = r = t;
                  return (
                    (a = {
                      baseState: n.baseState,
                      firstBaseUpdate: i,
                      lastBaseUpdate: r,
                      shared: n.shared,
                      effects: n.effects,
                    }),
                    void (e.updateQueue = a)
                  );
                }
                null === (e = a.lastBaseUpdate)
                  ? (a.firstBaseUpdate = t)
                  : (e.next = t),
                  (a.lastBaseUpdate = t);
              }
              function Lr(e, t, a, n) {
                var i = e.updateQueue;
                Fr = !1;
                var r = i.firstBaseUpdate,
                  l = i.lastBaseUpdate,
                  o = i.shared.pending;
                if (null !== o) {
                  i.shared.pending = null;
                  var u = o,
                    s = u.next;
                  (u.next = null), null === l ? (r = s) : (l.next = s), (l = u);
                  var c = e.alternate;
                  null !== c &&
                    (o = (c = c.updateQueue).lastBaseUpdate) !== l &&
                    (null === o ? (c.firstBaseUpdate = s) : (o.next = s),
                    (c.lastBaseUpdate = u));
                }
                if (null !== r) {
                  var d = i.baseState;
                  for (l = 0, c = s = u = null, o = r; ; ) {
                    var p = o.lane,
                      m = o.eventTime;
                    if ((n & p) === p) {
                      null !== c &&
                        (c = c.next =
                          {
                            eventTime: m,
                            lane: 0,
                            tag: o.tag,
                            payload: o.payload,
                            callback: o.callback,
                            next: null,
                          });
                      e: {
                        var f = e,
                          g = o;
                        switch (((p = t), (m = a), g.tag)) {
                          case 1:
                            if ("function" === typeof (f = g.payload)) {
                              d = f.call(m, d, p);
                              break e;
                            }
                            d = f;
                            break e;
                          case 3:
                            f.flags = (-65537 & f.flags) | 128;
                          case 0:
                            if (
                              null ===
                                (p =
                                  "function" === typeof (f = g.payload)
                                    ? f.call(m, d, p)
                                    : f) ||
                              void 0 === p
                            )
                              break e;
                            d = L({}, d, p);
                            break e;
                          case 2:
                            Fr = !0;
                        }
                      }
                      null !== o.callback &&
                        0 !== o.lane &&
                        ((e.flags |= 64),
                        null === (p = i.effects)
                          ? (i.effects = [o])
                          : p.push(o));
                    } else
                      (m = {
                        eventTime: m,
                        lane: p,
                        tag: o.tag,
                        payload: o.payload,
                        callback: o.callback,
                        next: null,
                      }),
                        null === c ? ((s = c = m), (u = d)) : (c = c.next = m),
                        (l |= p);
                    if (null === (o = o.next)) {
                      if (null === (o = i.shared.pending)) break;
                      (o = (p = o).next),
                        (p.next = null),
                        (i.lastBaseUpdate = p),
                        (i.shared.pending = null);
                    }
                  }
                  if (
                    (null === c && (u = d),
                    (i.baseState = u),
                    (i.firstBaseUpdate = s),
                    (i.lastBaseUpdate = c),
                    null !== (t = i.shared.interleaved))
                  ) {
                    i = t;
                    do {
                      (l |= i.lane), (i = i.next);
                    } while (i !== t);
                  } else null === r && (i.shared.lanes = 0);
                  (Lu |= l), (e.lanes = l), (e.memoizedState = d);
                }
              }
              function Tr(e, t, a) {
                if (((e = t.effects), (t.effects = null), null !== e))
                  for (t = 0; t < e.length; t++) {
                    var n = e[t],
                      i = n.callback;
                    if (null !== i) {
                      if (
                        ((n.callback = null), (n = a), "function" !== typeof i)
                      )
                        throw Error(r(191, i));
                      i.call(n);
                    }
                  }
              }
              var qr = new n.Component().refs;
              function Mr(e, t, a, n) {
                (a =
                  null === (a = a(n, (t = e.memoizedState))) || void 0 === a
                    ? t
                    : L({}, t, a)),
                  (e.memoizedState = a),
                  0 === e.lanes && (e.updateQueue.baseState = a);
              }
              var jr = {
                isMounted: function (e) {
                  return !!(e = e._reactInternals) && Ue(e) === e;
                },
                enqueueSetState: function (e, t, a) {
                  e = e._reactInternals;
                  var n = ts(),
                    i = as(e),
                    r = Br(n, i);
                  (r.payload = t),
                    void 0 !== a && null !== a && (r.callback = a),
                    null !== (t = Or(e, r, i)) && (ns(t, e, i, n), Pr(t, e, i));
                },
                enqueueReplaceState: function (e, t, a) {
                  e = e._reactInternals;
                  var n = ts(),
                    i = as(e),
                    r = Br(n, i);
                  (r.tag = 1),
                    (r.payload = t),
                    void 0 !== a && null !== a && (r.callback = a),
                    null !== (t = Or(e, r, i)) && (ns(t, e, i, n), Pr(t, e, i));
                },
                enqueueForceUpdate: function (e, t) {
                  e = e._reactInternals;
                  var a = ts(),
                    n = as(e),
                    i = Br(a, n);
                  (i.tag = 2),
                    void 0 !== t && null !== t && (i.callback = t),
                    null !== (t = Or(e, i, n)) && (ns(t, e, n, a), Pr(t, e, n));
                },
              };
              function Ur(e, t, a, n, i, r, l) {
                return "function" ===
                  typeof (e = e.stateNode).shouldComponentUpdate
                  ? e.shouldComponentUpdate(n, r, l)
                  : !t.prototype ||
                      !t.prototype.isPureReactComponent ||
                      !un(a, n) ||
                      !un(i, r);
              }
              function Qr(e, t, a) {
                var n = !1,
                  i = Ri,
                  r = t.contextType;
                return (
                  "object" === typeof r && null !== r
                    ? (r = Nr(r))
                    : ((i = ki(t) ? Fi : wi.current),
                      (r = (n = null !== (n = t.contextTypes) && void 0 !== n)
                        ? _i(e, i)
                        : Ri)),
                  (t = new t(a, r)),
                  (e.memoizedState =
                    null !== t.state && void 0 !== t.state ? t.state : null),
                  (t.updater = jr),
                  (e.stateNode = t),
                  (t._reactInternals = e),
                  n &&
                    (((e =
                      e.stateNode).__reactInternalMemoizedUnmaskedChildContext =
                      i),
                    (e.__reactInternalMemoizedMaskedChildContext = r)),
                  t
                );
              }
              function Yr(e, t, a, n) {
                (e = t.state),
                  "function" === typeof t.componentWillReceiveProps &&
                    t.componentWillReceiveProps(a, n),
                  "function" === typeof t.UNSAFE_componentWillReceiveProps &&
                    t.UNSAFE_componentWillReceiveProps(a, n),
                  t.state !== e && jr.enqueueReplaceState(t, t.state, null);
              }
              function Hr(e, t, a, n) {
                var i = e.stateNode;
                (i.props = a),
                  (i.state = e.memoizedState),
                  (i.refs = qr),
                  _r(e);
                var r = t.contextType;
                "object" === typeof r && null !== r
                  ? (i.context = Nr(r))
                  : ((r = ki(t) ? Fi : wi.current), (i.context = _i(e, r))),
                  (i.state = e.memoizedState),
                  "function" === typeof (r = t.getDerivedStateFromProps) &&
                    (Mr(e, t, r, a), (i.state = e.memoizedState)),
                  "function" === typeof t.getDerivedStateFromProps ||
                    "function" === typeof i.getSnapshotBeforeUpdate ||
                    ("function" !== typeof i.UNSAFE_componentWillMount &&
                      "function" !== typeof i.componentWillMount) ||
                    ((t = i.state),
                    "function" === typeof i.componentWillMount &&
                      i.componentWillMount(),
                    "function" === typeof i.UNSAFE_componentWillMount &&
                      i.UNSAFE_componentWillMount(),
                    t !== i.state && jr.enqueueReplaceState(i, i.state, null),
                    Lr(e, a, i, n),
                    (i.state = e.memoizedState)),
                  "function" === typeof i.componentDidMount &&
                    (e.flags |= 4194308);
              }
              function Xr(e, t, a) {
                if (
                  null !== (e = a.ref) &&
                  "function" !== typeof e &&
                  "object" !== typeof e
                ) {
                  if (a._owner) {
                    if ((a = a._owner)) {
                      if (1 !== a.tag) throw Error(r(309));
                      var n = a.stateNode;
                    }
                    if (!n) throw Error(r(147, e));
                    var i = n,
                      l = "" + e;
                    return null !== t &&
                      null !== t.ref &&
                      "function" === typeof t.ref &&
                      t.ref._stringRef === l
                      ? t.ref
                      : ((t = function (e) {
                          var t = i.refs;
                          t === qr && (t = i.refs = {}),
                            null === e ? delete t[l] : (t[l] = e);
                        }),
                        (t._stringRef = l),
                        t);
                  }
                  if ("string" !== typeof e) throw Error(r(284));
                  if (!a._owner) throw Error(r(290, e));
                }
                return e;
              }
              function Gr(e, t) {
                throw (
                  ((e = Object.prototype.toString.call(t)),
                  Error(
                    r(
                      31,
                      "[object Object]" === e
                        ? "object with keys {" + Object.keys(t).join(", ") + "}"
                        : e
                    )
                  ))
                );
              }
              function Wr(e) {
                return (0, e._init)(e._payload);
              }
              function Vr(e) {
                function t(t, a) {
                  if (e) {
                    var n = t.deletions;
                    null === n
                      ? ((t.deletions = [a]), (t.flags |= 16))
                      : n.push(a);
                  }
                }
                function a(a, n) {
                  if (!e) return null;
                  for (; null !== n; ) t(a, n), (n = n.sibling);
                  return null;
                }
                function n(e, t) {
                  for (e = new Map(); null !== t; )
                    null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                      (t = t.sibling);
                  return e;
                }
                function i(e, t) {
                  return ((e = Os(e, t)).index = 0), (e.sibling = null), e;
                }
                function l(t, a, n) {
                  return (
                    (t.index = n),
                    e
                      ? null !== (n = t.alternate)
                        ? (n = n.index) < a
                          ? ((t.flags |= 2), a)
                          : n
                        : ((t.flags |= 2), a)
                      : ((t.flags |= 1048576), a)
                  );
                }
                function o(t) {
                  return e && null === t.alternate && (t.flags |= 2), t;
                }
                function u(e, t, a, n) {
                  return null === t || 6 !== t.tag
                    ? (((t = Ts(a, e.mode, n)).return = e), t)
                    : (((t = i(t, a)).return = e), t);
                }
                function s(e, t, a, n) {
                  var r = a.type;
                  return r === E
                    ? d(e, t, a.props.children, n, a.key)
                    : null !== t &&
                      (t.elementType === r ||
                        ("object" === typeof r &&
                          null !== r &&
                          r.$$typeof === k &&
                          Wr(r) === t.type))
                    ? (((n = i(t, a.props)).ref = Xr(e, t, a)),
                      (n.return = e),
                      n)
                    : (((n = Ps(a.type, a.key, a.props, null, e.mode, n)).ref =
                        Xr(e, t, a)),
                      (n.return = e),
                      n);
                }
                function c(e, t, a, n) {
                  return null === t ||
                    4 !== t.tag ||
                    t.stateNode.containerInfo !== a.containerInfo ||
                    t.stateNode.implementation !== a.implementation
                    ? (((t = qs(a, e.mode, n)).return = e), t)
                    : (((t = i(t, a.children || [])).return = e), t);
                }
                function d(e, t, a, n, r) {
                  return null === t || 7 !== t.tag
                    ? (((t = Is(a, e.mode, n, r)).return = e), t)
                    : (((t = i(t, a)).return = e), t);
                }
                function p(e, t, a) {
                  if (
                    ("string" === typeof t && "" !== t) ||
                    "number" === typeof t
                  )
                    return ((t = Ts("" + t, e.mode, a)).return = e), t;
                  if ("object" === typeof t && null !== t) {
                    switch (t.$$typeof) {
                      case y:
                        return (
                          ((a = Ps(
                            t.type,
                            t.key,
                            t.props,
                            null,
                            e.mode,
                            a
                          )).ref = Xr(e, null, t)),
                          (a.return = e),
                          a
                        );
                      case A:
                        return ((t = qs(t, e.mode, a)).return = e), t;
                      case k:
                        return p(e, (0, t._init)(t._payload), a);
                    }
                    if (te(t) || P(t))
                      return ((t = Is(t, e.mode, a, null)).return = e), t;
                    Gr(e, t);
                  }
                  return null;
                }
                function m(e, t, a, n) {
                  var i = null !== t ? t.key : null;
                  if (
                    ("string" === typeof a && "" !== a) ||
                    "number" === typeof a
                  )
                    return null !== i ? null : u(e, t, "" + a, n);
                  if ("object" === typeof a && null !== a) {
                    switch (a.$$typeof) {
                      case y:
                        return a.key === i ? s(e, t, a, n) : null;
                      case A:
                        return a.key === i ? c(e, t, a, n) : null;
                      case k:
                        return m(e, t, (i = a._init)(a._payload), n);
                    }
                    if (te(a) || P(a))
                      return null !== i ? null : d(e, t, a, n, null);
                    Gr(e, a);
                  }
                  return null;
                }
                function f(e, t, a, n, i) {
                  if (
                    ("string" === typeof n && "" !== n) ||
                    "number" === typeof n
                  )
                    return u(t, (e = e.get(a) || null), "" + n, i);
                  if ("object" === typeof n && null !== n) {
                    switch (n.$$typeof) {
                      case y:
                        return s(
                          t,
                          (e = e.get(null === n.key ? a : n.key) || null),
                          n,
                          i
                        );
                      case A:
                        return c(
                          t,
                          (e = e.get(null === n.key ? a : n.key) || null),
                          n,
                          i
                        );
                      case k:
                        return f(e, t, a, (0, n._init)(n._payload), i);
                    }
                    if (te(n) || P(n))
                      return d(t, (e = e.get(a) || null), n, i, null);
                    Gr(t, n);
                  }
                  return null;
                }
                function g(i, r, o, u) {
                  for (
                    var s = null, c = null, d = r, g = (r = 0), h = null;
                    null !== d && g < o.length;
                    g++
                  ) {
                    d.index > g ? ((h = d), (d = null)) : (h = d.sibling);
                    var b = m(i, d, o[g], u);
                    if (null === b) {
                      null === d && (d = h);
                      break;
                    }
                    e && d && null === b.alternate && t(i, d),
                      (r = l(b, r, g)),
                      null === c ? (s = b) : (c.sibling = b),
                      (c = b),
                      (d = h);
                  }
                  if (g === o.length) return a(i, d), ir && Ki(i, g), s;
                  if (null === d) {
                    for (; g < o.length; g++)
                      null !== (d = p(i, o[g], u)) &&
                        ((r = l(d, r, g)),
                        null === c ? (s = d) : (c.sibling = d),
                        (c = d));
                    return ir && Ki(i, g), s;
                  }
                  for (d = n(i, d); g < o.length; g++)
                    null !== (h = f(d, i, g, o[g], u)) &&
                      (e &&
                        null !== h.alternate &&
                        d.delete(null === h.key ? g : h.key),
                      (r = l(h, r, g)),
                      null === c ? (s = h) : (c.sibling = h),
                      (c = h));
                  return (
                    e &&
                      d.forEach(function (e) {
                        return t(i, e);
                      }),
                    ir && Ki(i, g),
                    s
                  );
                }
                function h(i, o, u, s) {
                  var c = P(u);
                  if ("function" !== typeof c) throw Error(r(150));
                  if (null == (u = c.call(u))) throw Error(r(151));
                  for (
                    var d = (c = null),
                      g = o,
                      h = (o = 0),
                      b = null,
                      v = u.next();
                    null !== g && !v.done;
                    h++, v = u.next()
                  ) {
                    g.index > h ? ((b = g), (g = null)) : (b = g.sibling);
                    var x = m(i, g, v.value, s);
                    if (null === x) {
                      null === g && (g = b);
                      break;
                    }
                    e && g && null === x.alternate && t(i, g),
                      (o = l(x, o, h)),
                      null === d ? (c = x) : (d.sibling = x),
                      (d = x),
                      (g = b);
                  }
                  if (v.done) return a(i, g), ir && Ki(i, h), c;
                  if (null === g) {
                    for (; !v.done; h++, v = u.next())
                      null !== (v = p(i, v.value, s)) &&
                        ((o = l(v, o, h)),
                        null === d ? (c = v) : (d.sibling = v),
                        (d = v));
                    return ir && Ki(i, h), c;
                  }
                  for (g = n(i, g); !v.done; h++, v = u.next())
                    null !== (v = f(g, i, h, v.value, s)) &&
                      (e &&
                        null !== v.alternate &&
                        g.delete(null === v.key ? h : v.key),
                      (o = l(v, o, h)),
                      null === d ? (c = v) : (d.sibling = v),
                      (d = v));
                  return (
                    e &&
                      g.forEach(function (e) {
                        return t(i, e);
                      }),
                    ir && Ki(i, h),
                    c
                  );
                }
                return function e(n, r, l, u) {
                  if (
                    ("object" === typeof l &&
                      null !== l &&
                      l.type === E &&
                      null === l.key &&
                      (l = l.props.children),
                    "object" === typeof l && null !== l)
                  ) {
                    switch (l.$$typeof) {
                      case y:
                        e: {
                          for (var s = l.key, c = r; null !== c; ) {
                            if (c.key === s) {
                              if ((s = l.type) === E) {
                                if (7 === c.tag) {
                                  a(n, c.sibling),
                                    ((r = i(c, l.props.children)).return = n),
                                    (n = r);
                                  break e;
                                }
                              } else if (
                                c.elementType === s ||
                                ("object" === typeof s &&
                                  null !== s &&
                                  s.$$typeof === k &&
                                  Wr(s) === c.type)
                              ) {
                                a(n, c.sibling),
                                  ((r = i(c, l.props)).ref = Xr(n, c, l)),
                                  (r.return = n),
                                  (n = r);
                                break e;
                              }
                              a(n, c);
                              break;
                            }
                            t(n, c), (c = c.sibling);
                          }
                          l.type === E
                            ? (((r = Is(
                                l.props.children,
                                n.mode,
                                u,
                                l.key
                              )).return = n),
                              (n = r))
                            : (((u = Ps(
                                l.type,
                                l.key,
                                l.props,
                                null,
                                n.mode,
                                u
                              )).ref = Xr(n, r, l)),
                              (u.return = n),
                              (n = u));
                        }
                        return o(n);
                      case A:
                        e: {
                          for (c = l.key; null !== r; ) {
                            if (r.key === c) {
                              if (
                                4 === r.tag &&
                                r.stateNode.containerInfo === l.containerInfo &&
                                r.stateNode.implementation === l.implementation
                              ) {
                                a(n, r.sibling),
                                  ((r = i(r, l.children || [])).return = n),
                                  (n = r);
                                break e;
                              }
                              a(n, r);
                              break;
                            }
                            t(n, r), (r = r.sibling);
                          }
                          ((r = qs(l, n.mode, u)).return = n), (n = r);
                        }
                        return o(n);
                      case k:
                        return e(n, r, (c = l._init)(l._payload), u);
                    }
                    if (te(l)) return g(n, r, l, u);
                    if (P(l)) return h(n, r, l, u);
                    Gr(n, l);
                  }
                  return ("string" === typeof l && "" !== l) ||
                    "number" === typeof l
                    ? ((l = "" + l),
                      null !== r && 6 === r.tag
                        ? (a(n, r.sibling), ((r = i(r, l)).return = n), (n = r))
                        : (a(n, r),
                          ((r = Ts(l, n.mode, u)).return = n),
                          (n = r)),
                      o(n))
                    : a(n, r);
                };
              }
              var $r = Vr(!0),
                Jr = Vr(!1),
                Kr = {},
                Zr = Ci(Kr),
                el = Ci(Kr),
                tl = Ci(Kr);
              function al(e) {
                if (e === Kr) throw Error(r(174));
                return e;
              }
              function nl(e, t) {
                switch ((Si(tl, t), Si(el, e), Si(Zr, Kr), (e = t.nodeType))) {
                  case 9:
                  case 11:
                    t = (t = t.documentElement) ? t.namespaceURI : ue(null, "");
                    break;
                  default:
                    t = ue(
                      (t =
                        (e = 8 === e ? t.parentNode : t).namespaceURI || null),
                      (e = e.tagName)
                    );
                }
                Ni(Zr), Si(Zr, t);
              }
              function il() {
                Ni(Zr), Ni(el), Ni(tl);
              }
              function rl(e) {
                al(tl.current);
                var t = al(Zr.current),
                  a = ue(t, e.type);
                t !== a && (Si(el, e), Si(Zr, a));
              }
              function ll(e) {
                el.current === e && (Ni(Zr), Ni(el));
              }
              var ol = Ci(0);
              function ul(e) {
                for (var t = e; null !== t; ) {
                  if (13 === t.tag) {
                    var a = t.memoizedState;
                    if (
                      null !== a &&
                      (null === (a = a.dehydrated) ||
                        "$?" === a.data ||
                        "$!" === a.data)
                    )
                      return t;
                  } else if (
                    19 === t.tag &&
                    void 0 !== t.memoizedProps.revealOrder
                  ) {
                    if (0 !== (128 & t.flags)) return t;
                  } else if (null !== t.child) {
                    (t.child.return = t), (t = t.child);
                    continue;
                  }
                  if (t === e) break;
                  for (; null === t.sibling; ) {
                    if (null === t.return || t.return === e) return null;
                    t = t.return;
                  }
                  (t.sibling.return = t.return), (t = t.sibling);
                }
                return null;
              }
              var sl = [];
              function cl() {
                for (var e = 0; e < sl.length; e++)
                  sl[e]._workInProgressVersionPrimary = null;
                sl.length = 0;
              }
              var dl = z.ReactCurrentDispatcher,
                pl = z.ReactCurrentBatchConfig,
                ml = 0,
                fl = null,
                gl = null,
                hl = null,
                bl = !1,
                vl = !1,
                xl = 0,
                zl = 0;
              function yl() {
                throw Error(r(321));
              }
              function Al(e, t) {
                if (null === t) return !1;
                for (var a = 0; a < t.length && a < e.length; a++)
                  if (!on(e[a], t[a])) return !1;
                return !0;
              }
              function El(e, t, a, n, i, l) {
                if (
                  ((ml = l),
                  (fl = t),
                  (t.memoizedState = null),
                  (t.updateQueue = null),
                  (t.lanes = 0),
                  (dl.current =
                    null === e || null === e.memoizedState ? lo : oo),
                  (e = a(n, i)),
                  vl)
                ) {
                  l = 0;
                  do {
                    if (((vl = !1), (xl = 0), 25 <= l)) throw Error(r(301));
                    (l += 1),
                      (hl = gl = null),
                      (t.updateQueue = null),
                      (dl.current = uo),
                      (e = a(n, i));
                  } while (vl);
                }
                if (
                  ((dl.current = ro),
                  (t = null !== gl && null !== gl.next),
                  (ml = 0),
                  (hl = gl = fl = null),
                  (bl = !1),
                  t)
                )
                  throw Error(r(300));
                return e;
              }
              function Cl() {
                var e = 0 !== xl;
                return (xl = 0), e;
              }
              function Nl() {
                var e = {
                  memoizedState: null,
                  baseState: null,
                  baseQueue: null,
                  queue: null,
                  next: null,
                };
                return (
                  null === hl
                    ? (fl.memoizedState = hl = e)
                    : (hl = hl.next = e),
                  hl
                );
              }
              function Sl() {
                if (null === gl) {
                  var e = fl.alternate;
                  e = null !== e ? e.memoizedState : null;
                } else e = gl.next;
                var t = null === hl ? fl.memoizedState : hl.next;
                if (null !== t) (hl = t), (gl = e);
                else {
                  if (null === e) throw Error(r(310));
                  (e = {
                    memoizedState: (gl = e).memoizedState,
                    baseState: gl.baseState,
                    baseQueue: gl.baseQueue,
                    queue: gl.queue,
                    next: null,
                  }),
                    null === hl
                      ? (fl.memoizedState = hl = e)
                      : (hl = hl.next = e);
                }
                return hl;
              }
              function Rl(e, t) {
                return "function" === typeof t ? t(e) : t;
              }
              function wl(e) {
                var t = Sl(),
                  a = t.queue;
                if (null === a) throw Error(r(311));
                a.lastRenderedReducer = e;
                var n = gl,
                  i = n.baseQueue,
                  l = a.pending;
                if (null !== l) {
                  if (null !== i) {
                    var o = i.next;
                    (i.next = l.next), (l.next = o);
                  }
                  (n.baseQueue = i = l), (a.pending = null);
                }
                if (null !== i) {
                  (l = i.next), (n = n.baseState);
                  var u = (o = null),
                    s = null,
                    c = l;
                  do {
                    var d = c.lane;
                    if ((ml & d) === d)
                      null !== s &&
                        (s = s.next =
                          {
                            lane: 0,
                            action: c.action,
                            hasEagerState: c.hasEagerState,
                            eagerState: c.eagerState,
                            next: null,
                          }),
                        (n = c.hasEagerState ? c.eagerState : e(n, c.action));
                    else {
                      var p = {
                        lane: d,
                        action: c.action,
                        hasEagerState: c.hasEagerState,
                        eagerState: c.eagerState,
                        next: null,
                      };
                      null === s ? ((u = s = p), (o = n)) : (s = s.next = p),
                        (fl.lanes |= d),
                        (Lu |= d);
                    }
                    c = c.next;
                  } while (null !== c && c !== l);
                  null === s ? (o = n) : (s.next = u),
                    on(n, t.memoizedState) || (zo = !0),
                    (t.memoizedState = n),
                    (t.baseState = o),
                    (t.baseQueue = s),
                    (a.lastRenderedState = n);
                }
                if (null !== (e = a.interleaved)) {
                  i = e;
                  do {
                    (l = i.lane), (fl.lanes |= l), (Lu |= l), (i = i.next);
                  } while (i !== e);
                } else null === i && (a.lanes = 0);
                return [t.memoizedState, a.dispatch];
              }
              function Dl(e) {
                var t = Sl(),
                  a = t.queue;
                if (null === a) throw Error(r(311));
                a.lastRenderedReducer = e;
                var n = a.dispatch,
                  i = a.pending,
                  l = t.memoizedState;
                if (null !== i) {
                  a.pending = null;
                  var o = (i = i.next);
                  do {
                    (l = e(l, o.action)), (o = o.next);
                  } while (o !== i);
                  on(l, t.memoizedState) || (zo = !0),
                    (t.memoizedState = l),
                    null === t.baseQueue && (t.baseState = l),
                    (a.lastRenderedState = l);
                }
                return [l, n];
              }
              function Fl() {}
              function _l(e, t) {
                var a = fl,
                  n = Sl(),
                  i = t(),
                  l = !on(n.memoizedState, i);
                if (
                  (l && ((n.memoizedState = i), (zo = !0)),
                  (n = n.queue),
                  Ql(Ol.bind(null, a, n, e), [e]),
                  n.getSnapshot !== t ||
                    l ||
                    (null !== hl && 1 & hl.memoizedState.tag))
                ) {
                  if (
                    ((a.flags |= 2048),
                    Tl(9, Bl.bind(null, a, n, i, t), void 0, null),
                    null === Fu)
                  )
                    throw Error(r(349));
                  0 !== (30 & ml) || kl(a, t, i);
                }
                return i;
              }
              function kl(e, t, a) {
                (e.flags |= 16384),
                  (e = { getSnapshot: t, value: a }),
                  null === (t = fl.updateQueue)
                    ? ((t = { lastEffect: null, stores: null }),
                      (fl.updateQueue = t),
                      (t.stores = [e]))
                    : null === (a = t.stores)
                    ? (t.stores = [e])
                    : a.push(e);
              }
              function Bl(e, t, a, n) {
                (t.value = a), (t.getSnapshot = n), Pl(t) && Il(e);
              }
              function Ol(e, t, a) {
                return a(function () {
                  Pl(t) && Il(e);
                });
              }
              function Pl(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                  var a = t();
                  return !on(e, a);
                } catch (n) {
                  return !0;
                }
              }
              function Il(e) {
                var t = Dr(e, 1);
                null !== t && ns(t, e, 1, -1);
              }
              function Ll(e) {
                var t = Nl();
                return (
                  "function" === typeof e && (e = e()),
                  (t.memoizedState = t.baseState = e),
                  (e = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Rl,
                    lastRenderedState: e,
                  }),
                  (t.queue = e),
                  (e = e.dispatch = to.bind(null, fl, e)),
                  [t.memoizedState, e]
                );
              }
              function Tl(e, t, a, n) {
                return (
                  (e = { tag: e, create: t, destroy: a, deps: n, next: null }),
                  null === (t = fl.updateQueue)
                    ? ((t = { lastEffect: null, stores: null }),
                      (fl.updateQueue = t),
                      (t.lastEffect = e.next = e))
                    : null === (a = t.lastEffect)
                    ? (t.lastEffect = e.next = e)
                    : ((n = a.next),
                      (a.next = e),
                      (e.next = n),
                      (t.lastEffect = e)),
                  e
                );
              }
              function ql() {
                return Sl().memoizedState;
              }
              function Ml(e, t, a, n) {
                var i = Nl();
                (fl.flags |= e),
                  (i.memoizedState = Tl(
                    1 | t,
                    a,
                    void 0,
                    void 0 === n ? null : n
                  ));
              }
              function jl(e, t, a, n) {
                var i = Sl();
                n = void 0 === n ? null : n;
                var r = void 0;
                if (null !== gl) {
                  var l = gl.memoizedState;
                  if (((r = l.destroy), null !== n && Al(n, l.deps)))
                    return void (i.memoizedState = Tl(t, a, r, n));
                }
                (fl.flags |= e), (i.memoizedState = Tl(1 | t, a, r, n));
              }
              function Ul(e, t) {
                return Ml(8390656, 8, e, t);
              }
              function Ql(e, t) {
                return jl(2048, 8, e, t);
              }
              function Yl(e, t) {
                return jl(4, 2, e, t);
              }
              function Hl(e, t) {
                return jl(4, 4, e, t);
              }
              function Xl(e, t) {
                return "function" === typeof t
                  ? ((e = e()),
                    t(e),
                    function () {
                      t(null);
                    })
                  : null !== t && void 0 !== t
                  ? ((e = e()),
                    (t.current = e),
                    function () {
                      t.current = null;
                    })
                  : void 0;
              }
              function Gl(e, t, a) {
                return (
                  (a = null !== a && void 0 !== a ? a.concat([e]) : null),
                  jl(4, 4, Xl.bind(null, t, e), a)
                );
              }
              function Wl() {}
              function Vl(e, t) {
                var a = Sl();
                t = void 0 === t ? null : t;
                var n = a.memoizedState;
                return null !== n && null !== t && Al(t, n[1])
                  ? n[0]
                  : ((a.memoizedState = [e, t]), e);
              }
              function $l(e, t) {
                var a = Sl();
                t = void 0 === t ? null : t;
                var n = a.memoizedState;
                return null !== n && null !== t && Al(t, n[1])
                  ? n[0]
                  : ((e = e()), (a.memoizedState = [e, t]), e);
              }
              function Jl(e, t, a) {
                return 0 === (21 & ml)
                  ? (e.baseState && ((e.baseState = !1), (zo = !0)),
                    (e.memoizedState = a))
                  : (on(a, t) ||
                      ((a = gt()),
                      (fl.lanes |= a),
                      (Lu |= a),
                      (e.baseState = !0)),
                    t);
              }
              function Kl(e, t) {
                var a = xt;
                (xt = 0 !== a && 4 > a ? a : 4), e(!0);
                var n = pl.transition;
                pl.transition = {};
                try {
                  e(!1), t();
                } finally {
                  (xt = a), (pl.transition = n);
                }
              }
              function Zl() {
                return Sl().memoizedState;
              }
              function eo(e, t, a) {
                var n = as(e);
                if (
                  ((a = {
                    lane: n,
                    action: a,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null,
                  }),
                  ao(e))
                )
                  no(t, a);
                else if (null !== (a = wr(e, t, a, n))) {
                  ns(a, e, n, ts()), io(a, t, n);
                }
              }
              function to(e, t, a) {
                var n = as(e),
                  i = {
                    lane: n,
                    action: a,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null,
                  };
                if (ao(e)) no(t, i);
                else {
                  var r = e.alternate;
                  if (
                    0 === e.lanes &&
                    (null === r || 0 === r.lanes) &&
                    null !== (r = t.lastRenderedReducer)
                  )
                    try {
                      var l = t.lastRenderedState,
                        o = r(l, a);
                      if (
                        ((i.hasEagerState = !0), (i.eagerState = o), on(o, l))
                      ) {
                        var u = t.interleaved;
                        return (
                          null === u
                            ? ((i.next = i), Rr(t))
                            : ((i.next = u.next), (u.next = i)),
                          void (t.interleaved = i)
                        );
                      }
                    } catch (s) {}
                  null !== (a = wr(e, t, i, n)) &&
                    (ns(a, e, n, (i = ts())), io(a, t, n));
                }
              }
              function ao(e) {
                var t = e.alternate;
                return e === fl || (null !== t && t === fl);
              }
              function no(e, t) {
                vl = bl = !0;
                var a = e.pending;
                null === a ? (t.next = t) : ((t.next = a.next), (a.next = t)),
                  (e.pending = t);
              }
              function io(e, t, a) {
                if (0 !== (4194240 & a)) {
                  var n = t.lanes;
                  (a |= n &= e.pendingLanes), (t.lanes = a), vt(e, a);
                }
              }
              var ro = {
                  readContext: Nr,
                  useCallback: yl,
                  useContext: yl,
                  useEffect: yl,
                  useImperativeHandle: yl,
                  useInsertionEffect: yl,
                  useLayoutEffect: yl,
                  useMemo: yl,
                  useReducer: yl,
                  useRef: yl,
                  useState: yl,
                  useDebugValue: yl,
                  useDeferredValue: yl,
                  useTransition: yl,
                  useMutableSource: yl,
                  useSyncExternalStore: yl,
                  useId: yl,
                  unstable_isNewReconciler: !1,
                },
                lo = {
                  readContext: Nr,
                  useCallback: function (e, t) {
                    return (
                      (Nl().memoizedState = [e, void 0 === t ? null : t]), e
                    );
                  },
                  useContext: Nr,
                  useEffect: Ul,
                  useImperativeHandle: function (e, t, a) {
                    return (
                      (a = null !== a && void 0 !== a ? a.concat([e]) : null),
                      Ml(4194308, 4, Xl.bind(null, t, e), a)
                    );
                  },
                  useLayoutEffect: function (e, t) {
                    return Ml(4194308, 4, e, t);
                  },
                  useInsertionEffect: function (e, t) {
                    return Ml(4, 2, e, t);
                  },
                  useMemo: function (e, t) {
                    var a = Nl();
                    return (
                      (t = void 0 === t ? null : t),
                      (e = e()),
                      (a.memoizedState = [e, t]),
                      e
                    );
                  },
                  useReducer: function (e, t, a) {
                    var n = Nl();
                    return (
                      (t = void 0 !== a ? a(t) : t),
                      (n.memoizedState = n.baseState = t),
                      (e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: e,
                        lastRenderedState: t,
                      }),
                      (n.queue = e),
                      (e = e.dispatch = eo.bind(null, fl, e)),
                      [n.memoizedState, e]
                    );
                  },
                  useRef: function (e) {
                    return (e = { current: e }), (Nl().memoizedState = e);
                  },
                  useState: Ll,
                  useDebugValue: Wl,
                  useDeferredValue: function (e) {
                    return (Nl().memoizedState = e);
                  },
                  useTransition: function () {
                    var e = Ll(!1),
                      t = e[0];
                    return (
                      (e = Kl.bind(null, e[1])),
                      (Nl().memoizedState = e),
                      [t, e]
                    );
                  },
                  useMutableSource: function () {},
                  useSyncExternalStore: function (e, t, a) {
                    var n = fl,
                      i = Nl();
                    if (ir) {
                      if (void 0 === a) throw Error(r(407));
                      a = a();
                    } else {
                      if (((a = t()), null === Fu)) throw Error(r(349));
                      0 !== (30 & ml) || kl(n, t, a);
                    }
                    i.memoizedState = a;
                    var l = { value: a, getSnapshot: t };
                    return (
                      (i.queue = l),
                      Ul(Ol.bind(null, n, l, e), [e]),
                      (n.flags |= 2048),
                      Tl(9, Bl.bind(null, n, l, a, t), void 0, null),
                      a
                    );
                  },
                  useId: function () {
                    var e = Nl(),
                      t = Fu.identifierPrefix;
                    if (ir) {
                      var a = Ji;
                      (t =
                        ":" +
                        t +
                        "R" +
                        (a =
                          ($i & ~(1 << (32 - lt($i) - 1))).toString(32) + a)),
                        0 < (a = xl++) && (t += "H" + a.toString(32)),
                        (t += ":");
                    } else t = ":" + t + "r" + (a = zl++).toString(32) + ":";
                    return (e.memoizedState = t);
                  },
                  unstable_isNewReconciler: !1,
                },
                oo = {
                  readContext: Nr,
                  useCallback: Vl,
                  useContext: Nr,
                  useEffect: Ql,
                  useImperativeHandle: Gl,
                  useInsertionEffect: Yl,
                  useLayoutEffect: Hl,
                  useMemo: $l,
                  useReducer: wl,
                  useRef: ql,
                  useState: function () {
                    return wl(Rl);
                  },
                  useDebugValue: Wl,
                  useDeferredValue: function (e) {
                    return Jl(Sl(), gl.memoizedState, e);
                  },
                  useTransition: function () {
                    return [wl(Rl)[0], Sl().memoizedState];
                  },
                  useMutableSource: Fl,
                  useSyncExternalStore: _l,
                  useId: Zl,
                  unstable_isNewReconciler: !1,
                },
                uo = {
                  readContext: Nr,
                  useCallback: Vl,
                  useContext: Nr,
                  useEffect: Ql,
                  useImperativeHandle: Gl,
                  useInsertionEffect: Yl,
                  useLayoutEffect: Hl,
                  useMemo: $l,
                  useReducer: Dl,
                  useRef: ql,
                  useState: function () {
                    return Dl(Rl);
                  },
                  useDebugValue: Wl,
                  useDeferredValue: function (e) {
                    var t = Sl();
                    return null === gl
                      ? (t.memoizedState = e)
                      : Jl(t, gl.memoizedState, e);
                  },
                  useTransition: function () {
                    return [Dl(Rl)[0], Sl().memoizedState];
                  },
                  useMutableSource: Fl,
                  useSyncExternalStore: _l,
                  useId: Zl,
                  unstable_isNewReconciler: !1,
                };
              function so(e, t) {
                try {
                  var a = "",
                    n = t;
                  do {
                    (a += j(n)), (n = n.return);
                  } while (n);
                  var i = a;
                } catch (r) {
                  i = "\nError generating stack: " + r.message + "\n" + r.stack;
                }
                return { value: e, source: t, stack: i, digest: null };
              }
              function co(e, t, a) {
                return {
                  value: e,
                  source: null,
                  stack: null != a ? a : null,
                  digest: null != t ? t : null,
                };
              }
              function po(e, t) {
                try {
                  console.error(t.value);
                } catch (a) {
                  setTimeout(function () {
                    throw a;
                  });
                }
              }
              var mo = "function" === typeof WeakMap ? WeakMap : Map;
              function fo(e, t, a) {
                ((a = Br(-1, a)).tag = 3), (a.payload = { element: null });
                var n = t.value;
                return (
                  (a.callback = function () {
                    Hu || ((Hu = !0), (Xu = n)), po(0, t);
                  }),
                  a
                );
              }
              function go(e, t, a) {
                (a = Br(-1, a)).tag = 3;
                var n = e.type.getDerivedStateFromError;
                if ("function" === typeof n) {
                  var i = t.value;
                  (a.payload = function () {
                    return n(i);
                  }),
                    (a.callback = function () {
                      po(0, t);
                    });
                }
                var r = e.stateNode;
                return (
                  null !== r &&
                    "function" === typeof r.componentDidCatch &&
                    (a.callback = function () {
                      po(0, t),
                        "function" !== typeof n &&
                          (null === Gu ? (Gu = new Set([this])) : Gu.add(this));
                      var e = t.stack;
                      this.componentDidCatch(t.value, {
                        componentStack: null !== e ? e : "",
                      });
                    }),
                  a
                );
              }
              function ho(e, t, a) {
                var n = e.pingCache;
                if (null === n) {
                  n = e.pingCache = new mo();
                  var i = new Set();
                  n.set(t, i);
                } else
                  void 0 === (i = n.get(t)) && ((i = new Set()), n.set(t, i));
                i.has(a) ||
                  (i.add(a), (e = Ss.bind(null, e, t, a)), t.then(e, e));
              }
              function bo(e) {
                do {
                  var t;
                  if (
                    ((t = 13 === e.tag) &&
                      (t =
                        null === (t = e.memoizedState) ||
                        null !== t.dehydrated),
                    t)
                  )
                    return e;
                  e = e.return;
                } while (null !== e);
                return null;
              }
              function vo(e, t, a, n, i) {
                return 0 === (1 & e.mode)
                  ? (e === t
                      ? (e.flags |= 65536)
                      : ((e.flags |= 128),
                        (a.flags |= 131072),
                        (a.flags &= -52805),
                        1 === a.tag &&
                          (null === a.alternate
                            ? (a.tag = 17)
                            : (((t = Br(-1, 1)).tag = 2), Or(a, t, 1))),
                        (a.lanes |= 1)),
                    e)
                  : ((e.flags |= 65536), (e.lanes = i), e);
              }
              var xo = z.ReactCurrentOwner,
                zo = !1;
              function yo(e, t, a, n) {
                t.child = null === e ? Jr(t, null, a, n) : $r(t, e.child, a, n);
              }
              function Ao(e, t, a, n, i) {
                a = a.render;
                var r = t.ref;
                return (
                  Cr(t, i),
                  (n = El(e, t, a, n, r, i)),
                  (a = Cl()),
                  null === e || zo
                    ? (ir && a && er(t),
                      (t.flags |= 1),
                      yo(e, t, n, i),
                      t.child)
                    : ((t.updateQueue = e.updateQueue),
                      (t.flags &= -2053),
                      (e.lanes &= ~i),
                      Ho(e, t, i))
                );
              }
              function Eo(e, t, a, n, i) {
                if (null === e) {
                  var r = a.type;
                  return "function" !== typeof r ||
                    Bs(r) ||
                    void 0 !== r.defaultProps ||
                    null !== a.compare ||
                    void 0 !== a.defaultProps
                    ? (((e = Ps(a.type, null, n, t, t.mode, i)).ref = t.ref),
                      (e.return = t),
                      (t.child = e))
                    : ((t.tag = 15), (t.type = r), Co(e, t, r, n, i));
                }
                if (((r = e.child), 0 === (e.lanes & i))) {
                  var l = r.memoizedProps;
                  if (
                    (a = null !== (a = a.compare) ? a : un)(l, n) &&
                    e.ref === t.ref
                  )
                    return Ho(e, t, i);
                }
                return (
                  (t.flags |= 1),
                  ((e = Os(r, n)).ref = t.ref),
                  (e.return = t),
                  (t.child = e)
                );
              }
              function Co(e, t, a, n, i) {
                if (null !== e) {
                  var r = e.memoizedProps;
                  if (un(r, n) && e.ref === t.ref) {
                    if (
                      ((zo = !1), (t.pendingProps = n = r), 0 === (e.lanes & i))
                    )
                      return (t.lanes = e.lanes), Ho(e, t, i);
                    0 !== (131072 & e.flags) && (zo = !0);
                  }
                }
                return Ro(e, t, a, n, i);
              }
              function No(e, t, a) {
                var n = t.pendingProps,
                  i = n.children,
                  r = null !== e ? e.memoizedState : null;
                if ("hidden" === n.mode)
                  if (0 === (1 & t.mode))
                    (t.memoizedState = {
                      baseLanes: 0,
                      cachePool: null,
                      transitions: null,
                    }),
                      Si(Ou, Bu),
                      (Bu |= a);
                  else {
                    if (0 === (1073741824 & a))
                      return (
                        (e = null !== r ? r.baseLanes | a : a),
                        (t.lanes = t.childLanes = 1073741824),
                        (t.memoizedState = {
                          baseLanes: e,
                          cachePool: null,
                          transitions: null,
                        }),
                        (t.updateQueue = null),
                        Si(Ou, Bu),
                        (Bu |= e),
                        null
                      );
                    (t.memoizedState = {
                      baseLanes: 0,
                      cachePool: null,
                      transitions: null,
                    }),
                      (n = null !== r ? r.baseLanes : a),
                      Si(Ou, Bu),
                      (Bu |= n);
                  }
                else
                  null !== r
                    ? ((n = r.baseLanes | a), (t.memoizedState = null))
                    : (n = a),
                    Si(Ou, Bu),
                    (Bu |= n);
                return yo(e, t, i, a), t.child;
              }
              function So(e, t) {
                var a = t.ref;
                ((null === e && null !== a) || (null !== e && e.ref !== a)) &&
                  ((t.flags |= 512), (t.flags |= 2097152));
              }
              function Ro(e, t, a, n, i) {
                var r = ki(a) ? Fi : wi.current;
                return (
                  (r = _i(t, r)),
                  Cr(t, i),
                  (a = El(e, t, a, n, r, i)),
                  (n = Cl()),
                  null === e || zo
                    ? (ir && n && er(t),
                      (t.flags |= 1),
                      yo(e, t, a, i),
                      t.child)
                    : ((t.updateQueue = e.updateQueue),
                      (t.flags &= -2053),
                      (e.lanes &= ~i),
                      Ho(e, t, i))
                );
              }
              function wo(e, t, a, n, i) {
                if (ki(a)) {
                  var r = !0;
                  Ii(t);
                } else r = !1;
                if ((Cr(t, i), null === t.stateNode))
                  Yo(e, t), Qr(t, a, n), Hr(t, a, n, i), (n = !0);
                else if (null === e) {
                  var l = t.stateNode,
                    o = t.memoizedProps;
                  l.props = o;
                  var u = l.context,
                    s = a.contextType;
                  "object" === typeof s && null !== s
                    ? (s = Nr(s))
                    : (s = _i(t, (s = ki(a) ? Fi : wi.current)));
                  var c = a.getDerivedStateFromProps,
                    d =
                      "function" === typeof c ||
                      "function" === typeof l.getSnapshotBeforeUpdate;
                  d ||
                    ("function" !== typeof l.UNSAFE_componentWillReceiveProps &&
                      "function" !== typeof l.componentWillReceiveProps) ||
                    ((o !== n || u !== s) && Yr(t, l, n, s)),
                    (Fr = !1);
                  var p = t.memoizedState;
                  (l.state = p),
                    Lr(t, n, l, i),
                    (u = t.memoizedState),
                    o !== n || p !== u || Di.current || Fr
                      ? ("function" === typeof c &&
                          (Mr(t, a, c, n), (u = t.memoizedState)),
                        (o = Fr || Ur(t, a, o, n, p, u, s))
                          ? (d ||
                              ("function" !==
                                typeof l.UNSAFE_componentWillMount &&
                                "function" !== typeof l.componentWillMount) ||
                              ("function" === typeof l.componentWillMount &&
                                l.componentWillMount(),
                              "function" ===
                                typeof l.UNSAFE_componentWillMount &&
                                l.UNSAFE_componentWillMount()),
                            "function" === typeof l.componentDidMount &&
                              (t.flags |= 4194308))
                          : ("function" === typeof l.componentDidMount &&
                              (t.flags |= 4194308),
                            (t.memoizedProps = n),
                            (t.memoizedState = u)),
                        (l.props = n),
                        (l.state = u),
                        (l.context = s),
                        (n = o))
                      : ("function" === typeof l.componentDidMount &&
                          (t.flags |= 4194308),
                        (n = !1));
                } else {
                  (l = t.stateNode),
                    kr(e, t),
                    (o = t.memoizedProps),
                    (s = t.type === t.elementType ? o : hr(t.type, o)),
                    (l.props = s),
                    (d = t.pendingProps),
                    (p = l.context),
                    "object" === typeof (u = a.contextType) && null !== u
                      ? (u = Nr(u))
                      : (u = _i(t, (u = ki(a) ? Fi : wi.current)));
                  var m = a.getDerivedStateFromProps;
                  (c =
                    "function" === typeof m ||
                    "function" === typeof l.getSnapshotBeforeUpdate) ||
                    ("function" !== typeof l.UNSAFE_componentWillReceiveProps &&
                      "function" !== typeof l.componentWillReceiveProps) ||
                    ((o !== d || p !== u) && Yr(t, l, n, u)),
                    (Fr = !1),
                    (p = t.memoizedState),
                    (l.state = p),
                    Lr(t, n, l, i);
                  var f = t.memoizedState;
                  o !== d || p !== f || Di.current || Fr
                    ? ("function" === typeof m &&
                        (Mr(t, a, m, n), (f = t.memoizedState)),
                      (s = Fr || Ur(t, a, s, n, p, f, u) || !1)
                        ? (c ||
                            ("function" !==
                              typeof l.UNSAFE_componentWillUpdate &&
                              "function" !== typeof l.componentWillUpdate) ||
                            ("function" === typeof l.componentWillUpdate &&
                              l.componentWillUpdate(n, f, u),
                            "function" ===
                              typeof l.UNSAFE_componentWillUpdate &&
                              l.UNSAFE_componentWillUpdate(n, f, u)),
                          "function" === typeof l.componentDidUpdate &&
                            (t.flags |= 4),
                          "function" === typeof l.getSnapshotBeforeUpdate &&
                            (t.flags |= 1024))
                        : ("function" !== typeof l.componentDidUpdate ||
                            (o === e.memoizedProps && p === e.memoizedState) ||
                            (t.flags |= 4),
                          "function" !== typeof l.getSnapshotBeforeUpdate ||
                            (o === e.memoizedProps && p === e.memoizedState) ||
                            (t.flags |= 1024),
                          (t.memoizedProps = n),
                          (t.memoizedState = f)),
                      (l.props = n),
                      (l.state = f),
                      (l.context = u),
                      (n = s))
                    : ("function" !== typeof l.componentDidUpdate ||
                        (o === e.memoizedProps && p === e.memoizedState) ||
                        (t.flags |= 4),
                      "function" !== typeof l.getSnapshotBeforeUpdate ||
                        (o === e.memoizedProps && p === e.memoizedState) ||
                        (t.flags |= 1024),
                      (n = !1));
                }
                return Do(e, t, a, n, r, i);
              }
              function Do(e, t, a, n, i, r) {
                So(e, t);
                var l = 0 !== (128 & t.flags);
                if (!n && !l) return i && Li(t, a, !1), Ho(e, t, r);
                (n = t.stateNode), (xo.current = t);
                var o =
                  l && "function" !== typeof a.getDerivedStateFromError
                    ? null
                    : n.render();
                return (
                  (t.flags |= 1),
                  null !== e && l
                    ? ((t.child = $r(t, e.child, null, r)),
                      (t.child = $r(t, null, o, r)))
                    : yo(e, t, o, r),
                  (t.memoizedState = n.state),
                  i && Li(t, a, !0),
                  t.child
                );
              }
              function Fo(e) {
                var t = e.stateNode;
                t.pendingContext
                  ? Oi(0, t.pendingContext, t.pendingContext !== t.context)
                  : t.context && Oi(0, t.context, !1),
                  nl(e, t.containerInfo);
              }
              function _o(e, t, a, n, i) {
                return mr(), fr(i), (t.flags |= 256), yo(e, t, a, n), t.child;
              }
              var ko,
                Bo,
                Oo,
                Po,
                Io = { dehydrated: null, treeContext: null, retryLane: 0 };
              function Lo(e) {
                return { baseLanes: e, cachePool: null, transitions: null };
              }
              function To(e, t, a) {
                var n,
                  i = t.pendingProps,
                  l = ol.current,
                  o = !1,
                  u = 0 !== (128 & t.flags);
                if (
                  ((n = u) ||
                    (n =
                      (null === e || null !== e.memoizedState) &&
                      0 !== (2 & l)),
                  n
                    ? ((o = !0), (t.flags &= -129))
                    : (null !== e && null === e.memoizedState) || (l |= 1),
                  Si(ol, 1 & l),
                  null === e)
                )
                  return (
                    sr(t),
                    null !== (e = t.memoizedState) &&
                    null !== (e = e.dehydrated)
                      ? (0 === (1 & t.mode)
                          ? (t.lanes = 1)
                          : "$!" === e.data
                          ? (t.lanes = 8)
                          : (t.lanes = 1073741824),
                        null)
                      : ((u = i.children),
                        (e = i.fallback),
                        o
                          ? ((i = t.mode),
                            (o = t.child),
                            (u = { mode: "hidden", children: u }),
                            0 === (1 & i) && null !== o
                              ? ((o.childLanes = 0), (o.pendingProps = u))
                              : (o = Ls(u, i, 0, null)),
                            (e = Is(e, i, a, null)),
                            (o.return = t),
                            (e.return = t),
                            (o.sibling = e),
                            (t.child = o),
                            (t.child.memoizedState = Lo(a)),
                            (t.memoizedState = Io),
                            e)
                          : qo(t, u))
                  );
                if (
                  null !== (l = e.memoizedState) &&
                  null !== (n = l.dehydrated)
                )
                  return (function (e, t, a, n, i, l, o) {
                    if (a)
                      return 256 & t.flags
                        ? ((t.flags &= -257),
                          Mo(e, t, o, (n = co(Error(r(422))))))
                        : null !== t.memoizedState
                        ? ((t.child = e.child), (t.flags |= 128), null)
                        : ((l = n.fallback),
                          (i = t.mode),
                          (n = Ls(
                            { mode: "visible", children: n.children },
                            i,
                            0,
                            null
                          )),
                          ((l = Is(l, i, o, null)).flags |= 2),
                          (n.return = t),
                          (l.return = t),
                          (n.sibling = l),
                          (t.child = n),
                          0 !== (1 & t.mode) && $r(t, e.child, null, o),
                          (t.child.memoizedState = Lo(o)),
                          (t.memoizedState = Io),
                          l);
                    if (0 === (1 & t.mode)) return Mo(e, t, o, null);
                    if ("$!" === i.data) {
                      if ((n = i.nextSibling && i.nextSibling.dataset))
                        var u = n.dgst;
                      return (
                        (n = u),
                        Mo(e, t, o, (n = co((l = Error(r(419))), n, void 0)))
                      );
                    }
                    if (((u = 0 !== (o & e.childLanes)), zo || u)) {
                      if (null !== (n = Fu)) {
                        switch (o & -o) {
                          case 4:
                            i = 2;
                            break;
                          case 16:
                            i = 8;
                            break;
                          case 64:
                          case 128:
                          case 256:
                          case 512:
                          case 1024:
                          case 2048:
                          case 4096:
                          case 8192:
                          case 16384:
                          case 32768:
                          case 65536:
                          case 131072:
                          case 262144:
                          case 524288:
                          case 1048576:
                          case 2097152:
                          case 4194304:
                          case 8388608:
                          case 16777216:
                          case 33554432:
                          case 67108864:
                            i = 32;
                            break;
                          case 536870912:
                            i = 268435456;
                            break;
                          default:
                            i = 0;
                        }
                        0 !==
                          (i = 0 !== (i & (n.suspendedLanes | o)) ? 0 : i) &&
                          i !== l.retryLane &&
                          ((l.retryLane = i), Dr(e, i), ns(n, e, i, -1));
                      }
                      return hs(), Mo(e, t, o, (n = co(Error(r(421)))));
                    }
                    return "$?" === i.data
                      ? ((t.flags |= 128),
                        (t.child = e.child),
                        (t = ws.bind(null, e)),
                        (i._reactRetry = t),
                        null)
                      : ((e = l.treeContext),
                        (nr = si(i.nextSibling)),
                        (ar = t),
                        (ir = !0),
                        (rr = null),
                        null !== e &&
                          ((Gi[Wi++] = $i),
                          (Gi[Wi++] = Ji),
                          (Gi[Wi++] = Vi),
                          ($i = e.id),
                          (Ji = e.overflow),
                          (Vi = t)),
                        (t = qo(t, n.children)),
                        (t.flags |= 4096),
                        t);
                  })(e, t, u, i, n, l, a);
                if (o) {
                  (o = i.fallback), (u = t.mode), (n = (l = e.child).sibling);
                  var s = { mode: "hidden", children: i.children };
                  return (
                    0 === (1 & u) && t.child !== l
                      ? (((i = t.child).childLanes = 0),
                        (i.pendingProps = s),
                        (t.deletions = null))
                      : ((i = Os(l, s)).subtreeFlags =
                          14680064 & l.subtreeFlags),
                    null !== n
                      ? (o = Os(n, o))
                      : ((o = Is(o, u, a, null)).flags |= 2),
                    (o.return = t),
                    (i.return = t),
                    (i.sibling = o),
                    (t.child = i),
                    (i = o),
                    (o = t.child),
                    (u =
                      null === (u = e.child.memoizedState)
                        ? Lo(a)
                        : {
                            baseLanes: u.baseLanes | a,
                            cachePool: null,
                            transitions: u.transitions,
                          }),
                    (o.memoizedState = u),
                    (o.childLanes = e.childLanes & ~a),
                    (t.memoizedState = Io),
                    i
                  );
                }
                return (
                  (e = (o = e.child).sibling),
                  (i = Os(o, { mode: "visible", children: i.children })),
                  0 === (1 & t.mode) && (i.lanes = a),
                  (i.return = t),
                  (i.sibling = null),
                  null !== e &&
                    (null === (a = t.deletions)
                      ? ((t.deletions = [e]), (t.flags |= 16))
                      : a.push(e)),
                  (t.child = i),
                  (t.memoizedState = null),
                  i
                );
              }
              function qo(e, t) {
                return (
                  ((t = Ls(
                    { mode: "visible", children: t },
                    e.mode,
                    0,
                    null
                  )).return = e),
                  (e.child = t)
                );
              }
              function Mo(e, t, a, n) {
                return (
                  null !== n && fr(n),
                  $r(t, e.child, null, a),
                  ((e = qo(t, t.pendingProps.children)).flags |= 2),
                  (t.memoizedState = null),
                  e
                );
              }
              function jo(e, t, a) {
                e.lanes |= t;
                var n = e.alternate;
                null !== n && (n.lanes |= t), Er(e.return, t, a);
              }
              function Uo(e, t, a, n, i) {
                var r = e.memoizedState;
                null === r
                  ? (e.memoizedState = {
                      isBackwards: t,
                      rendering: null,
                      renderingStartTime: 0,
                      last: n,
                      tail: a,
                      tailMode: i,
                    })
                  : ((r.isBackwards = t),
                    (r.rendering = null),
                    (r.renderingStartTime = 0),
                    (r.last = n),
                    (r.tail = a),
                    (r.tailMode = i));
              }
              function Qo(e, t, a) {
                var n = t.pendingProps,
                  i = n.revealOrder,
                  r = n.tail;
                if ((yo(e, t, n.children, a), 0 !== (2 & (n = ol.current))))
                  (n = (1 & n) | 2), (t.flags |= 128);
                else {
                  if (null !== e && 0 !== (128 & e.flags))
                    e: for (e = t.child; null !== e; ) {
                      if (13 === e.tag) null !== e.memoizedState && jo(e, a, t);
                      else if (19 === e.tag) jo(e, a, t);
                      else if (null !== e.child) {
                        (e.child.return = e), (e = e.child);
                        continue;
                      }
                      if (e === t) break e;
                      for (; null === e.sibling; ) {
                        if (null === e.return || e.return === t) break e;
                        e = e.return;
                      }
                      (e.sibling.return = e.return), (e = e.sibling);
                    }
                  n &= 1;
                }
                if ((Si(ol, n), 0 === (1 & t.mode))) t.memoizedState = null;
                else
                  switch (i) {
                    case "forwards":
                      for (a = t.child, i = null; null !== a; )
                        null !== (e = a.alternate) && null === ul(e) && (i = a),
                          (a = a.sibling);
                      null === (a = i)
                        ? ((i = t.child), (t.child = null))
                        : ((i = a.sibling), (a.sibling = null)),
                        Uo(t, !1, i, a, r);
                      break;
                    case "backwards":
                      for (
                        a = null, i = t.child, t.child = null;
                        null !== i;

                      ) {
                        if (null !== (e = i.alternate) && null === ul(e)) {
                          t.child = i;
                          break;
                        }
                        (e = i.sibling), (i.sibling = a), (a = i), (i = e);
                      }
                      Uo(t, !0, a, null, r);
                      break;
                    case "together":
                      Uo(t, !1, null, null, void 0);
                      break;
                    default:
                      t.memoizedState = null;
                  }
                return t.child;
              }
              function Yo(e, t) {
                0 === (1 & t.mode) &&
                  null !== e &&
                  ((e.alternate = null), (t.alternate = null), (t.flags |= 2));
              }
              function Ho(e, t, a) {
                if (
                  (null !== e && (t.dependencies = e.dependencies),
                  (Lu |= t.lanes),
                  0 === (a & t.childLanes))
                )
                  return null;
                if (null !== e && t.child !== e.child) throw Error(r(153));
                if (null !== t.child) {
                  for (
                    a = Os((e = t.child), e.pendingProps),
                      t.child = a,
                      a.return = t;
                    null !== e.sibling;

                  )
                    (e = e.sibling),
                      ((a = a.sibling = Os(e, e.pendingProps)).return = t);
                  a.sibling = null;
                }
                return t.child;
              }
              function Xo(e, t) {
                if (!ir)
                  switch (e.tailMode) {
                    case "hidden":
                      t = e.tail;
                      for (var a = null; null !== t; )
                        null !== t.alternate && (a = t), (t = t.sibling);
                      null === a ? (e.tail = null) : (a.sibling = null);
                      break;
                    case "collapsed":
                      a = e.tail;
                      for (var n = null; null !== a; )
                        null !== a.alternate && (n = a), (a = a.sibling);
                      null === n
                        ? t || null === e.tail
                          ? (e.tail = null)
                          : (e.tail.sibling = null)
                        : (n.sibling = null);
                  }
              }
              function Go(e) {
                var t = null !== e.alternate && e.alternate.child === e.child,
                  a = 0,
                  n = 0;
                if (t)
                  for (var i = e.child; null !== i; )
                    (a |= i.lanes | i.childLanes),
                      (n |= 14680064 & i.subtreeFlags),
                      (n |= 14680064 & i.flags),
                      (i.return = e),
                      (i = i.sibling);
                else
                  for (i = e.child; null !== i; )
                    (a |= i.lanes | i.childLanes),
                      (n |= i.subtreeFlags),
                      (n |= i.flags),
                      (i.return = e),
                      (i = i.sibling);
                return (e.subtreeFlags |= n), (e.childLanes = a), t;
              }
              function Wo(e, t, a) {
                var n = t.pendingProps;
                switch ((tr(t), t.tag)) {
                  case 2:
                  case 16:
                  case 15:
                  case 0:
                  case 11:
                  case 7:
                  case 8:
                  case 12:
                  case 9:
                  case 14:
                    return Go(t), null;
                  case 1:
                  case 17:
                    return ki(t.type) && Bi(), Go(t), null;
                  case 3:
                    return (
                      (n = t.stateNode),
                      il(),
                      Ni(Di),
                      Ni(wi),
                      cl(),
                      n.pendingContext &&
                        ((n.context = n.pendingContext),
                        (n.pendingContext = null)),
                      (null !== e && null !== e.child) ||
                        (dr(t)
                          ? (t.flags |= 4)
                          : null === e ||
                            (e.memoizedState.isDehydrated &&
                              0 === (256 & t.flags)) ||
                            ((t.flags |= 1024),
                            null !== rr && (os(rr), (rr = null)))),
                      Bo(e, t),
                      Go(t),
                      null
                    );
                  case 5:
                    ll(t);
                    var i = al(tl.current);
                    if (((a = t.type), null !== e && null != t.stateNode))
                      Oo(e, t, a, n, i),
                        e.ref !== t.ref &&
                          ((t.flags |= 512), (t.flags |= 2097152));
                    else {
                      if (!n) {
                        if (null === t.stateNode) throw Error(r(166));
                        return Go(t), null;
                      }
                      if (((e = al(Zr.current)), dr(t))) {
                        (n = t.stateNode), (a = t.type);
                        var l = t.memoizedProps;
                        switch (
                          ((n[pi] = t),
                          (n[mi] = l),
                          (e = 0 !== (1 & t.mode)),
                          a)
                        ) {
                          case "dialog":
                            qn("cancel", n), qn("close", n);
                            break;
                          case "iframe":
                          case "object":
                          case "embed":
                            qn("load", n);
                            break;
                          case "video":
                          case "audio":
                            for (i = 0; i < Pn.length; i++) qn(Pn[i], n);
                            break;
                          case "source":
                            qn("error", n);
                            break;
                          case "img":
                          case "image":
                          case "link":
                            qn("error", n), qn("load", n);
                            break;
                          case "details":
                            qn("toggle", n);
                            break;
                          case "input":
                            $(n, l), qn("invalid", n);
                            break;
                          case "select":
                            (n._wrapperState = { wasMultiple: !!l.multiple }),
                              qn("invalid", n);
                            break;
                          case "textarea":
                            ie(n, l), qn("invalid", n);
                        }
                        for (var u in (ve(a, l), (i = null), l))
                          if (l.hasOwnProperty(u)) {
                            var s = l[u];
                            "children" === u
                              ? "string" === typeof s
                                ? n.textContent !== s &&
                                  (!0 !== l.suppressHydrationWarning &&
                                    Kn(n.textContent, s, e),
                                  (i = ["children", s]))
                                : "number" === typeof s &&
                                  n.textContent !== "" + s &&
                                  (!0 !== l.suppressHydrationWarning &&
                                    Kn(n.textContent, s, e),
                                  (i = ["children", "" + s]))
                              : o.hasOwnProperty(u) &&
                                null != s &&
                                "onScroll" === u &&
                                qn("scroll", n);
                          }
                        switch (a) {
                          case "input":
                            X(n), Z(n, l, !0);
                            break;
                          case "textarea":
                            X(n), le(n);
                            break;
                          case "select":
                          case "option":
                            break;
                          default:
                            "function" === typeof l.onClick && (n.onclick = Zn);
                        }
                        (n = i),
                          (t.updateQueue = n),
                          null !== n && (t.flags |= 4);
                      } else {
                        (u = 9 === i.nodeType ? i : i.ownerDocument),
                          "http://www.w3.org/1999/xhtml" === e && (e = oe(a)),
                          "http://www.w3.org/1999/xhtml" === e
                            ? "script" === a
                              ? (((e = u.createElement("div")).innerHTML =
                                  "<script><\/script>"),
                                (e = e.removeChild(e.firstChild)))
                              : "string" === typeof n.is
                              ? (e = u.createElement(a, { is: n.is }))
                              : ((e = u.createElement(a)),
                                "select" === a &&
                                  ((u = e),
                                  n.multiple
                                    ? (u.multiple = !0)
                                    : n.size && (u.size = n.size)))
                            : (e = u.createElementNS(e, a)),
                          (e[pi] = t),
                          (e[mi] = n),
                          ko(e, t, !1, !1),
                          (t.stateNode = e);
                        e: {
                          switch (((u = xe(a, n)), a)) {
                            case "dialog":
                              qn("cancel", e), qn("close", e), (i = n);
                              break;
                            case "iframe":
                            case "object":
                            case "embed":
                              qn("load", e), (i = n);
                              break;
                            case "video":
                            case "audio":
                              for (i = 0; i < Pn.length; i++) qn(Pn[i], e);
                              i = n;
                              break;
                            case "source":
                              qn("error", e), (i = n);
                              break;
                            case "img":
                            case "image":
                            case "link":
                              qn("error", e), qn("load", e), (i = n);
                              break;
                            case "details":
                              qn("toggle", e), (i = n);
                              break;
                            case "input":
                              $(e, n), (i = V(e, n)), qn("invalid", e);
                              break;
                            case "option":
                            default:
                              i = n;
                              break;
                            case "select":
                              (e._wrapperState = { wasMultiple: !!n.multiple }),
                                (i = L({}, n, { value: void 0 })),
                                qn("invalid", e);
                              break;
                            case "textarea":
                              ie(e, n), (i = ne(e, n)), qn("invalid", e);
                          }
                          for (l in (ve(a, i), (s = i)))
                            if (s.hasOwnProperty(l)) {
                              var c = s[l];
                              "style" === l
                                ? he(e, c)
                                : "dangerouslySetInnerHTML" === l
                                ? null != (c = c ? c.__html : void 0) &&
                                  de(e, c)
                                : "children" === l
                                ? "string" === typeof c
                                  ? ("textarea" !== a || "" !== c) && pe(e, c)
                                  : "number" === typeof c && pe(e, "" + c)
                                : "suppressContentEditableWarning" !== l &&
                                  "suppressHydrationWarning" !== l &&
                                  "autoFocus" !== l &&
                                  (o.hasOwnProperty(l)
                                    ? null != c &&
                                      "onScroll" === l &&
                                      qn("scroll", e)
                                    : null != c && x(e, l, c, u));
                            }
                          switch (a) {
                            case "input":
                              X(e), Z(e, n, !1);
                              break;
                            case "textarea":
                              X(e), le(e);
                              break;
                            case "option":
                              null != n.value &&
                                e.setAttribute("value", "" + Y(n.value));
                              break;
                            case "select":
                              (e.multiple = !!n.multiple),
                                null != (l = n.value)
                                  ? ae(e, !!n.multiple, l, !1)
                                  : null != n.defaultValue &&
                                    ae(e, !!n.multiple, n.defaultValue, !0);
                              break;
                            default:
                              "function" === typeof i.onClick &&
                                (e.onclick = Zn);
                          }
                          switch (a) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                              n = !!n.autoFocus;
                              break e;
                            case "img":
                              n = !0;
                              break e;
                            default:
                              n = !1;
                          }
                        }
                        n && (t.flags |= 4);
                      }
                      null !== t.ref &&
                        ((t.flags |= 512), (t.flags |= 2097152));
                    }
                    return Go(t), null;
                  case 6:
                    if (e && null != t.stateNode) Po(e, t, e.memoizedProps, n);
                    else {
                      if ("string" !== typeof n && null === t.stateNode)
                        throw Error(r(166));
                      if (((a = al(tl.current)), al(Zr.current), dr(t))) {
                        if (
                          ((n = t.stateNode),
                          (a = t.memoizedProps),
                          (n[pi] = t),
                          (l = n.nodeValue !== a) && null !== (e = ar))
                        )
                          switch (e.tag) {
                            case 3:
                              Kn(n.nodeValue, a, 0 !== (1 & e.mode));
                              break;
                            case 5:
                              !0 !== e.memoizedProps.suppressHydrationWarning &&
                                Kn(n.nodeValue, a, 0 !== (1 & e.mode));
                          }
                        l && (t.flags |= 4);
                      } else
                        ((n = (
                          9 === a.nodeType ? a : a.ownerDocument
                        ).createTextNode(n))[pi] = t),
                          (t.stateNode = n);
                    }
                    return Go(t), null;
                  case 13:
                    if (
                      (Ni(ol),
                      (n = t.memoizedState),
                      null === e ||
                        (null !== e.memoizedState &&
                          null !== e.memoizedState.dehydrated))
                    ) {
                      if (
                        ir &&
                        null !== nr &&
                        0 !== (1 & t.mode) &&
                        0 === (128 & t.flags)
                      )
                        pr(), mr(), (t.flags |= 98560), (l = !1);
                      else if (
                        ((l = dr(t)), null !== n && null !== n.dehydrated)
                      ) {
                        if (null === e) {
                          if (!l) throw Error(r(318));
                          if (
                            !(l =
                              null !== (l = t.memoizedState)
                                ? l.dehydrated
                                : null)
                          )
                            throw Error(r(317));
                          l[pi] = t;
                        } else
                          mr(),
                            0 === (128 & t.flags) && (t.memoizedState = null),
                            (t.flags |= 4);
                        Go(t), (l = !1);
                      } else null !== rr && (os(rr), (rr = null)), (l = !0);
                      if (!l) return 65536 & t.flags ? t : null;
                    }
                    return 0 !== (128 & t.flags)
                      ? ((t.lanes = a), t)
                      : ((n = null !== n) !==
                          (null !== e && null !== e.memoizedState) &&
                          n &&
                          ((t.child.flags |= 8192),
                          0 !== (1 & t.mode) &&
                            (null === e || 0 !== (1 & ol.current)
                              ? 0 === Pu && (Pu = 3)
                              : hs())),
                        null !== t.updateQueue && (t.flags |= 4),
                        Go(t),
                        null);
                  case 4:
                    return (
                      il(),
                      Bo(e, t),
                      null === e && Un(t.stateNode.containerInfo),
                      Go(t),
                      null
                    );
                  case 10:
                    return Ar(t.type._context), Go(t), null;
                  case 19:
                    if ((Ni(ol), null === (l = t.memoizedState)))
                      return Go(t), null;
                    if (
                      ((n = 0 !== (128 & t.flags)), null === (u = l.rendering))
                    )
                      if (n) Xo(l, !1);
                      else {
                        if (0 !== Pu || (null !== e && 0 !== (128 & e.flags)))
                          for (e = t.child; null !== e; ) {
                            if (null !== (u = ul(e))) {
                              for (
                                t.flags |= 128,
                                  Xo(l, !1),
                                  null !== (n = u.updateQueue) &&
                                    ((t.updateQueue = n), (t.flags |= 4)),
                                  t.subtreeFlags = 0,
                                  n = a,
                                  a = t.child;
                                null !== a;

                              )
                                (e = n),
                                  ((l = a).flags &= 14680066),
                                  null === (u = l.alternate)
                                    ? ((l.childLanes = 0),
                                      (l.lanes = e),
                                      (l.child = null),
                                      (l.subtreeFlags = 0),
                                      (l.memoizedProps = null),
                                      (l.memoizedState = null),
                                      (l.updateQueue = null),
                                      (l.dependencies = null),
                                      (l.stateNode = null))
                                    : ((l.childLanes = u.childLanes),
                                      (l.lanes = u.lanes),
                                      (l.child = u.child),
                                      (l.subtreeFlags = 0),
                                      (l.deletions = null),
                                      (l.memoizedProps = u.memoizedProps),
                                      (l.memoizedState = u.memoizedState),
                                      (l.updateQueue = u.updateQueue),
                                      (l.type = u.type),
                                      (e = u.dependencies),
                                      (l.dependencies =
                                        null === e
                                          ? null
                                          : {
                                              lanes: e.lanes,
                                              firstContext: e.firstContext,
                                            })),
                                  (a = a.sibling);
                              return Si(ol, (1 & ol.current) | 2), t.child;
                            }
                            e = e.sibling;
                          }
                        null !== l.tail &&
                          Je() > Qu &&
                          ((t.flags |= 128),
                          (n = !0),
                          Xo(l, !1),
                          (t.lanes = 4194304));
                      }
                    else {
                      if (!n)
                        if (null !== (e = ul(u))) {
                          if (
                            ((t.flags |= 128),
                            (n = !0),
                            null !== (a = e.updateQueue) &&
                              ((t.updateQueue = a), (t.flags |= 4)),
                            Xo(l, !0),
                            null === l.tail &&
                              "hidden" === l.tailMode &&
                              !u.alternate &&
                              !ir)
                          )
                            return Go(t), null;
                        } else
                          2 * Je() - l.renderingStartTime > Qu &&
                            1073741824 !== a &&
                            ((t.flags |= 128),
                            (n = !0),
                            Xo(l, !1),
                            (t.lanes = 4194304));
                      l.isBackwards
                        ? ((u.sibling = t.child), (t.child = u))
                        : (null !== (a = l.last)
                            ? (a.sibling = u)
                            : (t.child = u),
                          (l.last = u));
                    }
                    return null !== l.tail
                      ? ((t = l.tail),
                        (l.rendering = t),
                        (l.tail = t.sibling),
                        (l.renderingStartTime = Je()),
                        (t.sibling = null),
                        (a = ol.current),
                        Si(ol, n ? (1 & a) | 2 : 1 & a),
                        t)
                      : (Go(t), null);
                  case 22:
                  case 23:
                    return (
                      ps(),
                      (n = null !== t.memoizedState),
                      null !== e &&
                        (null !== e.memoizedState) !== n &&
                        (t.flags |= 8192),
                      n && 0 !== (1 & t.mode)
                        ? 0 !== (1073741824 & Bu) &&
                          (Go(t), 6 & t.subtreeFlags && (t.flags |= 8192))
                        : Go(t),
                      null
                    );
                  case 24:
                  case 25:
                    return null;
                }
                throw Error(r(156, t.tag));
              }
              function Vo(e, t) {
                switch ((tr(t), t.tag)) {
                  case 1:
                    return (
                      ki(t.type) && Bi(),
                      65536 & (e = t.flags)
                        ? ((t.flags = (-65537 & e) | 128), t)
                        : null
                    );
                  case 3:
                    return (
                      il(),
                      Ni(Di),
                      Ni(wi),
                      cl(),
                      0 !== (65536 & (e = t.flags)) && 0 === (128 & e)
                        ? ((t.flags = (-65537 & e) | 128), t)
                        : null
                    );
                  case 5:
                    return ll(t), null;
                  case 13:
                    if (
                      (Ni(ol),
                      null !== (e = t.memoizedState) && null !== e.dehydrated)
                    ) {
                      if (null === t.alternate) throw Error(r(340));
                      mr();
                    }
                    return 65536 & (e = t.flags)
                      ? ((t.flags = (-65537 & e) | 128), t)
                      : null;
                  case 19:
                    return Ni(ol), null;
                  case 4:
                    return il(), null;
                  case 10:
                    return Ar(t.type._context), null;
                  case 22:
                  case 23:
                    return ps(), null;
                  default:
                    return null;
                }
              }
              (ko = function (e, t) {
                for (var a = t.child; null !== a; ) {
                  if (5 === a.tag || 6 === a.tag) e.appendChild(a.stateNode);
                  else if (4 !== a.tag && null !== a.child) {
                    (a.child.return = a), (a = a.child);
                    continue;
                  }
                  if (a === t) break;
                  for (; null === a.sibling; ) {
                    if (null === a.return || a.return === t) return;
                    a = a.return;
                  }
                  (a.sibling.return = a.return), (a = a.sibling);
                }
              }),
                (Bo = function () {}),
                (Oo = function (e, t, a, n) {
                  var i = e.memoizedProps;
                  if (i !== n) {
                    (e = t.stateNode), al(Zr.current);
                    var r,
                      l = null;
                    switch (a) {
                      case "input":
                        (i = V(e, i)), (n = V(e, n)), (l = []);
                        break;
                      case "select":
                        (i = L({}, i, { value: void 0 })),
                          (n = L({}, n, { value: void 0 })),
                          (l = []);
                        break;
                      case "textarea":
                        (i = ne(e, i)), (n = ne(e, n)), (l = []);
                        break;
                      default:
                        "function" !== typeof i.onClick &&
                          "function" === typeof n.onClick &&
                          (e.onclick = Zn);
                    }
                    for (c in (ve(a, n), (a = null), i))
                      if (
                        !n.hasOwnProperty(c) &&
                        i.hasOwnProperty(c) &&
                        null != i[c]
                      )
                        if ("style" === c) {
                          var u = i[c];
                          for (r in u)
                            u.hasOwnProperty(r) && (a || (a = {}), (a[r] = ""));
                        } else
                          "dangerouslySetInnerHTML" !== c &&
                            "children" !== c &&
                            "suppressContentEditableWarning" !== c &&
                            "suppressHydrationWarning" !== c &&
                            "autoFocus" !== c &&
                            (o.hasOwnProperty(c)
                              ? l || (l = [])
                              : (l = l || []).push(c, null));
                    for (c in n) {
                      var s = n[c];
                      if (
                        ((u = null != i ? i[c] : void 0),
                        n.hasOwnProperty(c) &&
                          s !== u &&
                          (null != s || null != u))
                      )
                        if ("style" === c)
                          if (u) {
                            for (r in u)
                              !u.hasOwnProperty(r) ||
                                (s && s.hasOwnProperty(r)) ||
                                (a || (a = {}), (a[r] = ""));
                            for (r in s)
                              s.hasOwnProperty(r) &&
                                u[r] !== s[r] &&
                                (a || (a = {}), (a[r] = s[r]));
                          } else a || (l || (l = []), l.push(c, a)), (a = s);
                        else
                          "dangerouslySetInnerHTML" === c
                            ? ((s = s ? s.__html : void 0),
                              (u = u ? u.__html : void 0),
                              null != s && u !== s && (l = l || []).push(c, s))
                            : "children" === c
                            ? ("string" !== typeof s &&
                                "number" !== typeof s) ||
                              (l = l || []).push(c, "" + s)
                            : "suppressContentEditableWarning" !== c &&
                              "suppressHydrationWarning" !== c &&
                              (o.hasOwnProperty(c)
                                ? (null != s &&
                                    "onScroll" === c &&
                                    qn("scroll", e),
                                  l || u === s || (l = []))
                                : (l = l || []).push(c, s));
                    }
                    a && (l = l || []).push("style", a);
                    var c = l;
                    (t.updateQueue = c) && (t.flags |= 4);
                  }
                }),
                (Po = function (e, t, a, n) {
                  a !== n && (t.flags |= 4);
                });
              var $o = !1,
                Jo = !1,
                Ko = "function" === typeof WeakSet ? WeakSet : Set,
                Zo = null;
              function eu(e, t) {
                var a = e.ref;
                if (null !== a)
                  if ("function" === typeof a)
                    try {
                      a(null);
                    } catch (n) {
                      Ns(e, t, n);
                    }
                  else a.current = null;
              }
              function tu(e, t, a) {
                try {
                  a();
                } catch (n) {
                  Ns(e, t, n);
                }
              }
              var au = !1;
              function nu(e, t, a) {
                var n = t.updateQueue;
                if (null !== (n = null !== n ? n.lastEffect : null)) {
                  var i = (n = n.next);
                  do {
                    if ((i.tag & e) === e) {
                      var r = i.destroy;
                      (i.destroy = void 0), void 0 !== r && tu(t, a, r);
                    }
                    i = i.next;
                  } while (i !== n);
                }
              }
              function iu(e, t) {
                if (
                  null !==
                  (t = null !== (t = t.updateQueue) ? t.lastEffect : null)
                ) {
                  var a = (t = t.next);
                  do {
                    if ((a.tag & e) === e) {
                      var n = a.create;
                      a.destroy = n();
                    }
                    a = a.next;
                  } while (a !== t);
                }
              }
              function ru(e) {
                var t = e.ref;
                if (null !== t) {
                  var a = e.stateNode;
                  e.tag,
                    (e = a),
                    "function" === typeof t ? t(e) : (t.current = e);
                }
              }
              function lu(e) {
                var t = e.alternate;
                null !== t && ((e.alternate = null), lu(t)),
                  (e.child = null),
                  (e.deletions = null),
                  (e.sibling = null),
                  5 === e.tag &&
                    null !== (t = e.stateNode) &&
                    (delete t[pi],
                    delete t[mi],
                    delete t[gi],
                    delete t[hi],
                    delete t[bi]),
                  (e.stateNode = null),
                  (e.return = null),
                  (e.dependencies = null),
                  (e.memoizedProps = null),
                  (e.memoizedState = null),
                  (e.pendingProps = null),
                  (e.stateNode = null),
                  (e.updateQueue = null);
              }
              function ou(e) {
                return 5 === e.tag || 3 === e.tag || 4 === e.tag;
              }
              function uu(e) {
                e: for (;;) {
                  for (; null === e.sibling; ) {
                    if (null === e.return || ou(e.return)) return null;
                    e = e.return;
                  }
                  for (
                    e.sibling.return = e.return, e = e.sibling;
                    5 !== e.tag && 6 !== e.tag && 18 !== e.tag;

                  ) {
                    if (2 & e.flags) continue e;
                    if (null === e.child || 4 === e.tag) continue e;
                    (e.child.return = e), (e = e.child);
                  }
                  if (!(2 & e.flags)) return e.stateNode;
                }
              }
              function su(e, t, a) {
                var n = e.tag;
                if (5 === n || 6 === n)
                  (e = e.stateNode),
                    t
                      ? 8 === a.nodeType
                        ? a.parentNode.insertBefore(e, t)
                        : a.insertBefore(e, t)
                      : (8 === a.nodeType
                          ? (t = a.parentNode).insertBefore(e, a)
                          : (t = a).appendChild(e),
                        (null !== (a = a._reactRootContainer) &&
                          void 0 !== a) ||
                          null !== t.onclick ||
                          (t.onclick = Zn));
                else if (4 !== n && null !== (e = e.child))
                  for (su(e, t, a), e = e.sibling; null !== e; )
                    su(e, t, a), (e = e.sibling);
              }
              function cu(e, t, a) {
                var n = e.tag;
                if (5 === n || 6 === n)
                  (e = e.stateNode),
                    t ? a.insertBefore(e, t) : a.appendChild(e);
                else if (4 !== n && null !== (e = e.child))
                  for (cu(e, t, a), e = e.sibling; null !== e; )
                    cu(e, t, a), (e = e.sibling);
              }
              var du = null,
                pu = !1;
              function mu(e, t, a) {
                for (a = a.child; null !== a; ) fu(e, t, a), (a = a.sibling);
              }
              function fu(e, t, a) {
                if (rt && "function" === typeof rt.onCommitFiberUnmount)
                  try {
                    rt.onCommitFiberUnmount(it, a);
                  } catch (o) {}
                switch (a.tag) {
                  case 5:
                    Jo || eu(a, t);
                  case 6:
                    var n = du,
                      i = pu;
                    (du = null),
                      mu(e, t, a),
                      (pu = i),
                      null !== (du = n) &&
                        (pu
                          ? ((e = du),
                            (a = a.stateNode),
                            8 === e.nodeType
                              ? e.parentNode.removeChild(a)
                              : e.removeChild(a))
                          : du.removeChild(a.stateNode));
                    break;
                  case 18:
                    null !== du &&
                      (pu
                        ? ((e = du),
                          (a = a.stateNode),
                          8 === e.nodeType
                            ? ui(e.parentNode, a)
                            : 1 === e.nodeType && ui(e, a),
                          Ut(e))
                        : ui(du, a.stateNode));
                    break;
                  case 4:
                    (n = du),
                      (i = pu),
                      (du = a.stateNode.containerInfo),
                      (pu = !0),
                      mu(e, t, a),
                      (du = n),
                      (pu = i);
                    break;
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    if (
                      !Jo &&
                      null !== (n = a.updateQueue) &&
                      null !== (n = n.lastEffect)
                    ) {
                      i = n = n.next;
                      do {
                        var r = i,
                          l = r.destroy;
                        (r = r.tag),
                          void 0 !== l &&
                            (0 !== (2 & r) || 0 !== (4 & r)) &&
                            tu(a, t, l),
                          (i = i.next);
                      } while (i !== n);
                    }
                    mu(e, t, a);
                    break;
                  case 1:
                    if (
                      !Jo &&
                      (eu(a, t),
                      "function" ===
                        typeof (n = a.stateNode).componentWillUnmount)
                    )
                      try {
                        (n.props = a.memoizedProps),
                          (n.state = a.memoizedState),
                          n.componentWillUnmount();
                      } catch (o) {
                        Ns(a, t, o);
                      }
                    mu(e, t, a);
                    break;
                  case 21:
                    mu(e, t, a);
                    break;
                  case 22:
                    1 & a.mode
                      ? ((Jo = (n = Jo) || null !== a.memoizedState),
                        mu(e, t, a),
                        (Jo = n))
                      : mu(e, t, a);
                    break;
                  default:
                    mu(e, t, a);
                }
              }
              function gu(e) {
                var t = e.updateQueue;
                if (null !== t) {
                  e.updateQueue = null;
                  var a = e.stateNode;
                  null === a && (a = e.stateNode = new Ko()),
                    t.forEach(function (t) {
                      var n = Ds.bind(null, e, t);
                      a.has(t) || (a.add(t), t.then(n, n));
                    });
                }
              }
              function hu(e, t) {
                var a = t.deletions;
                if (null !== a)
                  for (var n = 0; n < a.length; n++) {
                    var i = a[n];
                    try {
                      var l = e,
                        o = t,
                        u = o;
                      e: for (; null !== u; ) {
                        switch (u.tag) {
                          case 5:
                            (du = u.stateNode), (pu = !1);
                            break e;
                          case 3:
                          case 4:
                            (du = u.stateNode.containerInfo), (pu = !0);
                            break e;
                        }
                        u = u.return;
                      }
                      if (null === du) throw Error(r(160));
                      fu(l, o, i), (du = null), (pu = !1);
                      var s = i.alternate;
                      null !== s && (s.return = null), (i.return = null);
                    } catch (c) {
                      Ns(i, t, c);
                    }
                  }
                if (12854 & t.subtreeFlags)
                  for (t = t.child; null !== t; ) bu(t, e), (t = t.sibling);
              }
              function bu(e, t) {
                var a = e.alternate,
                  n = e.flags;
                switch (e.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    if ((hu(t, e), vu(e), 4 & n)) {
                      try {
                        nu(3, e, e.return), iu(3, e);
                      } catch (h) {
                        Ns(e, e.return, h);
                      }
                      try {
                        nu(5, e, e.return);
                      } catch (h) {
                        Ns(e, e.return, h);
                      }
                    }
                    break;
                  case 1:
                    hu(t, e), vu(e), 512 & n && null !== a && eu(a, a.return);
                    break;
                  case 5:
                    if (
                      (hu(t, e),
                      vu(e),
                      512 & n && null !== a && eu(a, a.return),
                      32 & e.flags)
                    ) {
                      var i = e.stateNode;
                      try {
                        pe(i, "");
                      } catch (h) {
                        Ns(e, e.return, h);
                      }
                    }
                    if (4 & n && null != (i = e.stateNode)) {
                      var l = e.memoizedProps,
                        o = null !== a ? a.memoizedProps : l,
                        u = e.type,
                        s = e.updateQueue;
                      if (((e.updateQueue = null), null !== s))
                        try {
                          "input" === u &&
                            "radio" === l.type &&
                            null != l.name &&
                            J(i, l),
                            xe(u, o);
                          var c = xe(u, l);
                          for (o = 0; o < s.length; o += 2) {
                            var d = s[o],
                              p = s[o + 1];
                            "style" === d
                              ? he(i, p)
                              : "dangerouslySetInnerHTML" === d
                              ? de(i, p)
                              : "children" === d
                              ? pe(i, p)
                              : x(i, d, p, c);
                          }
                          switch (u) {
                            case "input":
                              K(i, l);
                              break;
                            case "textarea":
                              re(i, l);
                              break;
                            case "select":
                              var m = i._wrapperState.wasMultiple;
                              i._wrapperState.wasMultiple = !!l.multiple;
                              var f = l.value;
                              null != f
                                ? ae(i, !!l.multiple, f, !1)
                                : m !== !!l.multiple &&
                                  (null != l.defaultValue
                                    ? ae(i, !!l.multiple, l.defaultValue, !0)
                                    : ae(
                                        i,
                                        !!l.multiple,
                                        l.multiple ? [] : "",
                                        !1
                                      ));
                          }
                          i[mi] = l;
                        } catch (h) {
                          Ns(e, e.return, h);
                        }
                    }
                    break;
                  case 6:
                    if ((hu(t, e), vu(e), 4 & n)) {
                      if (null === e.stateNode) throw Error(r(162));
                      (i = e.stateNode), (l = e.memoizedProps);
                      try {
                        i.nodeValue = l;
                      } catch (h) {
                        Ns(e, e.return, h);
                      }
                    }
                    break;
                  case 3:
                    if (
                      (hu(t, e),
                      vu(e),
                      4 & n && null !== a && a.memoizedState.isDehydrated)
                    )
                      try {
                        Ut(t.containerInfo);
                      } catch (h) {
                        Ns(e, e.return, h);
                      }
                    break;
                  case 4:
                  default:
                    hu(t, e), vu(e);
                    break;
                  case 13:
                    hu(t, e),
                      vu(e),
                      8192 & (i = e.child).flags &&
                        ((l = null !== i.memoizedState),
                        (i.stateNode.isHidden = l),
                        !l ||
                          (null !== i.alternate &&
                            null !== i.alternate.memoizedState) ||
                          (Uu = Je())),
                      4 & n && gu(e);
                    break;
                  case 22:
                    if (
                      ((d = null !== a && null !== a.memoizedState),
                      1 & e.mode
                        ? ((Jo = (c = Jo) || d), hu(t, e), (Jo = c))
                        : hu(t, e),
                      vu(e),
                      8192 & n)
                    ) {
                      if (
                        ((c = null !== e.memoizedState),
                        (e.stateNode.isHidden = c) && !d && 0 !== (1 & e.mode))
                      )
                        for (Zo = e, d = e.child; null !== d; ) {
                          for (p = Zo = d; null !== Zo; ) {
                            switch (((f = (m = Zo).child), m.tag)) {
                              case 0:
                              case 11:
                              case 14:
                              case 15:
                                nu(4, m, m.return);
                                break;
                              case 1:
                                eu(m, m.return);
                                var g = m.stateNode;
                                if (
                                  "function" === typeof g.componentWillUnmount
                                ) {
                                  (n = m), (a = m.return);
                                  try {
                                    (t = n),
                                      (g.props = t.memoizedProps),
                                      (g.state = t.memoizedState),
                                      g.componentWillUnmount();
                                  } catch (h) {
                                    Ns(n, a, h);
                                  }
                                }
                                break;
                              case 5:
                                eu(m, m.return);
                                break;
                              case 22:
                                if (null !== m.memoizedState) {
                                  Au(p);
                                  continue;
                                }
                            }
                            null !== f ? ((f.return = m), (Zo = f)) : Au(p);
                          }
                          d = d.sibling;
                        }
                      e: for (d = null, p = e; ; ) {
                        if (5 === p.tag) {
                          if (null === d) {
                            d = p;
                            try {
                              (i = p.stateNode),
                                c
                                  ? "function" ===
                                    typeof (l = i.style).setProperty
                                    ? l.setProperty(
                                        "display",
                                        "none",
                                        "important"
                                      )
                                    : (l.display = "none")
                                  : ((u = p.stateNode),
                                    (o =
                                      void 0 !== (s = p.memoizedProps.style) &&
                                      null !== s &&
                                      s.hasOwnProperty("display")
                                        ? s.display
                                        : null),
                                    (u.style.display = ge("display", o)));
                            } catch (h) {
                              Ns(e, e.return, h);
                            }
                          }
                        } else if (6 === p.tag) {
                          if (null === d)
                            try {
                              p.stateNode.nodeValue = c ? "" : p.memoizedProps;
                            } catch (h) {
                              Ns(e, e.return, h);
                            }
                        } else if (
                          ((22 !== p.tag && 23 !== p.tag) ||
                            null === p.memoizedState ||
                            p === e) &&
                          null !== p.child
                        ) {
                          (p.child.return = p), (p = p.child);
                          continue;
                        }
                        if (p === e) break e;
                        for (; null === p.sibling; ) {
                          if (null === p.return || p.return === e) break e;
                          d === p && (d = null), (p = p.return);
                        }
                        d === p && (d = null),
                          (p.sibling.return = p.return),
                          (p = p.sibling);
                      }
                    }
                    break;
                  case 19:
                    hu(t, e), vu(e), 4 & n && gu(e);
                  case 21:
                }
              }
              function vu(e) {
                var t = e.flags;
                if (2 & t) {
                  try {
                    e: {
                      for (var a = e.return; null !== a; ) {
                        if (ou(a)) {
                          var n = a;
                          break e;
                        }
                        a = a.return;
                      }
                      throw Error(r(160));
                    }
                    switch (n.tag) {
                      case 5:
                        var i = n.stateNode;
                        32 & n.flags && (pe(i, ""), (n.flags &= -33)),
                          cu(e, uu(e), i);
                        break;
                      case 3:
                      case 4:
                        var l = n.stateNode.containerInfo;
                        su(e, uu(e), l);
                        break;
                      default:
                        throw Error(r(161));
                    }
                  } catch (o) {
                    Ns(e, e.return, o);
                  }
                  e.flags &= -3;
                }
                4096 & t && (e.flags &= -4097);
              }
              function xu(e, t, a) {
                (Zo = e), zu(e, t, a);
              }
              function zu(e, t, a) {
                for (var n = 0 !== (1 & e.mode); null !== Zo; ) {
                  var i = Zo,
                    r = i.child;
                  if (22 === i.tag && n) {
                    var l = null !== i.memoizedState || $o;
                    if (!l) {
                      var o = i.alternate,
                        u = (null !== o && null !== o.memoizedState) || Jo;
                      o = $o;
                      var s = Jo;
                      if ((($o = l), (Jo = u) && !s))
                        for (Zo = i; null !== Zo; )
                          (u = (l = Zo).child),
                            22 === l.tag && null !== l.memoizedState
                              ? Eu(i)
                              : null !== u
                              ? ((u.return = l), (Zo = u))
                              : Eu(i);
                      for (; null !== r; )
                        (Zo = r), zu(r, t, a), (r = r.sibling);
                      (Zo = i), ($o = o), (Jo = s);
                    }
                    yu(e);
                  } else
                    0 !== (8772 & i.subtreeFlags) && null !== r
                      ? ((r.return = i), (Zo = r))
                      : yu(e);
                }
              }
              function yu(e) {
                for (; null !== Zo; ) {
                  var t = Zo;
                  if (0 !== (8772 & t.flags)) {
                    var a = t.alternate;
                    try {
                      if (0 !== (8772 & t.flags))
                        switch (t.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Jo || iu(5, t);
                            break;
                          case 1:
                            var n = t.stateNode;
                            if (4 & t.flags && !Jo)
                              if (null === a) n.componentDidMount();
                              else {
                                var i =
                                  t.elementType === t.type
                                    ? a.memoizedProps
                                    : hr(t.type, a.memoizedProps);
                                n.componentDidUpdate(
                                  i,
                                  a.memoizedState,
                                  n.__reactInternalSnapshotBeforeUpdate
                                );
                              }
                            var l = t.updateQueue;
                            null !== l && Tr(t, l, n);
                            break;
                          case 3:
                            var o = t.updateQueue;
                            if (null !== o) {
                              if (((a = null), null !== t.child))
                                switch (t.child.tag) {
                                  case 5:
                                  case 1:
                                    a = t.child.stateNode;
                                }
                              Tr(t, o, a);
                            }
                            break;
                          case 5:
                            var u = t.stateNode;
                            if (null === a && 4 & t.flags) {
                              a = u;
                              var s = t.memoizedProps;
                              switch (t.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                  s.autoFocus && a.focus();
                                  break;
                                case "img":
                                  s.src && (a.src = s.src);
                              }
                            }
                            break;
                          case 6:
                          case 4:
                          case 12:
                          case 19:
                          case 17:
                          case 21:
                          case 22:
                          case 23:
                          case 25:
                            break;
                          case 13:
                            if (null === t.memoizedState) {
                              var c = t.alternate;
                              if (null !== c) {
                                var d = c.memoizedState;
                                if (null !== d) {
                                  var p = d.dehydrated;
                                  null !== p && Ut(p);
                                }
                              }
                            }
                            break;
                          default:
                            throw Error(r(163));
                        }
                      Jo || (512 & t.flags && ru(t));
                    } catch (m) {
                      Ns(t, t.return, m);
                    }
                  }
                  if (t === e) {
                    Zo = null;
                    break;
                  }
                  if (null !== (a = t.sibling)) {
                    (a.return = t.return), (Zo = a);
                    break;
                  }
                  Zo = t.return;
                }
              }
              function Au(e) {
                for (; null !== Zo; ) {
                  var t = Zo;
                  if (t === e) {
                    Zo = null;
                    break;
                  }
                  var a = t.sibling;
                  if (null !== a) {
                    (a.return = t.return), (Zo = a);
                    break;
                  }
                  Zo = t.return;
                }
              }
              function Eu(e) {
                for (; null !== Zo; ) {
                  var t = Zo;
                  try {
                    switch (t.tag) {
                      case 0:
                      case 11:
                      case 15:
                        var a = t.return;
                        try {
                          iu(4, t);
                        } catch (u) {
                          Ns(t, a, u);
                        }
                        break;
                      case 1:
                        var n = t.stateNode;
                        if ("function" === typeof n.componentDidMount) {
                          var i = t.return;
                          try {
                            n.componentDidMount();
                          } catch (u) {
                            Ns(t, i, u);
                          }
                        }
                        var r = t.return;
                        try {
                          ru(t);
                        } catch (u) {
                          Ns(t, r, u);
                        }
                        break;
                      case 5:
                        var l = t.return;
                        try {
                          ru(t);
                        } catch (u) {
                          Ns(t, l, u);
                        }
                    }
                  } catch (u) {
                    Ns(t, t.return, u);
                  }
                  if (t === e) {
                    Zo = null;
                    break;
                  }
                  var o = t.sibling;
                  if (null !== o) {
                    (o.return = t.return), (Zo = o);
                    break;
                  }
                  Zo = t.return;
                }
              }
              var Cu,
                Nu = Math.ceil,
                Su = z.ReactCurrentDispatcher,
                Ru = z.ReactCurrentOwner,
                wu = z.ReactCurrentBatchConfig,
                Du = 0,
                Fu = null,
                _u = null,
                ku = 0,
                Bu = 0,
                Ou = Ci(0),
                Pu = 0,
                Iu = null,
                Lu = 0,
                Tu = 0,
                qu = 0,
                Mu = null,
                ju = null,
                Uu = 0,
                Qu = 1 / 0,
                Yu = null,
                Hu = !1,
                Xu = null,
                Gu = null,
                Wu = !1,
                Vu = null,
                $u = 0,
                Ju = 0,
                Ku = null,
                Zu = -1,
                es = 0;
              function ts() {
                return 0 !== (6 & Du) ? Je() : -1 !== Zu ? Zu : (Zu = Je());
              }
              function as(e) {
                return 0 === (1 & e.mode)
                  ? 1
                  : 0 !== (2 & Du) && 0 !== ku
                  ? ku & -ku
                  : null !== gr.transition
                  ? (0 === es && (es = gt()), es)
                  : 0 !== (e = xt)
                  ? e
                  : (e = void 0 === (e = window.event) ? 16 : $t(e.type));
              }
              function ns(e, t, a, n) {
                if (50 < Ju) throw ((Ju = 0), (Ku = null), Error(r(185)));
                bt(e, a, n),
                  (0 !== (2 & Du) && e === Fu) ||
                    (e === Fu &&
                      (0 === (2 & Du) && (Tu |= a), 4 === Pu && us(e, ku)),
                    is(e, n),
                    1 === a &&
                      0 === Du &&
                      0 === (1 & t.mode) &&
                      ((Qu = Je() + 500), qi && Ui()));
              }
              function is(e, t) {
                var a = e.callbackNode;
                !(function (e, t) {
                  for (
                    var a = e.suspendedLanes,
                      n = e.pingedLanes,
                      i = e.expirationTimes,
                      r = e.pendingLanes;
                    0 < r;

                  ) {
                    var l = 31 - lt(r),
                      o = 1 << l,
                      u = i[l];
                    -1 === u
                      ? (0 !== (o & a) && 0 === (o & n)) || (i[l] = mt(o, t))
                      : u <= t && (e.expiredLanes |= o),
                      (r &= ~o);
                  }
                })(e, t);
                var n = pt(e, e === Fu ? ku : 0);
                if (0 === n)
                  null !== a && We(a),
                    (e.callbackNode = null),
                    (e.callbackPriority = 0);
                else if (((t = n & -n), e.callbackPriority !== t)) {
                  if ((null != a && We(a), 1 === t))
                    0 === e.tag
                      ? (function (e) {
                          (qi = !0), ji(e);
                        })(ss.bind(null, e))
                      : ji(ss.bind(null, e)),
                      li(function () {
                        0 === (6 & Du) && Ui();
                      }),
                      (a = null);
                  else {
                    switch (zt(n)) {
                      case 1:
                        a = Ze;
                        break;
                      case 4:
                        a = et;
                        break;
                      case 16:
                      default:
                        a = tt;
                        break;
                      case 536870912:
                        a = nt;
                    }
                    a = Fs(a, rs.bind(null, e));
                  }
                  (e.callbackPriority = t), (e.callbackNode = a);
                }
              }
              function rs(e, t) {
                if (((Zu = -1), (es = 0), 0 !== (6 & Du))) throw Error(r(327));
                var a = e.callbackNode;
                if (Es() && e.callbackNode !== a) return null;
                var n = pt(e, e === Fu ? ku : 0);
                if (0 === n) return null;
                if (0 !== (30 & n) || 0 !== (n & e.expiredLanes) || t)
                  t = bs(e, n);
                else {
                  t = n;
                  var i = Du;
                  Du |= 2;
                  var l = gs();
                  for (
                    (Fu === e && ku === t) ||
                    ((Yu = null), (Qu = Je() + 500), ms(e, t));
                    ;

                  )
                    try {
                      xs();
                      break;
                    } catch (u) {
                      fs(e, u);
                    }
                  yr(),
                    (Su.current = l),
                    (Du = i),
                    null !== _u ? (t = 0) : ((Fu = null), (ku = 0), (t = Pu));
                }
                if (0 !== t) {
                  if (
                    (2 === t && 0 !== (i = ft(e)) && ((n = i), (t = ls(e, i))),
                    1 === t)
                  )
                    throw ((a = Iu), ms(e, 0), us(e, n), is(e, Je()), a);
                  if (6 === t) us(e, n);
                  else {
                    if (
                      ((i = e.current.alternate),
                      0 === (30 & n) &&
                        !(function (e) {
                          for (var t = e; ; ) {
                            if (16384 & t.flags) {
                              var a = t.updateQueue;
                              if (null !== a && null !== (a = a.stores))
                                for (var n = 0; n < a.length; n++) {
                                  var i = a[n],
                                    r = i.getSnapshot;
                                  i = i.value;
                                  try {
                                    if (!on(r(), i)) return !1;
                                  } catch (o) {
                                    return !1;
                                  }
                                }
                            }
                            if (
                              ((a = t.child),
                              16384 & t.subtreeFlags && null !== a)
                            )
                              (a.return = t), (t = a);
                            else {
                              if (t === e) break;
                              for (; null === t.sibling; ) {
                                if (null === t.return || t.return === e)
                                  return !0;
                                t = t.return;
                              }
                              (t.sibling.return = t.return), (t = t.sibling);
                            }
                          }
                          return !0;
                        })(i) &&
                        (2 === (t = bs(e, n)) &&
                          0 !== (l = ft(e)) &&
                          ((n = l), (t = ls(e, l))),
                        1 === t))
                    )
                      throw ((a = Iu), ms(e, 0), us(e, n), is(e, Je()), a);
                    switch (((e.finishedWork = i), (e.finishedLanes = n), t)) {
                      case 0:
                      case 1:
                        throw Error(r(345));
                      case 2:
                      case 5:
                        As(e, ju, Yu);
                        break;
                      case 3:
                        if (
                          (us(e, n),
                          (130023424 & n) === n && 10 < (t = Uu + 500 - Je()))
                        ) {
                          if (0 !== pt(e, 0)) break;
                          if (((i = e.suspendedLanes) & n) !== n) {
                            ts(), (e.pingedLanes |= e.suspendedLanes & i);
                            break;
                          }
                          e.timeoutHandle = ni(As.bind(null, e, ju, Yu), t);
                          break;
                        }
                        As(e, ju, Yu);
                        break;
                      case 4:
                        if ((us(e, n), (4194240 & n) === n)) break;
                        for (t = e.eventTimes, i = -1; 0 < n; ) {
                          var o = 31 - lt(n);
                          (l = 1 << o), (o = t[o]) > i && (i = o), (n &= ~l);
                        }
                        if (
                          ((n = i),
                          10 <
                            (n =
                              (120 > (n = Je() - n)
                                ? 120
                                : 480 > n
                                ? 480
                                : 1080 > n
                                ? 1080
                                : 1920 > n
                                ? 1920
                                : 3e3 > n
                                ? 3e3
                                : 4320 > n
                                ? 4320
                                : 1960 * Nu(n / 1960)) - n))
                        ) {
                          e.timeoutHandle = ni(As.bind(null, e, ju, Yu), n);
                          break;
                        }
                        As(e, ju, Yu);
                        break;
                      default:
                        throw Error(r(329));
                    }
                  }
                }
                return (
                  is(e, Je()), e.callbackNode === a ? rs.bind(null, e) : null
                );
              }
              function ls(e, t) {
                var a = Mu;
                return (
                  e.current.memoizedState.isDehydrated &&
                    (ms(e, t).flags |= 256),
                  2 !== (e = bs(e, t)) &&
                    ((t = ju), (ju = a), null !== t && os(t)),
                  e
                );
              }
              function os(e) {
                null === ju ? (ju = e) : ju.push.apply(ju, e);
              }
              function us(e, t) {
                for (
                  t &= ~qu,
                    t &= ~Tu,
                    e.suspendedLanes |= t,
                    e.pingedLanes &= ~t,
                    e = e.expirationTimes;
                  0 < t;

                ) {
                  var a = 31 - lt(t),
                    n = 1 << a;
                  (e[a] = -1), (t &= ~n);
                }
              }
              function ss(e) {
                if (0 !== (6 & Du)) throw Error(r(327));
                Es();
                var t = pt(e, 0);
                if (0 === (1 & t)) return is(e, Je()), null;
                var a = bs(e, t);
                if (0 !== e.tag && 2 === a) {
                  var n = ft(e);
                  0 !== n && ((t = n), (a = ls(e, n)));
                }
                if (1 === a)
                  throw ((a = Iu), ms(e, 0), us(e, t), is(e, Je()), a);
                if (6 === a) throw Error(r(345));
                return (
                  (e.finishedWork = e.current.alternate),
                  (e.finishedLanes = t),
                  As(e, ju, Yu),
                  is(e, Je()),
                  null
                );
              }
              function cs(e, t) {
                var a = Du;
                Du |= 1;
                try {
                  return e(t);
                } finally {
                  0 === (Du = a) && ((Qu = Je() + 500), qi && Ui());
                }
              }
              function ds(e) {
                null !== Vu && 0 === Vu.tag && 0 === (6 & Du) && Es();
                var t = Du;
                Du |= 1;
                var a = wu.transition,
                  n = xt;
                try {
                  if (((wu.transition = null), (xt = 1), e)) return e();
                } finally {
                  (xt = n), (wu.transition = a), 0 === (6 & (Du = t)) && Ui();
                }
              }
              function ps() {
                (Bu = Ou.current), Ni(Ou);
              }
              function ms(e, t) {
                (e.finishedWork = null), (e.finishedLanes = 0);
                var a = e.timeoutHandle;
                if ((-1 !== a && ((e.timeoutHandle = -1), ii(a)), null !== _u))
                  for (a = _u.return; null !== a; ) {
                    var n = a;
                    switch ((tr(n), n.tag)) {
                      case 1:
                        null !== (n = n.type.childContextTypes) &&
                          void 0 !== n &&
                          Bi();
                        break;
                      case 3:
                        il(), Ni(Di), Ni(wi), cl();
                        break;
                      case 5:
                        ll(n);
                        break;
                      case 4:
                        il();
                        break;
                      case 13:
                      case 19:
                        Ni(ol);
                        break;
                      case 10:
                        Ar(n.type._context);
                        break;
                      case 22:
                      case 23:
                        ps();
                    }
                    a = a.return;
                  }
                if (
                  ((Fu = e),
                  (_u = e = Os(e.current, null)),
                  (ku = Bu = t),
                  (Pu = 0),
                  (Iu = null),
                  (qu = Tu = Lu = 0),
                  (ju = Mu = null),
                  null !== Sr)
                ) {
                  for (t = 0; t < Sr.length; t++)
                    if (null !== (n = (a = Sr[t]).interleaved)) {
                      a.interleaved = null;
                      var i = n.next,
                        r = a.pending;
                      if (null !== r) {
                        var l = r.next;
                        (r.next = i), (n.next = l);
                      }
                      a.pending = n;
                    }
                  Sr = null;
                }
                return e;
              }
              function fs(e, t) {
                for (;;) {
                  var a = _u;
                  try {
                    if ((yr(), (dl.current = ro), bl)) {
                      for (var n = fl.memoizedState; null !== n; ) {
                        var i = n.queue;
                        null !== i && (i.pending = null), (n = n.next);
                      }
                      bl = !1;
                    }
                    if (
                      ((ml = 0),
                      (hl = gl = fl = null),
                      (vl = !1),
                      (xl = 0),
                      (Ru.current = null),
                      null === a || null === a.return)
                    ) {
                      (Pu = 1), (Iu = t), (_u = null);
                      break;
                    }
                    e: {
                      var l = e,
                        o = a.return,
                        u = a,
                        s = t;
                      if (
                        ((t = ku),
                        (u.flags |= 32768),
                        null !== s &&
                          "object" === typeof s &&
                          "function" === typeof s.then)
                      ) {
                        var c = s,
                          d = u,
                          p = d.tag;
                        if (
                          0 === (1 & d.mode) &&
                          (0 === p || 11 === p || 15 === p)
                        ) {
                          var m = d.alternate;
                          m
                            ? ((d.updateQueue = m.updateQueue),
                              (d.memoizedState = m.memoizedState),
                              (d.lanes = m.lanes))
                            : ((d.updateQueue = null),
                              (d.memoizedState = null));
                        }
                        var f = bo(o);
                        if (null !== f) {
                          (f.flags &= -257),
                            vo(f, o, u, 0, t),
                            1 & f.mode && ho(l, c, t),
                            (s = c);
                          var g = (t = f).updateQueue;
                          if (null === g) {
                            var h = new Set();
                            h.add(s), (t.updateQueue = h);
                          } else g.add(s);
                          break e;
                        }
                        if (0 === (1 & t)) {
                          ho(l, c, t), hs();
                          break e;
                        }
                        s = Error(r(426));
                      } else if (ir && 1 & u.mode) {
                        var b = bo(o);
                        if (null !== b) {
                          0 === (65536 & b.flags) && (b.flags |= 256),
                            vo(b, o, u, 0, t),
                            fr(so(s, u));
                          break e;
                        }
                      }
                      (l = s = so(s, u)),
                        4 !== Pu && (Pu = 2),
                        null === Mu ? (Mu = [l]) : Mu.push(l),
                        (l = o);
                      do {
                        switch (l.tag) {
                          case 3:
                            (l.flags |= 65536),
                              (t &= -t),
                              (l.lanes |= t),
                              Ir(l, fo(0, s, t));
                            break e;
                          case 1:
                            u = s;
                            var v = l.type,
                              x = l.stateNode;
                            if (
                              0 === (128 & l.flags) &&
                              ("function" ===
                                typeof v.getDerivedStateFromError ||
                                (null !== x &&
                                  "function" === typeof x.componentDidCatch &&
                                  (null === Gu || !Gu.has(x))))
                            ) {
                              (l.flags |= 65536),
                                (t &= -t),
                                (l.lanes |= t),
                                Ir(l, go(l, u, t));
                              break e;
                            }
                        }
                        l = l.return;
                      } while (null !== l);
                    }
                    ys(a);
                  } catch (z) {
                    (t = z), _u === a && null !== a && (_u = a = a.return);
                    continue;
                  }
                  break;
                }
              }
              function gs() {
                var e = Su.current;
                return (Su.current = ro), null === e ? ro : e;
              }
              function hs() {
                (0 !== Pu && 3 !== Pu && 2 !== Pu) || (Pu = 4),
                  null === Fu ||
                    (0 === (268435455 & Lu) && 0 === (268435455 & Tu)) ||
                    us(Fu, ku);
              }
              function bs(e, t) {
                var a = Du;
                Du |= 2;
                var n = gs();
                for ((Fu === e && ku === t) || ((Yu = null), ms(e, t)); ; )
                  try {
                    vs();
                    break;
                  } catch (i) {
                    fs(e, i);
                  }
                if ((yr(), (Du = a), (Su.current = n), null !== _u))
                  throw Error(r(261));
                return (Fu = null), (ku = 0), Pu;
              }
              function vs() {
                for (; null !== _u; ) zs(_u);
              }
              function xs() {
                for (; null !== _u && !Ve(); ) zs(_u);
              }
              function zs(e) {
                var t = Cu(e.alternate, e, Bu);
                (e.memoizedProps = e.pendingProps),
                  null === t ? ys(e) : (_u = t),
                  (Ru.current = null);
              }
              function ys(e) {
                var t = e;
                do {
                  var a = t.alternate;
                  if (((e = t.return), 0 === (32768 & t.flags))) {
                    if (null !== (a = Wo(a, t, Bu))) return void (_u = a);
                  } else {
                    if (null !== (a = Vo(a, t)))
                      return (a.flags &= 32767), void (_u = a);
                    if (null === e) return (Pu = 6), void (_u = null);
                    (e.flags |= 32768),
                      (e.subtreeFlags = 0),
                      (e.deletions = null);
                  }
                  if (null !== (t = t.sibling)) return void (_u = t);
                  _u = t = e;
                } while (null !== t);
                0 === Pu && (Pu = 5);
              }
              function As(e, t, a) {
                var n = xt,
                  i = wu.transition;
                try {
                  (wu.transition = null),
                    (xt = 1),
                    (function (e, t, a, n) {
                      do {
                        Es();
                      } while (null !== Vu);
                      if (0 !== (6 & Du)) throw Error(r(327));
                      a = e.finishedWork;
                      var i = e.finishedLanes;
                      if (null === a) return null;
                      if (
                        ((e.finishedWork = null),
                        (e.finishedLanes = 0),
                        a === e.current)
                      )
                        throw Error(r(177));
                      (e.callbackNode = null), (e.callbackPriority = 0);
                      var l = a.lanes | a.childLanes;
                      if (
                        ((function (e, t) {
                          var a = e.pendingLanes & ~t;
                          (e.pendingLanes = t),
                            (e.suspendedLanes = 0),
                            (e.pingedLanes = 0),
                            (e.expiredLanes &= t),
                            (e.mutableReadLanes &= t),
                            (e.entangledLanes &= t),
                            (t = e.entanglements);
                          var n = e.eventTimes;
                          for (e = e.expirationTimes; 0 < a; ) {
                            var i = 31 - lt(a),
                              r = 1 << i;
                            (t[i] = 0), (n[i] = -1), (e[i] = -1), (a &= ~r);
                          }
                        })(e, l),
                        e === Fu && ((_u = Fu = null), (ku = 0)),
                        (0 === (2064 & a.subtreeFlags) &&
                          0 === (2064 & a.flags)) ||
                          Wu ||
                          ((Wu = !0),
                          Fs(tt, function () {
                            return Es(), null;
                          })),
                        (l = 0 !== (15990 & a.flags)),
                        0 !== (15990 & a.subtreeFlags) || l)
                      ) {
                        (l = wu.transition), (wu.transition = null);
                        var o = xt;
                        xt = 1;
                        var u = Du;
                        (Du |= 4),
                          (Ru.current = null),
                          (function (e, t) {
                            if (((ei = Yt), mn((e = pn())))) {
                              if ("selectionStart" in e)
                                var a = {
                                  start: e.selectionStart,
                                  end: e.selectionEnd,
                                };
                              else
                                e: {
                                  var n =
                                    (a =
                                      ((a = e.ownerDocument) &&
                                        a.defaultView) ||
                                      window).getSelection && a.getSelection();
                                  if (n && 0 !== n.rangeCount) {
                                    a = n.anchorNode;
                                    var i = n.anchorOffset,
                                      l = n.focusNode;
                                    n = n.focusOffset;
                                    try {
                                      a.nodeType, l.nodeType;
                                    } catch (y) {
                                      a = null;
                                      break e;
                                    }
                                    var o = 0,
                                      u = -1,
                                      s = -1,
                                      c = 0,
                                      d = 0,
                                      p = e,
                                      m = null;
                                    t: for (;;) {
                                      for (
                                        var f;
                                        p !== a ||
                                          (0 !== i && 3 !== p.nodeType) ||
                                          (u = o + i),
                                          p !== l ||
                                            (0 !== n && 3 !== p.nodeType) ||
                                            (s = o + n),
                                          3 === p.nodeType &&
                                            (o += p.nodeValue.length),
                                          null !== (f = p.firstChild);

                                      )
                                        (m = p), (p = f);
                                      for (;;) {
                                        if (p === e) break t;
                                        if (
                                          (m === a && ++c === i && (u = o),
                                          m === l && ++d === n && (s = o),
                                          null !== (f = p.nextSibling))
                                        )
                                          break;
                                        m = (p = m).parentNode;
                                      }
                                      p = f;
                                    }
                                    a =
                                      -1 === u || -1 === s
                                        ? null
                                        : { start: u, end: s };
                                  } else a = null;
                                }
                              a = a || { start: 0, end: 0 };
                            } else a = null;
                            for (
                              ti = { focusedElem: e, selectionRange: a },
                                Yt = !1,
                                Zo = t;
                              null !== Zo;

                            )
                              if (
                                ((e = (t = Zo).child),
                                0 !== (1028 & t.subtreeFlags) && null !== e)
                              )
                                (e.return = t), (Zo = e);
                              else
                                for (; null !== Zo; ) {
                                  t = Zo;
                                  try {
                                    var g = t.alternate;
                                    if (0 !== (1024 & t.flags))
                                      switch (t.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                        case 5:
                                        case 6:
                                        case 4:
                                        case 17:
                                          break;
                                        case 1:
                                          if (null !== g) {
                                            var h = g.memoizedProps,
                                              b = g.memoizedState,
                                              v = t.stateNode,
                                              x = v.getSnapshotBeforeUpdate(
                                                t.elementType === t.type
                                                  ? h
                                                  : hr(t.type, h),
                                                b
                                              );
                                            v.__reactInternalSnapshotBeforeUpdate =
                                              x;
                                          }
                                          break;
                                        case 3:
                                          var z = t.stateNode.containerInfo;
                                          1 === z.nodeType
                                            ? (z.textContent = "")
                                            : 9 === z.nodeType &&
                                              z.documentElement &&
                                              z.removeChild(z.documentElement);
                                          break;
                                        default:
                                          throw Error(r(163));
                                      }
                                  } catch (y) {
                                    Ns(t, t.return, y);
                                  }
                                  if (null !== (e = t.sibling)) {
                                    (e.return = t.return), (Zo = e);
                                    break;
                                  }
                                  Zo = t.return;
                                }
                            (g = au), (au = !1);
                          })(e, a),
                          bu(a, e),
                          fn(ti),
                          (Yt = !!ei),
                          (ti = ei = null),
                          (e.current = a),
                          xu(a, e, i),
                          $e(),
                          (Du = u),
                          (xt = o),
                          (wu.transition = l);
                      } else e.current = a;
                      if (
                        (Wu && ((Wu = !1), (Vu = e), ($u = i)),
                        (l = e.pendingLanes),
                        0 === l && (Gu = null),
                        (function (e) {
                          if (rt && "function" === typeof rt.onCommitFiberRoot)
                            try {
                              rt.onCommitFiberRoot(
                                it,
                                e,
                                void 0,
                                128 === (128 & e.current.flags)
                              );
                            } catch (t) {}
                        })(a.stateNode),
                        is(e, Je()),
                        null !== t)
                      )
                        for (n = e.onRecoverableError, a = 0; a < t.length; a++)
                          (i = t[a]),
                            n(i.value, {
                              componentStack: i.stack,
                              digest: i.digest,
                            });
                      if (Hu) throw ((Hu = !1), (e = Xu), (Xu = null), e);
                      0 !== (1 & $u) && 0 !== e.tag && Es(),
                        (l = e.pendingLanes),
                        0 !== (1 & l)
                          ? e === Ku
                            ? Ju++
                            : ((Ju = 0), (Ku = e))
                          : (Ju = 0),
                        Ui();
                    })(e, t, a, n);
                } finally {
                  (wu.transition = i), (xt = n);
                }
                return null;
              }
              function Es() {
                if (null !== Vu) {
                  var e = zt($u),
                    t = wu.transition,
                    a = xt;
                  try {
                    if (
                      ((wu.transition = null),
                      (xt = 16 > e ? 16 : e),
                      null === Vu)
                    )
                      var n = !1;
                    else {
                      if (((e = Vu), (Vu = null), ($u = 0), 0 !== (6 & Du)))
                        throw Error(r(331));
                      var i = Du;
                      for (Du |= 4, Zo = e.current; null !== Zo; ) {
                        var l = Zo,
                          o = l.child;
                        if (0 !== (16 & Zo.flags)) {
                          var u = l.deletions;
                          if (null !== u) {
                            for (var s = 0; s < u.length; s++) {
                              var c = u[s];
                              for (Zo = c; null !== Zo; ) {
                                var d = Zo;
                                switch (d.tag) {
                                  case 0:
                                  case 11:
                                  case 15:
                                    nu(8, d, l);
                                }
                                var p = d.child;
                                if (null !== p) (p.return = d), (Zo = p);
                                else
                                  for (; null !== Zo; ) {
                                    var m = (d = Zo).sibling,
                                      f = d.return;
                                    if ((lu(d), d === c)) {
                                      Zo = null;
                                      break;
                                    }
                                    if (null !== m) {
                                      (m.return = f), (Zo = m);
                                      break;
                                    }
                                    Zo = f;
                                  }
                              }
                            }
                            var g = l.alternate;
                            if (null !== g) {
                              var h = g.child;
                              if (null !== h) {
                                g.child = null;
                                do {
                                  var b = h.sibling;
                                  (h.sibling = null), (h = b);
                                } while (null !== h);
                              }
                            }
                            Zo = l;
                          }
                        }
                        if (0 !== (2064 & l.subtreeFlags) && null !== o)
                          (o.return = l), (Zo = o);
                        else
                          e: for (; null !== Zo; ) {
                            if (0 !== (2048 & (l = Zo).flags))
                              switch (l.tag) {
                                case 0:
                                case 11:
                                case 15:
                                  nu(9, l, l.return);
                              }
                            var v = l.sibling;
                            if (null !== v) {
                              (v.return = l.return), (Zo = v);
                              break e;
                            }
                            Zo = l.return;
                          }
                      }
                      var x = e.current;
                      for (Zo = x; null !== Zo; ) {
                        var z = (o = Zo).child;
                        if (0 !== (2064 & o.subtreeFlags) && null !== z)
                          (z.return = o), (Zo = z);
                        else
                          e: for (o = x; null !== Zo; ) {
                            if (0 !== (2048 & (u = Zo).flags))
                              try {
                                switch (u.tag) {
                                  case 0:
                                  case 11:
                                  case 15:
                                    iu(9, u);
                                }
                              } catch (A) {
                                Ns(u, u.return, A);
                              }
                            if (u === o) {
                              Zo = null;
                              break e;
                            }
                            var y = u.sibling;
                            if (null !== y) {
                              (y.return = u.return), (Zo = y);
                              break e;
                            }
                            Zo = u.return;
                          }
                      }
                      if (
                        ((Du = i),
                        Ui(),
                        rt && "function" === typeof rt.onPostCommitFiberRoot)
                      )
                        try {
                          rt.onPostCommitFiberRoot(it, e);
                        } catch (A) {}
                      n = !0;
                    }
                    return n;
                  } finally {
                    (xt = a), (wu.transition = t);
                  }
                }
                return !1;
              }
              function Cs(e, t, a) {
                (e = Or(e, (t = fo(0, (t = so(a, t)), 1)), 1)),
                  (t = ts()),
                  null !== e && (bt(e, 1, t), is(e, t));
              }
              function Ns(e, t, a) {
                if (3 === e.tag) Cs(e, e, a);
                else
                  for (; null !== t; ) {
                    if (3 === t.tag) {
                      Cs(t, e, a);
                      break;
                    }
                    if (1 === t.tag) {
                      var n = t.stateNode;
                      if (
                        "function" === typeof t.type.getDerivedStateFromError ||
                        ("function" === typeof n.componentDidCatch &&
                          (null === Gu || !Gu.has(n)))
                      ) {
                        (t = Or(t, (e = go(t, (e = so(a, e)), 1)), 1)),
                          (e = ts()),
                          null !== t && (bt(t, 1, e), is(t, e));
                        break;
                      }
                    }
                    t = t.return;
                  }
              }
              function Ss(e, t, a) {
                var n = e.pingCache;
                null !== n && n.delete(t),
                  (t = ts()),
                  (e.pingedLanes |= e.suspendedLanes & a),
                  Fu === e &&
                    (ku & a) === a &&
                    (4 === Pu ||
                    (3 === Pu && (130023424 & ku) === ku && 500 > Je() - Uu)
                      ? ms(e, 0)
                      : (qu |= a)),
                  is(e, t);
              }
              function Rs(e, t) {
                0 === t &&
                  (0 === (1 & e.mode)
                    ? (t = 1)
                    : ((t = ct),
                      0 === (130023424 & (ct <<= 1)) && (ct = 4194304)));
                var a = ts();
                null !== (e = Dr(e, t)) && (bt(e, t, a), is(e, a));
              }
              function ws(e) {
                var t = e.memoizedState,
                  a = 0;
                null !== t && (a = t.retryLane), Rs(e, a);
              }
              function Ds(e, t) {
                var a = 0;
                switch (e.tag) {
                  case 13:
                    var n = e.stateNode,
                      i = e.memoizedState;
                    null !== i && (a = i.retryLane);
                    break;
                  case 19:
                    n = e.stateNode;
                    break;
                  default:
                    throw Error(r(314));
                }
                null !== n && n.delete(t), Rs(e, a);
              }
              function Fs(e, t) {
                return Ge(e, t);
              }
              function _s(e, t, a, n) {
                (this.tag = e),
                  (this.key = a),
                  (this.sibling =
                    this.child =
                    this.return =
                    this.stateNode =
                    this.type =
                    this.elementType =
                      null),
                  (this.index = 0),
                  (this.ref = null),
                  (this.pendingProps = t),
                  (this.dependencies =
                    this.memoizedState =
                    this.updateQueue =
                    this.memoizedProps =
                      null),
                  (this.mode = n),
                  (this.subtreeFlags = this.flags = 0),
                  (this.deletions = null),
                  (this.childLanes = this.lanes = 0),
                  (this.alternate = null);
              }
              function ks(e, t, a, n) {
                return new _s(e, t, a, n);
              }
              function Bs(e) {
                return !(!(e = e.prototype) || !e.isReactComponent);
              }
              function Os(e, t) {
                var a = e.alternate;
                return (
                  null === a
                    ? (((a = ks(e.tag, t, e.key, e.mode)).elementType =
                        e.elementType),
                      (a.type = e.type),
                      (a.stateNode = e.stateNode),
                      (a.alternate = e),
                      (e.alternate = a))
                    : ((a.pendingProps = t),
                      (a.type = e.type),
                      (a.flags = 0),
                      (a.subtreeFlags = 0),
                      (a.deletions = null)),
                  (a.flags = 14680064 & e.flags),
                  (a.childLanes = e.childLanes),
                  (a.lanes = e.lanes),
                  (a.child = e.child),
                  (a.memoizedProps = e.memoizedProps),
                  (a.memoizedState = e.memoizedState),
                  (a.updateQueue = e.updateQueue),
                  (t = e.dependencies),
                  (a.dependencies =
                    null === t
                      ? null
                      : { lanes: t.lanes, firstContext: t.firstContext }),
                  (a.sibling = e.sibling),
                  (a.index = e.index),
                  (a.ref = e.ref),
                  a
                );
              }
              function Ps(e, t, a, n, i, l) {
                var o = 2;
                if (((n = e), "function" === typeof e)) Bs(e) && (o = 1);
                else if ("string" === typeof e) o = 5;
                else
                  e: switch (e) {
                    case E:
                      return Is(a.children, i, l, t);
                    case C:
                      (o = 8), (i |= 8);
                      break;
                    case N:
                      return (
                        ((e = ks(12, a, t, 2 | i)).elementType = N),
                        (e.lanes = l),
                        e
                      );
                    case D:
                      return (
                        ((e = ks(13, a, t, i)).elementType = D),
                        (e.lanes = l),
                        e
                      );
                    case F:
                      return (
                        ((e = ks(19, a, t, i)).elementType = F),
                        (e.lanes = l),
                        e
                      );
                    case B:
                      return Ls(a, i, l, t);
                    default:
                      if ("object" === typeof e && null !== e)
                        switch (e.$$typeof) {
                          case S:
                            o = 10;
                            break e;
                          case R:
                            o = 9;
                            break e;
                          case w:
                            o = 11;
                            break e;
                          case _:
                            o = 14;
                            break e;
                          case k:
                            (o = 16), (n = null);
                            break e;
                        }
                      throw Error(r(130, null == e ? e : typeof e, ""));
                  }
                return (
                  ((t = ks(o, a, t, i)).elementType = e),
                  (t.type = n),
                  (t.lanes = l),
                  t
                );
              }
              function Is(e, t, a, n) {
                return ((e = ks(7, e, n, t)).lanes = a), e;
              }
              function Ls(e, t, a, n) {
                return (
                  ((e = ks(22, e, n, t)).elementType = B),
                  (e.lanes = a),
                  (e.stateNode = { isHidden: !1 }),
                  e
                );
              }
              function Ts(e, t, a) {
                return ((e = ks(6, e, null, t)).lanes = a), e;
              }
              function qs(e, t, a) {
                return (
                  ((t = ks(
                    4,
                    null !== e.children ? e.children : [],
                    e.key,
                    t
                  )).lanes = a),
                  (t.stateNode = {
                    containerInfo: e.containerInfo,
                    pendingChildren: null,
                    implementation: e.implementation,
                  }),
                  t
                );
              }
              function Ms(e, t, a, n, i) {
                (this.tag = t),
                  (this.containerInfo = e),
                  (this.finishedWork =
                    this.pingCache =
                    this.current =
                    this.pendingChildren =
                      null),
                  (this.timeoutHandle = -1),
                  (this.callbackNode =
                    this.pendingContext =
                    this.context =
                      null),
                  (this.callbackPriority = 0),
                  (this.eventTimes = ht(0)),
                  (this.expirationTimes = ht(-1)),
                  (this.entangledLanes =
                    this.finishedLanes =
                    this.mutableReadLanes =
                    this.expiredLanes =
                    this.pingedLanes =
                    this.suspendedLanes =
                    this.pendingLanes =
                      0),
                  (this.entanglements = ht(0)),
                  (this.identifierPrefix = n),
                  (this.onRecoverableError = i),
                  (this.mutableSourceEagerHydrationData = null);
              }
              function js(e, t, a, n, i, r, l, o, u) {
                return (
                  (e = new Ms(e, t, a, o, u)),
                  1 === t ? ((t = 1), !0 === r && (t |= 8)) : (t = 0),
                  (r = ks(3, null, null, t)),
                  (e.current = r),
                  (r.stateNode = e),
                  (r.memoizedState = {
                    element: n,
                    isDehydrated: a,
                    cache: null,
                    transitions: null,
                    pendingSuspenseBoundaries: null,
                  }),
                  _r(r),
                  e
                );
              }
              function Us(e) {
                if (!e) return Ri;
                e: {
                  if (Ue((e = e._reactInternals)) !== e || 1 !== e.tag)
                    throw Error(r(170));
                  var t = e;
                  do {
                    switch (t.tag) {
                      case 3:
                        t = t.stateNode.context;
                        break e;
                      case 1:
                        if (ki(t.type)) {
                          t =
                            t.stateNode
                              .__reactInternalMemoizedMergedChildContext;
                          break e;
                        }
                    }
                    t = t.return;
                  } while (null !== t);
                  throw Error(r(171));
                }
                if (1 === e.tag) {
                  var a = e.type;
                  if (ki(a)) return Pi(e, a, t);
                }
                return t;
              }
              function Qs(e, t, a, n, i, r, l, o, u) {
                return (
                  ((e = js(a, n, !0, e, 0, r, 0, o, u)).context = Us(null)),
                  (a = e.current),
                  ((r = Br((n = ts()), (i = as(a)))).callback =
                    void 0 !== t && null !== t ? t : null),
                  Or(a, r, i),
                  (e.current.lanes = i),
                  bt(e, i, n),
                  is(e, n),
                  e
                );
              }
              function Ys(e, t, a, n) {
                var i = t.current,
                  r = ts(),
                  l = as(i);
                return (
                  (a = Us(a)),
                  null === t.context ? (t.context = a) : (t.pendingContext = a),
                  ((t = Br(r, l)).payload = { element: e }),
                  null !== (n = void 0 === n ? null : n) && (t.callback = n),
                  null !== (e = Or(i, t, l)) && (ns(e, i, l, r), Pr(e, i, l)),
                  l
                );
              }
              function Hs(e) {
                return (e = e.current).child
                  ? (e.child.tag, e.child.stateNode)
                  : null;
              }
              function Xs(e, t) {
                if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                  var a = e.retryLane;
                  e.retryLane = 0 !== a && a < t ? a : t;
                }
              }
              function Gs(e, t) {
                Xs(e, t), (e = e.alternate) && Xs(e, t);
              }
              Cu = function (e, t, a) {
                if (null !== e)
                  if (e.memoizedProps !== t.pendingProps || Di.current) zo = !0;
                  else {
                    if (0 === (e.lanes & a) && 0 === (128 & t.flags))
                      return (
                        (zo = !1),
                        (function (e, t, a) {
                          switch (t.tag) {
                            case 3:
                              Fo(t), mr();
                              break;
                            case 5:
                              rl(t);
                              break;
                            case 1:
                              ki(t.type) && Ii(t);
                              break;
                            case 4:
                              nl(t, t.stateNode.containerInfo);
                              break;
                            case 10:
                              var n = t.type._context,
                                i = t.memoizedProps.value;
                              Si(br, n._currentValue), (n._currentValue = i);
                              break;
                            case 13:
                              if (null !== (n = t.memoizedState))
                                return null !== n.dehydrated
                                  ? (Si(ol, 1 & ol.current),
                                    (t.flags |= 128),
                                    null)
                                  : 0 !== (a & t.child.childLanes)
                                  ? To(e, t, a)
                                  : (Si(ol, 1 & ol.current),
                                    null !== (e = Ho(e, t, a))
                                      ? e.sibling
                                      : null);
                              Si(ol, 1 & ol.current);
                              break;
                            case 19:
                              if (
                                ((n = 0 !== (a & t.childLanes)),
                                0 !== (128 & e.flags))
                              ) {
                                if (n) return Qo(e, t, a);
                                t.flags |= 128;
                              }
                              if (
                                (null !== (i = t.memoizedState) &&
                                  ((i.rendering = null),
                                  (i.tail = null),
                                  (i.lastEffect = null)),
                                Si(ol, ol.current),
                                n)
                              )
                                break;
                              return null;
                            case 22:
                            case 23:
                              return (t.lanes = 0), No(e, t, a);
                          }
                          return Ho(e, t, a);
                        })(e, t, a)
                      );
                    zo = 0 !== (131072 & e.flags);
                  }
                else
                  (zo = !1),
                    ir && 0 !== (1048576 & t.flags) && Zi(t, Xi, t.index);
                switch (((t.lanes = 0), t.tag)) {
                  case 2:
                    var n = t.type;
                    Yo(e, t), (e = t.pendingProps);
                    var i = _i(t, wi.current);
                    Cr(t, a), (i = El(null, t, n, e, i, a));
                    var l = Cl();
                    return (
                      (t.flags |= 1),
                      "object" === typeof i &&
                      null !== i &&
                      "function" === typeof i.render &&
                      void 0 === i.$$typeof
                        ? ((t.tag = 1),
                          (t.memoizedState = null),
                          (t.updateQueue = null),
                          ki(n) ? ((l = !0), Ii(t)) : (l = !1),
                          (t.memoizedState =
                            null !== i.state && void 0 !== i.state
                              ? i.state
                              : null),
                          _r(t),
                          (i.updater = jr),
                          (t.stateNode = i),
                          (i._reactInternals = t),
                          Hr(t, n, e, a),
                          (t = Do(null, t, n, !0, l, a)))
                        : ((t.tag = 0),
                          ir && l && er(t),
                          yo(null, t, i, a),
                          (t = t.child)),
                      t
                    );
                  case 16:
                    n = t.elementType;
                    e: {
                      switch (
                        (Yo(e, t),
                        (e = t.pendingProps),
                        (n = (i = n._init)(n._payload)),
                        (t.type = n),
                        (i = t.tag =
                          (function (e) {
                            if ("function" === typeof e) return Bs(e) ? 1 : 0;
                            if (void 0 !== e && null !== e) {
                              if ((e = e.$$typeof) === w) return 11;
                              if (e === _) return 14;
                            }
                            return 2;
                          })(n)),
                        (e = hr(n, e)),
                        i)
                      ) {
                        case 0:
                          t = Ro(null, t, n, e, a);
                          break e;
                        case 1:
                          t = wo(null, t, n, e, a);
                          break e;
                        case 11:
                          t = Ao(null, t, n, e, a);
                          break e;
                        case 14:
                          t = Eo(null, t, n, hr(n.type, e), a);
                          break e;
                      }
                      throw Error(r(306, n, ""));
                    }
                    return t;
                  case 0:
                    return (
                      (n = t.type),
                      (i = t.pendingProps),
                      Ro(e, t, n, (i = t.elementType === n ? i : hr(n, i)), a)
                    );
                  case 1:
                    return (
                      (n = t.type),
                      (i = t.pendingProps),
                      wo(e, t, n, (i = t.elementType === n ? i : hr(n, i)), a)
                    );
                  case 3:
                    e: {
                      if ((Fo(t), null === e)) throw Error(r(387));
                      (n = t.pendingProps),
                        (i = (l = t.memoizedState).element),
                        kr(e, t),
                        Lr(t, n, null, a);
                      var o = t.memoizedState;
                      if (((n = o.element), l.isDehydrated)) {
                        if (
                          ((l = {
                            element: n,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries:
                              o.pendingSuspenseBoundaries,
                            transitions: o.transitions,
                          }),
                          (t.updateQueue.baseState = l),
                          (t.memoizedState = l),
                          256 & t.flags)
                        ) {
                          t = _o(e, t, n, a, (i = so(Error(r(423)), t)));
                          break e;
                        }
                        if (n !== i) {
                          t = _o(e, t, n, a, (i = so(Error(r(424)), t)));
                          break e;
                        }
                        for (
                          nr = si(t.stateNode.containerInfo.firstChild),
                            ar = t,
                            ir = !0,
                            rr = null,
                            a = Jr(t, null, n, a),
                            t.child = a;
                          a;

                        )
                          (a.flags = (-3 & a.flags) | 4096), (a = a.sibling);
                      } else {
                        if ((mr(), n === i)) {
                          t = Ho(e, t, a);
                          break e;
                        }
                        yo(e, t, n, a);
                      }
                      t = t.child;
                    }
                    return t;
                  case 5:
                    return (
                      rl(t),
                      null === e && sr(t),
                      (n = t.type),
                      (i = t.pendingProps),
                      (l = null !== e ? e.memoizedProps : null),
                      (o = i.children),
                      ai(n, i)
                        ? (o = null)
                        : null !== l && ai(n, l) && (t.flags |= 32),
                      So(e, t),
                      yo(e, t, o, a),
                      t.child
                    );
                  case 6:
                    return null === e && sr(t), null;
                  case 13:
                    return To(e, t, a);
                  case 4:
                    return (
                      nl(t, t.stateNode.containerInfo),
                      (n = t.pendingProps),
                      null === e
                        ? (t.child = $r(t, null, n, a))
                        : yo(e, t, n, a),
                      t.child
                    );
                  case 11:
                    return (
                      (n = t.type),
                      (i = t.pendingProps),
                      Ao(e, t, n, (i = t.elementType === n ? i : hr(n, i)), a)
                    );
                  case 7:
                    return yo(e, t, t.pendingProps, a), t.child;
                  case 8:
                  case 12:
                    return yo(e, t, t.pendingProps.children, a), t.child;
                  case 10:
                    e: {
                      if (
                        ((n = t.type._context),
                        (i = t.pendingProps),
                        (l = t.memoizedProps),
                        (o = i.value),
                        Si(br, n._currentValue),
                        (n._currentValue = o),
                        null !== l)
                      )
                        if (on(l.value, o)) {
                          if (l.children === i.children && !Di.current) {
                            t = Ho(e, t, a);
                            break e;
                          }
                        } else
                          for (
                            null !== (l = t.child) && (l.return = t);
                            null !== l;

                          ) {
                            var u = l.dependencies;
                            if (null !== u) {
                              o = l.child;
                              for (var s = u.firstContext; null !== s; ) {
                                if (s.context === n) {
                                  if (1 === l.tag) {
                                    (s = Br(-1, a & -a)).tag = 2;
                                    var c = l.updateQueue;
                                    if (null !== c) {
                                      var d = (c = c.shared).pending;
                                      null === d
                                        ? (s.next = s)
                                        : ((s.next = d.next), (d.next = s)),
                                        (c.pending = s);
                                    }
                                  }
                                  (l.lanes |= a),
                                    null !== (s = l.alternate) &&
                                      (s.lanes |= a),
                                    Er(l.return, a, t),
                                    (u.lanes |= a);
                                  break;
                                }
                                s = s.next;
                              }
                            } else if (10 === l.tag)
                              o = l.type === t.type ? null : l.child;
                            else if (18 === l.tag) {
                              if (null === (o = l.return)) throw Error(r(341));
                              (o.lanes |= a),
                                null !== (u = o.alternate) && (u.lanes |= a),
                                Er(o, a, t),
                                (o = l.sibling);
                            } else o = l.child;
                            if (null !== o) o.return = l;
                            else
                              for (o = l; null !== o; ) {
                                if (o === t) {
                                  o = null;
                                  break;
                                }
                                if (null !== (l = o.sibling)) {
                                  (l.return = o.return), (o = l);
                                  break;
                                }
                                o = o.return;
                              }
                            l = o;
                          }
                      yo(e, t, i.children, a), (t = t.child);
                    }
                    return t;
                  case 9:
                    return (
                      (i = t.type),
                      (n = t.pendingProps.children),
                      Cr(t, a),
                      (n = n((i = Nr(i)))),
                      (t.flags |= 1),
                      yo(e, t, n, a),
                      t.child
                    );
                  case 14:
                    return (
                      (i = hr((n = t.type), t.pendingProps)),
                      Eo(e, t, n, (i = hr(n.type, i)), a)
                    );
                  case 15:
                    return Co(e, t, t.type, t.pendingProps, a);
                  case 17:
                    return (
                      (n = t.type),
                      (i = t.pendingProps),
                      (i = t.elementType === n ? i : hr(n, i)),
                      Yo(e, t),
                      (t.tag = 1),
                      ki(n) ? ((e = !0), Ii(t)) : (e = !1),
                      Cr(t, a),
                      Qr(t, n, i),
                      Hr(t, n, i, a),
                      Do(null, t, n, !0, e, a)
                    );
                  case 19:
                    return Qo(e, t, a);
                  case 22:
                    return No(e, t, a);
                }
                throw Error(r(156, t.tag));
              };
              var Ws =
                "function" === typeof reportError
                  ? reportError
                  : function (e) {
                      console.error(e);
                    };
              function Vs(e) {
                this._internalRoot = e;
              }
              function $s(e) {
                this._internalRoot = e;
              }
              function Js(e) {
                return !(
                  !e ||
                  (1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
                );
              }
              function Ks(e) {
                return !(
                  !e ||
                  (1 !== e.nodeType &&
                    9 !== e.nodeType &&
                    11 !== e.nodeType &&
                    (8 !== e.nodeType ||
                      " react-mount-point-unstable " !== e.nodeValue))
                );
              }
              function Zs() {}
              function ec(e, t, a, n, i) {
                var r = a._reactRootContainer;
                if (r) {
                  var l = r;
                  if ("function" === typeof i) {
                    var o = i;
                    i = function () {
                      var e = Hs(l);
                      o.call(e);
                    };
                  }
                  Ys(t, l, e, i);
                } else
                  l = (function (e, t, a, n, i) {
                    if (i) {
                      if ("function" === typeof n) {
                        var r = n;
                        n = function () {
                          var e = Hs(l);
                          r.call(e);
                        };
                      }
                      var l = Qs(t, n, e, 0, null, !1, 0, "", Zs);
                      return (
                        (e._reactRootContainer = l),
                        (e[fi] = l.current),
                        Un(8 === e.nodeType ? e.parentNode : e),
                        ds(),
                        l
                      );
                    }
                    for (; (i = e.lastChild); ) e.removeChild(i);
                    if ("function" === typeof n) {
                      var o = n;
                      n = function () {
                        var e = Hs(u);
                        o.call(e);
                      };
                    }
                    var u = js(e, 0, !1, null, 0, !1, 0, "", Zs);
                    return (
                      (e._reactRootContainer = u),
                      (e[fi] = u.current),
                      Un(8 === e.nodeType ? e.parentNode : e),
                      ds(function () {
                        Ys(t, u, a, n);
                      }),
                      u
                    );
                  })(a, t, e, i, n);
                return Hs(l);
              }
              ($s.prototype.render = Vs.prototype.render =
                function (e) {
                  var t = this._internalRoot;
                  if (null === t) throw Error(r(409));
                  Ys(e, t, null, null);
                }),
                ($s.prototype.unmount = Vs.prototype.unmount =
                  function () {
                    var e = this._internalRoot;
                    if (null !== e) {
                      this._internalRoot = null;
                      var t = e.containerInfo;
                      ds(function () {
                        Ys(null, e, null, null);
                      }),
                        (t[fi] = null);
                    }
                  }),
                ($s.prototype.unstable_scheduleHydration = function (e) {
                  if (e) {
                    var t = Ct();
                    e = { blockedOn: null, target: e, priority: t };
                    for (
                      var a = 0;
                      a < Bt.length && 0 !== t && t < Bt[a].priority;
                      a++
                    );
                    Bt.splice(a, 0, e), 0 === a && Lt(e);
                  }
                }),
                (yt = function (e) {
                  switch (e.tag) {
                    case 3:
                      var t = e.stateNode;
                      if (t.current.memoizedState.isDehydrated) {
                        var a = dt(t.pendingLanes);
                        0 !== a &&
                          (vt(t, 1 | a),
                          is(t, Je()),
                          0 === (6 & Du) && ((Qu = Je() + 500), Ui()));
                      }
                      break;
                    case 13:
                      ds(function () {
                        var t = Dr(e, 1);
                        if (null !== t) {
                          var a = ts();
                          ns(t, e, 1, a);
                        }
                      }),
                        Gs(e, 1);
                  }
                }),
                (At = function (e) {
                  if (13 === e.tag) {
                    var t = Dr(e, 134217728);
                    if (null !== t) ns(t, e, 134217728, ts());
                    Gs(e, 134217728);
                  }
                }),
                (Et = function (e) {
                  if (13 === e.tag) {
                    var t = as(e),
                      a = Dr(e, t);
                    if (null !== a) ns(a, e, t, ts());
                    Gs(e, t);
                  }
                }),
                (Ct = function () {
                  return xt;
                }),
                (Nt = function (e, t) {
                  var a = xt;
                  try {
                    return (xt = e), t();
                  } finally {
                    xt = a;
                  }
                }),
                (Ae = function (e, t, a) {
                  switch (t) {
                    case "input":
                      if (
                        (K(e, a), (t = a.name), "radio" === a.type && null != t)
                      ) {
                        for (a = e; a.parentNode; ) a = a.parentNode;
                        for (
                          a = a.querySelectorAll(
                            "input[name=" +
                              JSON.stringify("" + t) +
                              '][type="radio"]'
                          ),
                            t = 0;
                          t < a.length;
                          t++
                        ) {
                          var n = a[t];
                          if (n !== e && n.form === e.form) {
                            var i = yi(n);
                            if (!i) throw Error(r(90));
                            G(n), K(n, i);
                          }
                        }
                      }
                      break;
                    case "textarea":
                      re(e, a);
                      break;
                    case "select":
                      null != (t = a.value) && ae(e, !!a.multiple, t, !1);
                  }
                }),
                (we = cs),
                (De = ds);
              var tc = {
                  usingClientEntryPoint: !1,
                  Events: [xi, zi, yi, Se, Re, cs],
                },
                ac = {
                  findFiberByHostInstance: vi,
                  bundleType: 0,
                  version: "18.2.0",
                  rendererPackageName: "react-dom",
                },
                nc = {
                  bundleType: ac.bundleType,
                  version: ac.version,
                  rendererPackageName: ac.rendererPackageName,
                  rendererConfig: ac.rendererConfig,
                  overrideHookState: null,
                  overrideHookStateDeletePath: null,
                  overrideHookStateRenamePath: null,
                  overrideProps: null,
                  overridePropsDeletePath: null,
                  overridePropsRenamePath: null,
                  setErrorHandler: null,
                  setSuspenseHandler: null,
                  scheduleUpdate: null,
                  currentDispatcherRef: z.ReactCurrentDispatcher,
                  findHostInstanceByFiber: function (e) {
                    return null === (e = He(e)) ? null : e.stateNode;
                  },
                  findFiberByHostInstance:
                    ac.findFiberByHostInstance ||
                    function () {
                      return null;
                    },
                  findHostInstancesForRefresh: null,
                  scheduleRefresh: null,
                  scheduleRoot: null,
                  setRefreshHandler: null,
                  getCurrentFiber: null,
                  reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
                };
              if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                var ic = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (!ic.isDisabled && ic.supportsFiber)
                  try {
                    (it = ic.inject(nc)), (rt = ic);
                  } catch (ce) {}
              }
              (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tc),
                (t.createPortal = function (e, t) {
                  var a =
                    2 < arguments.length && void 0 !== arguments[2]
                      ? arguments[2]
                      : null;
                  if (!Js(t)) throw Error(r(200));
                  return (function (e, t, a) {
                    var n =
                      3 < arguments.length && void 0 !== arguments[3]
                        ? arguments[3]
                        : null;
                    return {
                      $$typeof: A,
                      key: null == n ? null : "" + n,
                      children: e,
                      containerInfo: t,
                      implementation: a,
                    };
                  })(e, t, null, a);
                }),
                (t.createRoot = function (e, t) {
                  if (!Js(e)) throw Error(r(299));
                  var a = !1,
                    n = "",
                    i = Ws;
                  return (
                    null !== t &&
                      void 0 !== t &&
                      (!0 === t.unstable_strictMode && (a = !0),
                      void 0 !== t.identifierPrefix && (n = t.identifierPrefix),
                      void 0 !== t.onRecoverableError &&
                        (i = t.onRecoverableError)),
                    (t = js(e, 1, !1, null, 0, a, 0, n, i)),
                    (e[fi] = t.current),
                    Un(8 === e.nodeType ? e.parentNode : e),
                    new Vs(t)
                  );
                }),
                (t.findDOMNode = function (e) {
                  if (null == e) return null;
                  if (1 === e.nodeType) return e;
                  var t = e._reactInternals;
                  if (void 0 === t) {
                    if ("function" === typeof e.render) throw Error(r(188));
                    throw ((e = Object.keys(e).join(",")), Error(r(268, e)));
                  }
                  return (e = null === (e = He(t)) ? null : e.stateNode);
                }),
                (t.flushSync = function (e) {
                  return ds(e);
                }),
                (t.hydrate = function (e, t, a) {
                  if (!Ks(t)) throw Error(r(200));
                  return ec(null, e, t, !0, a);
                }),
                (t.hydrateRoot = function (e, t, a) {
                  if (!Js(e)) throw Error(r(405));
                  var n = (null != a && a.hydratedSources) || null,
                    i = !1,
                    l = "",
                    o = Ws;
                  if (
                    (null !== a &&
                      void 0 !== a &&
                      (!0 === a.unstable_strictMode && (i = !0),
                      void 0 !== a.identifierPrefix && (l = a.identifierPrefix),
                      void 0 !== a.onRecoverableError &&
                        (o = a.onRecoverableError)),
                    (t = Qs(t, null, e, 1, null != a ? a : null, i, 0, l, o)),
                    (e[fi] = t.current),
                    Un(e),
                    n)
                  )
                    for (e = 0; e < n.length; e++)
                      (i = (i = (a = n[e])._getVersion)(a._source)),
                        null == t.mutableSourceEagerHydrationData
                          ? (t.mutableSourceEagerHydrationData = [a, i])
                          : t.mutableSourceEagerHydrationData.push(a, i);
                  return new $s(t);
                }),
                (t.render = function (e, t, a) {
                  if (!Ks(t)) throw Error(r(200));
                  return ec(null, e, t, !1, a);
                }),
                (t.unmountComponentAtNode = function (e) {
                  if (!Ks(e)) throw Error(r(40));
                  return (
                    !!e._reactRootContainer &&
                    (ds(function () {
                      ec(null, null, e, !1, function () {
                        (e._reactRootContainer = null), (e[fi] = null);
                      });
                    }),
                    !0)
                  );
                }),
                (t.unstable_batchedUpdates = cs),
                (t.unstable_renderSubtreeIntoContainer = function (e, t, a, n) {
                  if (!Ks(a)) throw Error(r(200));
                  if (null == e || void 0 === e._reactInternals)
                    throw Error(r(38));
                  return ec(e, t, a, !1, n);
                }),
                (t.version = "18.2.0-next-9e3b772b8-20220608");
            },
            254: function (e, t, a) {
              var n = a(599);
              (t.createRoot = n.createRoot), (t.hydrateRoot = n.hydrateRoot);
            },
            599: function (e, t, a) {
              !(function e() {
                if (
                  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
                  "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE
                )
                  try {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
                  } catch (t) {
                    console.error(t);
                  }
              })(),
                (e.exports = a(470));
            },
            511: function (e, t, a) {
              var n = a(390),
                i = Symbol.for("react.element"),
                r = Symbol.for("react.fragment"),
                l = Object.prototype.hasOwnProperty,
                o =
                  n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
                    .ReactCurrentOwner,
                u = { key: !0, ref: !0, __self: !0, __source: !0 };
              function s(e, t, a) {
                var n,
                  r = {},
                  s = null,
                  c = null;
                for (n in (void 0 !== a && (s = "" + a),
                void 0 !== t.key && (s = "" + t.key),
                void 0 !== t.ref && (c = t.ref),
                t))
                  l.call(t, n) && !u.hasOwnProperty(n) && (r[n] = t[n]);
                if (e && e.defaultProps)
                  for (n in (t = e.defaultProps))
                    void 0 === r[n] && (r[n] = t[n]);
                return {
                  $$typeof: i,
                  type: e,
                  key: s,
                  ref: c,
                  props: r,
                  _owner: o.current,
                };
              }
              (t.jsx = s), (t.jsxs = s);
            },
            23: function (e, t) {
              var a = Symbol.for("react.element"),
                n = Symbol.for("react.portal"),
                i = Symbol.for("react.fragment"),
                r = Symbol.for("react.strict_mode"),
                l = Symbol.for("react.profiler"),
                o = Symbol.for("react.provider"),
                u = Symbol.for("react.context"),
                s = Symbol.for("react.forward_ref"),
                c = Symbol.for("react.suspense"),
                d = Symbol.for("react.memo"),
                p = Symbol.for("react.lazy"),
                m = Symbol.iterator;
              var f = {
                  isMounted: function () {
                    return !1;
                  },
                  enqueueForceUpdate: function () {},
                  enqueueReplaceState: function () {},
                  enqueueSetState: function () {},
                },
                g = Object.assign,
                h = {};
              function b(e, t, a) {
                (this.props = e),
                  (this.context = t),
                  (this.refs = h),
                  (this.updater = a || f);
              }
              function v() {}
              function x(e, t, a) {
                (this.props = e),
                  (this.context = t),
                  (this.refs = h),
                  (this.updater = a || f);
              }
              (b.prototype.isReactComponent = {}),
                (b.prototype.setState = function (e, t) {
                  if (
                    "object" !== typeof e &&
                    "function" !== typeof e &&
                    null != e
                  )
                    throw Error(
                      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
                    );
                  this.updater.enqueueSetState(this, e, t, "setState");
                }),
                (b.prototype.forceUpdate = function (e) {
                  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
                }),
                (v.prototype = b.prototype);
              var z = (x.prototype = new v());
              (z.constructor = x),
                g(z, b.prototype),
                (z.isPureReactComponent = !0);
              var y = Array.isArray,
                A = Object.prototype.hasOwnProperty,
                E = { current: null },
                C = { key: !0, ref: !0, __self: !0, __source: !0 };
              function N(e, t, n) {
                var i,
                  r = {},
                  l = null,
                  o = null;
                if (null != t)
                  for (i in (void 0 !== t.ref && (o = t.ref),
                  void 0 !== t.key && (l = "" + t.key),
                  t))
                    A.call(t, i) && !C.hasOwnProperty(i) && (r[i] = t[i]);
                var u = arguments.length - 2;
                if (1 === u) r.children = n;
                else if (1 < u) {
                  for (var s = Array(u), c = 0; c < u; c++)
                    s[c] = arguments[c + 2];
                  r.children = s;
                }
                if (e && e.defaultProps)
                  for (i in (u = e.defaultProps))
                    void 0 === r[i] && (r[i] = u[i]);
                return {
                  $$typeof: a,
                  type: e,
                  key: l,
                  ref: o,
                  props: r,
                  _owner: E.current,
                };
              }
              function S(e) {
                return "object" === typeof e && null !== e && e.$$typeof === a;
              }
              var R = /\/+/g;
              function w(e, t) {
                return "object" === typeof e && null !== e && null != e.key
                  ? (function (e) {
                      var t = { "=": "=0", ":": "=2" };
                      return (
                        "$" +
                        e.replace(/[=:]/g, function (e) {
                          return t[e];
                        })
                      );
                    })("" + e.key)
                  : t.toString(36);
              }
              function D(e, t, i, r, l) {
                var o = typeof e;
                ("undefined" !== o && "boolean" !== o) || (e = null);
                var u = !1;
                if (null === e) u = !0;
                else
                  switch (o) {
                    case "string":
                    case "number":
                      u = !0;
                      break;
                    case "object":
                      switch (e.$$typeof) {
                        case a:
                        case n:
                          u = !0;
                      }
                  }
                if (u)
                  return (
                    (l = l((u = e))),
                    (e = "" === r ? "." + w(u, 0) : r),
                    y(l)
                      ? ((i = ""),
                        null != e && (i = e.replace(R, "$&/") + "/"),
                        D(l, t, i, "", function (e) {
                          return e;
                        }))
                      : null != l &&
                        (S(l) &&
                          (l = (function (e, t) {
                            return {
                              $$typeof: a,
                              type: e.type,
                              key: t,
                              ref: e.ref,
                              props: e.props,
                              _owner: e._owner,
                            };
                          })(
                            l,
                            i +
                              (!l.key || (u && u.key === l.key)
                                ? ""
                                : ("" + l.key).replace(R, "$&/") + "/") +
                              e
                          )),
                        t.push(l)),
                    1
                  );
                if (((u = 0), (r = "" === r ? "." : r + ":"), y(e)))
                  for (var s = 0; s < e.length; s++) {
                    var c = r + w((o = e[s]), s);
                    u += D(o, t, i, c, l);
                  }
                else if (
                  ((c = (function (e) {
                    return null === e || "object" !== typeof e
                      ? null
                      : "function" ===
                        typeof (e = (m && e[m]) || e["@@iterator"])
                      ? e
                      : null;
                  })(e)),
                  "function" === typeof c)
                )
                  for (e = c.call(e), s = 0; !(o = e.next()).done; )
                    u += D((o = o.value), t, i, (c = r + w(o, s++)), l);
                else if ("object" === o)
                  throw (
                    ((t = String(e)),
                    Error(
                      "Objects are not valid as a React child (found: " +
                        ("[object Object]" === t
                          ? "object with keys {" +
                            Object.keys(e).join(", ") +
                            "}"
                          : t) +
                        "). If you meant to render a collection of children, use an array instead."
                    ))
                  );
                return u;
              }
              function F(e, t, a) {
                if (null == e) return e;
                var n = [],
                  i = 0;
                return (
                  D(e, n, "", "", function (e) {
                    return t.call(a, e, i++);
                  }),
                  n
                );
              }
              function _(e) {
                if (-1 === e._status) {
                  var t = e._result;
                  (t = t()).then(
                    function (t) {
                      (0 !== e._status && -1 !== e._status) ||
                        ((e._status = 1), (e._result = t));
                    },
                    function (t) {
                      (0 !== e._status && -1 !== e._status) ||
                        ((e._status = 2), (e._result = t));
                    }
                  ),
                    -1 === e._status && ((e._status = 0), (e._result = t));
                }
                if (1 === e._status) return e._result.default;
                throw e._result;
              }
              var k = { current: null },
                B = { transition: null },
                O = {
                  ReactCurrentDispatcher: k,
                  ReactCurrentBatchConfig: B,
                  ReactCurrentOwner: E,
                };
              (t.Children = {
                map: F,
                forEach: function (e, t, a) {
                  F(
                    e,
                    function () {
                      t.apply(this, arguments);
                    },
                    a
                  );
                },
                count: function (e) {
                  var t = 0;
                  return (
                    F(e, function () {
                      t++;
                    }),
                    t
                  );
                },
                toArray: function (e) {
                  return (
                    F(e, function (e) {
                      return e;
                    }) || []
                  );
                },
                only: function (e) {
                  if (!S(e))
                    throw Error(
                      "React.Children.only expected to receive a single React element child."
                    );
                  return e;
                },
              }),
                (t.Component = b),
                (t.Fragment = i),
                (t.Profiler = l),
                (t.PureComponent = x),
                (t.StrictMode = r),
                (t.Suspense = c),
                (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = O),
                (t.cloneElement = function (e, t, n) {
                  if (null === e || void 0 === e)
                    throw Error(
                      "React.cloneElement(...): The argument must be a React element, but you passed " +
                        e +
                        "."
                    );
                  var i = g({}, e.props),
                    r = e.key,
                    l = e.ref,
                    o = e._owner;
                  if (null != t) {
                    if (
                      (void 0 !== t.ref && ((l = t.ref), (o = E.current)),
                      void 0 !== t.key && (r = "" + t.key),
                      e.type && e.type.defaultProps)
                    )
                      var u = e.type.defaultProps;
                    for (s in t)
                      A.call(t, s) &&
                        !C.hasOwnProperty(s) &&
                        (i[s] = void 0 === t[s] && void 0 !== u ? u[s] : t[s]);
                  }
                  var s = arguments.length - 2;
                  if (1 === s) i.children = n;
                  else if (1 < s) {
                    u = Array(s);
                    for (var c = 0; c < s; c++) u[c] = arguments[c + 2];
                    i.children = u;
                  }
                  return {
                    $$typeof: a,
                    type: e.type,
                    key: r,
                    ref: l,
                    props: i,
                    _owner: o,
                  };
                }),
                (t.createContext = function (e) {
                  return (
                    ((e = {
                      $$typeof: u,
                      _currentValue: e,
                      _currentValue2: e,
                      _threadCount: 0,
                      Provider: null,
                      Consumer: null,
                      _defaultValue: null,
                      _globalName: null,
                    }).Provider = { $$typeof: o, _context: e }),
                    (e.Consumer = e)
                  );
                }),
                (t.createElement = N),
                (t.createFactory = function (e) {
                  var t = N.bind(null, e);
                  return (t.type = e), t;
                }),
                (t.createRef = function () {
                  return { current: null };
                }),
                (t.forwardRef = function (e) {
                  return { $$typeof: s, render: e };
                }),
                (t.isValidElement = S),
                (t.lazy = function (e) {
                  return {
                    $$typeof: p,
                    _payload: { _status: -1, _result: e },
                    _init: _,
                  };
                }),
                (t.memo = function (e, t) {
                  return {
                    $$typeof: d,
                    type: e,
                    compare: void 0 === t ? null : t,
                  };
                }),
                (t.startTransition = function (e) {
                  var t = B.transition;
                  B.transition = {};
                  try {
                    e();
                  } finally {
                    B.transition = t;
                  }
                }),
                (t.unstable_act = function () {
                  throw Error(
                    "act(...) is not supported in production builds of React."
                  );
                }),
                (t.useCallback = function (e, t) {
                  return k.current.useCallback(e, t);
                }),
                (t.useContext = function (e) {
                  return k.current.useContext(e);
                }),
                (t.useDebugValue = function () {}),
                (t.useDeferredValue = function (e) {
                  return k.current.useDeferredValue(e);
                }),
                (t.useEffect = function (e, t) {
                  return k.current.useEffect(e, t);
                }),
                (t.useId = function () {
                  return k.current.useId();
                }),
                (t.useImperativeHandle = function (e, t, a) {
                  return k.current.useImperativeHandle(e, t, a);
                }),
                (t.useInsertionEffect = function (e, t) {
                  return k.current.useInsertionEffect(e, t);
                }),
                (t.useLayoutEffect = function (e, t) {
                  return k.current.useLayoutEffect(e, t);
                }),
                (t.useMemo = function (e, t) {
                  return k.current.useMemo(e, t);
                }),
                (t.useReducer = function (e, t, a) {
                  return k.current.useReducer(e, t, a);
                }),
                (t.useRef = function (e) {
                  return k.current.useRef(e);
                }),
                (t.useState = function (e) {
                  return k.current.useState(e);
                }),
                (t.useSyncExternalStore = function (e, t, a) {
                  return k.current.useSyncExternalStore(e, t, a);
                }),
                (t.useTransition = function () {
                  return k.current.useTransition();
                }),
                (t.version = "18.2.0");
            },
            390: function (e, t, a) {
              e.exports = a(23);
            },
            559: function (e, t, a) {
              e.exports = a(511);
            },
            17: function (e, t) {
              function a(e, t) {
                var a = e.length;
                e.push(t);
                e: for (; 0 < a; ) {
                  var n = (a - 1) >>> 1,
                    i = e[n];
                  if (!(0 < r(i, t))) break e;
                  (e[n] = t), (e[a] = i), (a = n);
                }
              }
              function n(e) {
                return 0 === e.length ? null : e[0];
              }
              function i(e) {
                if (0 === e.length) return null;
                var t = e[0],
                  a = e.pop();
                if (a !== t) {
                  e[0] = a;
                  e: for (var n = 0, i = e.length, l = i >>> 1; n < l; ) {
                    var o = 2 * (n + 1) - 1,
                      u = e[o],
                      s = o + 1,
                      c = e[s];
                    if (0 > r(u, a))
                      s < i && 0 > r(c, u)
                        ? ((e[n] = c), (e[s] = a), (n = s))
                        : ((e[n] = u), (e[o] = a), (n = o));
                    else {
                      if (!(s < i && 0 > r(c, a))) break e;
                      (e[n] = c), (e[s] = a), (n = s);
                    }
                  }
                }
                return t;
              }
              function r(e, t) {
                var a = e.sortIndex - t.sortIndex;
                return 0 !== a ? a : e.id - t.id;
              }
              if (
                "object" === typeof performance &&
                "function" === typeof performance.now
              ) {
                var l = performance;
                t.unstable_now = function () {
                  return l.now();
                };
              } else {
                var o = Date,
                  u = o.now();
                t.unstable_now = function () {
                  return o.now() - u;
                };
              }
              var s = [],
                c = [],
                d = 1,
                p = null,
                m = 3,
                f = !1,
                g = !1,
                h = !1,
                b = "function" === typeof setTimeout ? setTimeout : null,
                v = "function" === typeof clearTimeout ? clearTimeout : null,
                x = "undefined" !== typeof setImmediate ? setImmediate : null;
              function z(e) {
                for (var t = n(c); null !== t; ) {
                  if (null === t.callback) i(c);
                  else {
                    if (!(t.startTime <= e)) break;
                    i(c), (t.sortIndex = t.expirationTime), a(s, t);
                  }
                  t = n(c);
                }
              }
              function y(e) {
                if (((h = !1), z(e), !g))
                  if (null !== n(s)) (g = !0), B(A);
                  else {
                    var t = n(c);
                    null !== t && O(y, t.startTime - e);
                  }
              }
              function A(e, a) {
                (g = !1), h && ((h = !1), v(S), (S = -1)), (f = !0);
                var r = m;
                try {
                  for (
                    z(a), p = n(s);
                    null !== p && (!(p.expirationTime > a) || (e && !D()));

                  ) {
                    var l = p.callback;
                    if ("function" === typeof l) {
                      (p.callback = null), (m = p.priorityLevel);
                      var o = l(p.expirationTime <= a);
                      (a = t.unstable_now()),
                        "function" === typeof o
                          ? (p.callback = o)
                          : p === n(s) && i(s),
                        z(a);
                    } else i(s);
                    p = n(s);
                  }
                  if (null !== p) var u = !0;
                  else {
                    var d = n(c);
                    null !== d && O(y, d.startTime - a), (u = !1);
                  }
                  return u;
                } finally {
                  (p = null), (m = r), (f = !1);
                }
              }
              "undefined" !== typeof navigator &&
                void 0 !== navigator.scheduling &&
                void 0 !== navigator.scheduling.isInputPending &&
                navigator.scheduling.isInputPending.bind(navigator.scheduling);
              var E,
                C = !1,
                N = null,
                S = -1,
                R = 5,
                w = -1;
              function D() {
                return !(t.unstable_now() - w < R);
              }
              function F() {
                if (null !== N) {
                  var e = t.unstable_now();
                  w = e;
                  var a = !0;
                  try {
                    a = N(!0, e);
                  } finally {
                    a ? E() : ((C = !1), (N = null));
                  }
                } else C = !1;
              }
              if ("function" === typeof x)
                E = function () {
                  x(F);
                };
              else if ("undefined" !== typeof MessageChannel) {
                var _ = new MessageChannel(),
                  k = _.port2;
                (_.port1.onmessage = F),
                  (E = function () {
                    k.postMessage(null);
                  });
              } else
                E = function () {
                  b(F, 0);
                };
              function B(e) {
                (N = e), C || ((C = !0), E());
              }
              function O(e, a) {
                S = b(function () {
                  e(t.unstable_now());
                }, a);
              }
              (t.unstable_IdlePriority = 5),
                (t.unstable_ImmediatePriority = 1),
                (t.unstable_LowPriority = 4),
                (t.unstable_NormalPriority = 3),
                (t.unstable_Profiling = null),
                (t.unstable_UserBlockingPriority = 2),
                (t.unstable_cancelCallback = function (e) {
                  e.callback = null;
                }),
                (t.unstable_continueExecution = function () {
                  g || f || ((g = !0), B(A));
                }),
                (t.unstable_forceFrameRate = function (e) {
                  0 > e || 125 < e
                    ? console.error(
                        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                      )
                    : (R = 0 < e ? Math.floor(1e3 / e) : 5);
                }),
                (t.unstable_getCurrentPriorityLevel = function () {
                  return m;
                }),
                (t.unstable_getFirstCallbackNode = function () {
                  return n(s);
                }),
                (t.unstable_next = function (e) {
                  switch (m) {
                    case 1:
                    case 2:
                    case 3:
                      var t = 3;
                      break;
                    default:
                      t = m;
                  }
                  var a = m;
                  m = t;
                  try {
                    return e();
                  } finally {
                    m = a;
                  }
                }),
                (t.unstable_pauseExecution = function () {}),
                (t.unstable_requestPaint = function () {}),
                (t.unstable_runWithPriority = function (e, t) {
                  switch (e) {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                      break;
                    default:
                      e = 3;
                  }
                  var a = m;
                  m = e;
                  try {
                    return t();
                  } finally {
                    m = a;
                  }
                }),
                (t.unstable_scheduleCallback = function (e, i, r) {
                  var l = t.unstable_now();
                  switch (
                    ("object" === typeof r && null !== r
                      ? (r =
                          "number" === typeof (r = r.delay) && 0 < r
                            ? l + r
                            : l)
                      : (r = l),
                    e)
                  ) {
                    case 1:
                      var o = -1;
                      break;
                    case 2:
                      o = 250;
                      break;
                    case 5:
                      o = 1073741823;
                      break;
                    case 4:
                      o = 1e4;
                      break;
                    default:
                      o = 5e3;
                  }
                  return (
                    (e = {
                      id: d++,
                      callback: i,
                      priorityLevel: e,
                      startTime: r,
                      expirationTime: (o = r + o),
                      sortIndex: -1,
                    }),
                    r > l
                      ? ((e.sortIndex = r),
                        a(c, e),
                        null === n(s) &&
                          e === n(c) &&
                          (h ? (v(S), (S = -1)) : (h = !0), O(y, r - l)))
                      : ((e.sortIndex = o),
                        a(s, e),
                        g || f || ((g = !0), B(A))),
                    e
                  );
                }),
                (t.unstable_shouldYield = D),
                (t.unstable_wrapCallback = function (e) {
                  var t = m;
                  return function () {
                    var a = m;
                    m = t;
                    try {
                      return e.apply(this, arguments);
                    } finally {
                      m = a;
                    }
                  };
                });
            },
            124: function (e, t, a) {
              e.exports = a(17);
            },
          },
          t = {};
        function a(n) {
          var i = t[n];
          if (void 0 !== i) return i.exports;
          var r = (t[n] = { exports: {} });
          return e[n](r, r.exports, a), r.exports;
        }
        !(function () {
          var e = a(390),
            t = a(254);
          function n(e) {
            return (
              (n =
                "function" == typeof Symbol &&
                "symbol" == typeof Symbol.iterator
                  ? function (e) {
                      return typeof e;
                    }
                  : function (e) {
                      return e &&
                        "function" == typeof Symbol &&
                        e.constructor === Symbol &&
                        e !== Symbol.prototype
                        ? "symbol"
                        : typeof e;
                    }),
              n(e)
            );
          }
          function i(e) {
            var t = (function (e, t) {
              if ("object" !== n(e) || null === e) return e;
              var a = e[Symbol.toPrimitive];
              if (void 0 !== a) {
                var i = a.call(e, t || "default");
                if ("object" !== n(i)) return i;
                throw new TypeError(
                  "@@toPrimitive must return a primitive value."
                );
              }
              return ("string" === t ? String : Number)(e);
            })(e, "string");
            return "symbol" === n(t) ? t : String(t);
          }
          function r(e, t, a) {
            return (
              (t = i(t)) in e
                ? Object.defineProperty(e, t, {
                    value: a,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (e[t] = a),
              e
            );
          }
          function l(e, t) {
            var a = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              t &&
                (n = n.filter(function (t) {
                  return Object.getOwnPropertyDescriptor(e, t).enumerable;
                })),
                a.push.apply(a, n);
            }
            return a;
          }
          function o(e) {
            for (var t = 1; t < arguments.length; t++) {
              var a = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? l(Object(a), !0).forEach(function (t) {
                    r(e, t, a[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(a)
                  )
                : l(Object(a)).forEach(function (t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(a, t)
                    );
                  });
            }
            return e;
          }
          function u(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var a = 0, n = new Array(t); a < t; a++) n[a] = e[a];
            return n;
          }
          function s(e, t) {
            return (
              (function (e) {
                if (Array.isArray(e)) return e;
              })(e) ||
              (function (e, t) {
                var a =
                  null == e
                    ? null
                    : ("undefined" != typeof Symbol && e[Symbol.iterator]) ||
                      e["@@iterator"];
                if (null != a) {
                  var n,
                    i,
                    r,
                    l,
                    o = [],
                    u = !0,
                    s = !1;
                  try {
                    if (((r = (a = a.call(e)).next), 0 === t)) {
                      if (Object(a) !== a) return;
                      u = !1;
                    } else
                      for (
                        ;
                        !(u = (n = r.call(a)).done) &&
                        (o.push(n.value), o.length !== t);
                        u = !0
                      );
                  } catch (c) {
                    (s = !0), (i = c);
                  } finally {
                    try {
                      if (
                        !u &&
                        null != a.return &&
                        ((l = a.return()), Object(l) !== l)
                      )
                        return;
                    } finally {
                      if (s) throw i;
                    }
                  }
                  return o;
                }
              })(e, t) ||
              (function (e, t) {
                if (e) {
                  if ("string" === typeof e) return u(e, t);
                  var a = Object.prototype.toString.call(e).slice(8, -1);
                  return (
                    "Object" === a && e.constructor && (a = e.constructor.name),
                    "Map" === a || "Set" === a
                      ? Array.from(e)
                      : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? u(e, t)
                      : void 0
                  );
                }
              })(e, t) ||
              (function () {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                );
              })()
            );
          }
          var c = !1;
          if ("undefined" !== typeof window) {
            var d = {
              get passive() {
                c = !0;
              },
            };
            window.addEventListener("testPassive", null, d),
              window.removeEventListener("testPassive", null, d);
          }
          var p =
              "undefined" !== typeof window &&
              window.navigator &&
              window.navigator.platform &&
              (/iP(ad|hone|od)/.test(window.navigator.platform) ||
                ("MacIntel" === window.navigator.platform &&
                  window.navigator.maxTouchPoints > 1)),
            m = [],
            f = !1,
            g = -1,
            h = void 0,
            b = void 0,
            v = void 0,
            x = function (e) {
              return m.some(function (t) {
                return !(
                  !t.options.allowTouchMove || !t.options.allowTouchMove(e)
                );
              });
            },
            z = function (e) {
              var t = e || window.event;
              return (
                !!x(t.target) ||
                t.touches.length > 1 ||
                (t.preventDefault && t.preventDefault(), !1)
              );
            },
            y = function () {
              void 0 !== v &&
                ((document.body.style.paddingRight = v), (v = void 0)),
                void 0 !== h &&
                  ((document.body.style.overflow = h), (h = void 0));
            },
            A = function () {
              if (void 0 !== b) {
                var e = -parseInt(document.body.style.top, 10),
                  t = -parseInt(document.body.style.left, 10);
                (document.body.style.position = b.position),
                  (document.body.style.top = b.top),
                  (document.body.style.left = b.left),
                  window.scrollTo(t, e),
                  (b = void 0);
              }
            },
            E = function (e, t) {
              if (e) {
                if (
                  !m.some(function (t) {
                    return t.targetElement === e;
                  })
                ) {
                  var a = { targetElement: e, options: t || {} };
                  (m = [].concat(
                    (function (e) {
                      if (Array.isArray(e)) {
                        for (var t = 0, a = Array(e.length); t < e.length; t++)
                          a[t] = e[t];
                        return a;
                      }
                      return Array.from(e);
                    })(m),
                    [a]
                  )),
                    p
                      ? window.requestAnimationFrame(function () {
                          if (void 0 === b) {
                            b = {
                              position: document.body.style.position,
                              top: document.body.style.top,
                              left: document.body.style.left,
                            };
                            var e = window,
                              t = e.scrollY,
                              a = e.scrollX,
                              n = e.innerHeight;
                            (document.body.style.position = "fixed"),
                              (document.body.style.top = -t),
                              (document.body.style.left = -a),
                              setTimeout(function () {
                                return window.requestAnimationFrame(
                                  function () {
                                    var e = n - window.innerHeight;
                                    e &&
                                      t >= n &&
                                      (document.body.style.top = -(t + e));
                                  }
                                );
                              }, 300);
                          }
                        })
                      : (function (e) {
                          if (void 0 === v) {
                            var t = !!e && !0 === e.reserveScrollBarGap,
                              a =
                                window.innerWidth -
                                document.documentElement.clientWidth;
                            if (t && a > 0) {
                              var n = parseInt(
                                window
                                  .getComputedStyle(document.body)
                                  .getPropertyValue("padding-right"),
                                10
                              );
                              (v = document.body.style.paddingRight),
                                (document.body.style.paddingRight =
                                  n + a + "px");
                            }
                          }
                          void 0 === h &&
                            ((h = document.body.style.overflow),
                            (document.body.style.overflow = "hidden"));
                        })(t),
                    p &&
                      ((e.ontouchstart = function (e) {
                        1 === e.targetTouches.length &&
                          (g = e.targetTouches[0].clientY);
                      }),
                      (e.ontouchmove = function (t) {
                        1 === t.targetTouches.length &&
                          (function (e, t) {
                            var a = e.targetTouches[0].clientY - g;
                            !x(e.target) &&
                              ((t && 0 === t.scrollTop && a > 0) ||
                              ((function (e) {
                                return (
                                  !!e &&
                                  e.scrollHeight - e.scrollTop <= e.clientHeight
                                );
                              })(t) &&
                                a < 0)
                                ? z(e)
                                : e.stopPropagation());
                          })(t, e);
                      }),
                      f ||
                        (document.addEventListener(
                          "touchmove",
                          z,
                          c ? { passive: !1 } : void 0
                        ),
                        (f = !0)));
                }
              } else
                console.error(
                  "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
                );
            },
            C = a(559),
            N = function (t) {
              var a = t.question,
                n = t.content,
                i = t.onClose,
                r = (0, e.useRef)();
              return (
                (0, e.useEffect)(function () {
                  return (
                    E(r.current),
                    function () {
                      return (
                        p &&
                          (m.forEach(function (e) {
                            (e.targetElement.ontouchstart = null),
                              (e.targetElement.ontouchmove = null);
                          }),
                          f &&
                            (document.removeEventListener(
                              "touchmove",
                              z,
                              c ? { passive: !1 } : void 0
                            ),
                            (f = !1)),
                          (g = -1)),
                        p ? A() : y(),
                        void (m = [])
                      );
                    }
                  );
                }, []),
                (0, C.jsx)("div", {
                  className: "popup-overlay",
                  onClick: i,
                  ref: r,
                  children: (0, C.jsxs)("div", {
                    className: "popup-content",
                    onClick: function (e) {
                      return e.stopPropagation();
                    },
                    children: [
                      (0, C.jsx)("p", { className: "question", children: a }),
                      n.map(function (e, t) {
                        return (0,
                        C.jsxs)("div", { className: "explanation", children: [(0, C.jsx)("p", { style: { fontWeight: 600 }, children: e.text }), e.feedback] }, t);
                      }),
                      (0, C.jsx)("button", {
                        className: "ok-btn",
                        onClick: i,
                        children: "OK",
                      }),
                    ],
                  }),
                })
              );
            };
          for (
            var S = function (t) {
                var a = t.context,
                  n = s((0, e.useState)(!1), 2),
                  i = n[0],
                  r = n[1];
                return (0, C.jsxs)("div", {
                  className: "infoBox",
                  children: [
                    (0, C.jsx)("button", {
                      className: "ok-btn",
                      style: { marginTop: "0px" },
                      onClick: function () {
                        return r(!i);
                      },
                      children: i
                        ? "Ascunde informatie"
                        : "Informatie document",
                    }),
                    i &&
                      (0, C.jsx)("div", {
                        className: "infoContent",
                        children: (0, C.jsx)("table", {
                          children: (0, C.jsx)("tbody", {
                            children: Object.entries(a).map(function (e, t) {
                              var a = s(e, 2),
                                n = a[0],
                                i = a[1];
                              return "Surse" !== n
                                ? (0, C.jsxs)(
                                    "tr",
                                    {
                                      children: [
                                        (0, C.jsx)("td", {
                                          children: (0, C.jsxs)("strong", {
                                            children: [n, ":"],
                                          }),
                                        }),
                                        (0, C.jsx)("td", { children: i }),
                                      ],
                                    },
                                    t
                                  )
                                : (0, C.jsxs)(
                                    "tr",
                                    {
                                      children: [
                                        (0, C.jsx)("td", {
                                          children: (0, C.jsx)("strong", {
                                            children: n,
                                          }),
                                        }),
                                        (0, C.jsx)("td", {
                                          children: (0, C.jsx)("ul", {
                                            children: i.map(function (e, t) {
                                              return (0,
                                              C.jsx)("li", { children: (0, C.jsx)("a", { href: e.link, children: e.linkText }) }, t);
                                            }),
                                          }),
                                        }),
                                      ],
                                    },
                                    t
                                  );
                            }),
                          }),
                        }),
                      }),
                  ],
                });
              },
              R = {
                1: [
                  "Acest r\u0103spuns este gre\u0219it. Operatorul lista_atribute \u03c4_lista_atribute (R) nu se refer\u0103 la proiec\u021bia rela\u021biei R, ci se refer\u0103 la ordonarea sa. Proiec\u021bia se refer\u0103 la selec\u021bia anumitor coloane (atribute) din rela\u021bie, nu la ordonarea lor.",
                  "Acest r\u0103spuns este corect. Operatorul lista_atribute \u03c4_lista_atribute (R) se refer\u0103 la ordonarea rela\u021biei R dup\u0103 atributele specificate \xeen list\u0103. Aceasta este exact func\u021bionalitatea acestui operator.",
                  "Acest r\u0103spuns este gre\u0219it. Operatorul lista_atribute \u03c4_lista_atribute (R) nu este folosit pentru gruparea rela\u021biei R, ci pentru ordonarea acesteia. Gruparea implic\u0103 agregarea datelor pe baza unor anumite atribute, ceea ce nu este cazul aici.",
                ],
                2: [
                  "Acest r\u0103spuns este corect. Un model de date reprezint\u0103, \xeentr-adev\u0103r, un set de reguli \u0219i concepte care descriu structura unei baze de date. Aceasta ofer\u0103 un cadru pentru reprezentarea \u0219i manipularea datelor.",
                  "Acest r\u0103spuns este gre\u0219it. Un model de date nu se reduce la o simpl\u0103 colec\u021bie de fi\u0219iere de date. Mai degrab\u0103, este un cadru teoretic pentru descrierea structurii \u0219i organiz\u0103rii datelor.",
                  "Acest r\u0103spuns este gre\u0219it. Un model de date nu este doar o metod\u0103 de stocare a datelor pe suport fizic. Este un cadru conceptual care define\u0219te modul \xeen care datele sunt structurate \u0219i manipulate.",
                ],
                3: [
                  "Acest r\u0103spuns este corect. Constr\xe2ngerile de integritate reprezint\u0103 mecanisme care asigur\u0103 c\u0103 opera\u021biile de inserare, \u0219tergere \u0219i modificare nu duc la \xeenc\u0103lcarea condi\u021biilor de coeren\u021b\u0103 ale datelor din baza de date.",
                  "Acest r\u0103spuns este gre\u0219it. Constr\xe2ngerile de integritate nu se refer\u0103 la verificarea drepturilor de acces la date. Ele sunt menite s\u0103 asigure coeren\u021ba \u0219i corectitudinea datelor \xeen baza de date.",
                  "Acest r\u0103spuns este gre\u0219it. De\u0219i poate p\u0103rea atractiv\u0103, aceast\u0103 op\u021biune este incorect\u0103, deoarece constr\xe2ngerile de integritate nu se refer\u0103 la verificarea drepturilor de acces la date, ci la asigurarea coeren\u021bei datelor.",
                ],
                4: [
                  "O entitate a bazei de date nu este o asociere intre obiecte, ci mai degraba un element sau un concept distinct \xeen sistem. Asocierea se refer\u0103 mai mult la leg\u0103turile \xeentre entit\u0103\u021bi.",
                  "Aceasta este defini\u021bia corect\u0103 a unei entit\u0103\u021bi \xeentr-o baz\u0103 de date. O entitate reprezint\u0103 un obiect sau un concept distinct care poate fi identificat \xeen mod unic printr-un set de atribute.",
                  "O entitate a bazei de date nu este o clasificare a obiectelor. Clasificarea se refer\u0103 mai degrab\u0103 la procesul de a grupa entit\u0103\u021bi similare sau atribute similare.",
                ],
                5: [
                  "Axioma de reflexivitate nu este cea care reglementeaz\u0103 aceast\u0103 situa\u021bie. Reflexivitatea se refer\u0103 la ideea c\u0103 dac\u0103 avem un set de atribute, acesta se poate determina pe sine \xeensu\u0219i.",
                  "Axioma de tranzitivitate nu se aplic\u0103 aici. Tranzitivitatea se refer\u0103 la ideea c\u0103 dac\u0103 X -> Y \u0219i Y -> Z, atunci X -> Z.",
                  "Aceasta este corect\u0103. Regula de augmentare, sau axioma de augmentare, afirm\u0103 c\u0103 dac\u0103 un set de atribute X determin\u0103 un set de atribute Y, atunci ad\u0103ug\xe2nd un set de atribute Z la ambele p\u0103r\u021bi ale rela\u021biei, XZ va determina YZ.",
                ],
                6: [
                  "Aceasta este op\u021biunea corect\u0103. Pentru a stabili o rela\u021bie \xeentre dou\u0103 tabele \xeentr-o baz\u0103 de date, trebuie s\u0103 existe un c\xe2mp comun \xeentre ele care este cheie primar\u0103 sau unic\u0103 \xeen cel pu\u021bin una dintre tabele. \xcen acest caz, id_autor poate servi acestui scop.",
                  "Aceast\u0103 afirma\u021bie este fals\u0103. De\u0219i este necesar ca id_autor s\u0103 fie de acela\u0219i tip \xeen ambele tabele pentru a face posibil\u0103 rela\u021bia, aceasta nu este condi\u021bia suficient\u0103 pentru a stabili o rela\u021bie \xeentre tabele.",
                  "Aceasta este o afirma\u021bie fals\u0103. Nu este necesar ca id_autor s\u0103 fie cheie primar\u0103 \xeen ambele tabele pentru a se realiza o rela\u021bie. Este suficient ca acesta s\u0103 fie cheie primar\u0103 sau unic\u0103 \xeentr-o singur\u0103 tabel\u0103.",
                ],
                7: [
                  "Modelul Entitate-Asociere extins nu este limitat doar la atribute, asocieri \u0219i constr\xe2ngeri de integritate. Acesta include mai multe componente, inclusiv entit\u0103\u021bi \u0219i ierarhii.",
                  "Acesta este r\u0103spunsul corect. Modelul Entitate-Asociere extins permite reprezentarea bazei de date prin entit\u0103\u021bi, atribute ale entitatilor, asocieri \u0219i ierarhii.",
                  "Aceast\u0103 afirma\u021bie este par\u021bial corect\u0103, dar nu include toate componentele modelului Entitate-Asociere extins. Acesta include entit\u0103\u021bi, ierarhii \u0219i chei, dar mai include \u0219i atribute ale entitatilor \u0219i asocieri.",
                ],
                8: [
                  "Aceasta este op\u021biunea corect\u0103 deoarece, av\xe2nd \xeen vedere ca o carte are un singur autor, \xeen modelul rela\u021bional (MR) se introduce cheia str\u0103in\u0103 id_autor \xeen tabela CARTI pentru a realiza leg\u0103tura \xeentre cele dou\u0103 tabele.",
                  "Aceasta este op\u021biunea gresita. \xcen modelul rela\u021bional, nu este nevoie s\u0103 ad\u0103ug\u0103m id_carte \xeen tabelul AUTORI deoarece o carte are un singur autor, iar acest lucru este reflectat prin ad\u0103ugarea id_autor \xeen tabela CARTI.",
                  "Aceasta este op\u021biunea gresita. \xcen modelul rela\u021bional, cheia str\u0103in\u0103 este ad\u0103ugat\u0103 \xeen tabelul cu cardinalitatea 'unul' \xeen rela\u021bia 'unul la multi'. \xcen acest caz, id_autor trebuie ad\u0103ugat \xeen tabela CARTI.",
                ],
                9: [
                  "Aceasta este op\u021biunea gresita deoarece o cheie FOREIGN KEY se poate referi la o cheie UNICA dintr-o alt\u0103 tabel\u0103. \xcens\u0103 acest lucru nu este suficient pentru a fi singura op\u021biune corect\u0103.",
                  "Aceasta este op\u021biunea gresita deoarece o cheie FOREIGN KEY se poate referi la o cheie PRIMAR\u0102 dintr-o alt\u0103 tabel\u0103. \xcens\u0103 acest lucru nu este suficient pentru a fi singura op\u021biune corect\u0103.",
                  "Aceasta este op\u021biunea corect\u0103 deoarece o cheie FOREIGN KEY se poate referi at\xe2t la o cheie UNICA c\xe2t \u0219i la o cheie PRIMAR\u0102 dintr-o alt\u0103 tabel\u0103.",
                ],
                10: [
                  "Aceasta este op\u021biunea gresita deoarece descompunerea nu satisface condi\u021bia de a avea un atribut comun care s\u0103 fie o cheie pentru una dintre rela\u021bii, necesar\u0103 pentru proprietatea de join f\u0103r\u0103 pierderi.",
                  "Aceasta este op\u021biunea corecta. Datorit\u0103 dependen\u021belor func\u021bionale, avem ABD -> C \u0219i ACE -> D, care sunt cuprinse \xeen multimea F. De asemenea, atributul comun A este cheie pentru una dintre rela\u021biile decompuze.",
                  "Aceasta este op\u021biunea gresita deoarece descompunerea nu satisface condi\u021bia de a avea un atribut comun care s\u0103 fie o cheie pentru una dintre rela\u021bii, necesar\u0103 pentru proprietatea de join f\u0103r\u0103 pierderi.",
                ],
                11: [
                  "Aceasta este op\u021biunea corecta deoarece D -> E este o dependenta functionala iar A nu are nici o dependenta functionala, deci AD poate fi considerata cheie.",
                  "Aceasta este op\u021biunea gresita deoarece CD nu sunt atribuite niciunei dependen\u021be func\u021bionale \xeen setul F, deci CD nu poate fi o cheie.",
                  "Aceasta este op\u021biunea gresita deoarece C \u0219i D sunt dependente de A \u0219i D, respectiv, deci includerea lor \xeentr-o cheie nu este necesar\u0103.",
                ],
                12: [
                  "R\u0103spunsul este incorect deoarece forma canonic\u0103 a unei dependen\u021be func\u021bionale este reprezentat\u0103 de un set de dependen\u021be func\u021bionale unde partea dreapt\u0103 are un singur atribut, \xeens\u0103 A->B \u0219i A->C nu fac parte din setul de dependen\u021be func\u021bionale ini\u021bial.",
                  "Acest r\u0103spuns este corect. Forma canonic\u0103 a unei dependen\u021be func\u021bionale reprezint\u0103 un set de dependen\u021be func\u021bionale unde partea dreapt\u0103 are un singur atribut, iar setul de dependen\u021be este acela\u0219i cu cel ini\u021bial.",
                  "R\u0103spunsul este incorect deoarece AB->E nu este prezent \xeen setul ini\u021bial de dependen\u021be func\u021bionale.",
                ],
                13: [
                  "R\u0103spunsul este incorect. Nu se p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale \xeen urma proiec\u021biei rela\u021biei F.",
                  "Acest r\u0103spuns este corect. Proiec\u021bia P nu p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale ale lui F. Dependen\u021bele B->E \u0219i D->B nu sunt p\u0103strate \xeen urma proiec\u021biei.",
                  "R\u0103spunsul este incorect deoarece algoritmul de verificare poate fi aplicat \xeen acest caz.",
                ],
                14: [
                  "R\u0103spunsul este corect. C\xe2nd o rela\u021bie R poate fi reconstruit\u0103 complet (f\u0103r\u0103 pierderi) din proiec\u021biile sale, acest fapt indic\u0103 existen\u021ba unei dependen\u021be jonc\u021bionale.",
                  "R\u0103spunsul este incorect. Existenta unei dependen\u021be multivalorice nu garanteaz\u0103 c\u0103 o rela\u021bie poate fi reconstruit\u0103 complet din proiec\u021biile sale.",
                  "R\u0103spunsul este incorect. Dependenta trivial\u0103 nu are leg\u0103tur\u0103 cu posibilitatea reconstruirii unei rela\u021bii din proiec\u021biile sale.",
                ],
                15: [
                  "R\u0103spunsul este incorect. Forma normal\u0103 a bazei de date FN3 nu este subsumat\u0103 de FNBC, iar FNBC nu este subsumat\u0103 de FN4.",
                  "Acest r\u0103spuns este corect. FN5 este o form\u0103 mai relaxat\u0103 dec\xe2t FN4, iar FN4 este o form\u0103 mai relaxat\u0103 dec\xe2t FNBC.",
                  "R\u0103spunsul este incorect. FNBC nu este subsumat\u0103 de FN3, iar FN3 nu este subsumat\u0103 de FN4.",
                ],
                16: [
                  "R\u0103spunsul este incorect. Axioma diferen\u021bei nu este folosit\u0103 pentru a deduce WX->->Z \u2013 WY din X->->Y \u0219i WY->->Z.",
                  "R\u0103spunsul este incorect. Axioma augment\u0103rii nu este folosit\u0103 pentru a deduce WX->->Z \u2013 WY din X->->Y \u0219i WY->->Z.",
                  "Acest r\u0103spuns este corect. Axioma pseudotranzitivit\u0103\u021bii este folosit\u0103 pentru a deduce WX->->Z \u2013 WY din X->->Y \u0219i WY->->Z.",
                ],
                17: [
                  "Graful de strategii nu reprezint\u0103 o metod\u0103 pentru descompunerea schemelor de rela\u021bii. Este mai degrab\u0103 un instrument folosit pentru analiza performan\u021bei \u0219i optimizarea interog\u0103rilor \xeentr-un sistem de gestionare a bazelor de date.",
                  "Corect, graful de strategii este o metod\u0103 pentru studierea tehnicilor de optimizare a interog\u0103rilor. Acesta este utilizat pentru a evalua \u0219i a compara diferite planuri de interogare pentru a alege cel mai eficient mod de a executa o anumit\u0103 interogare \xeen sistemul de gestionare a bazelor de date.",
                  "Graful de strategii nu este o metod\u0103 de reprezentare a bazei de date. Este folosit pentru a analiza \u0219i a \xeembun\u0103t\u0103\u021bi performan\u021ba interog\u0103rilor, nu pentru a reprezenta structura bazei de date.",
                ],
                18: [
                  "Func\u021biile SQL de grup nu pot fi folosite direct \xeen clauza WHERE a unei cereri SELECT, chiar dac\u0103 se utilizeaz\u0103 clauza GROUP BY. Clauza WHERE este folosit\u0103 pentru a filtra \xeenregistr\u0103rile \xeenainte de a face gruparea.",
                  "Func\u021biile SQL de grup nu pot fi folosite direct \xeen clauza WHERE a unei cereri SELECT, f\u0103r\u0103 a folosi subcereri. Aceste func\u021bii se aplic\u0103 pe un grup de \xeenregistr\u0103ri \u0219i nu pe \xeenregistr\u0103ri individuale, ceea ce este necesar \xeen clauza WHERE.",
                  "Corect, o func\u021bie SQL de grup se poate folosi direct \xeen clauza HAVING a unei cereri SELECT. Clauza HAVING este utilizat\u0103 pentru a filtra rezultatele care au fost deja grupate cu ajutorul clauzei GROUP BY.",
                ],
                19: [
                  "Un join de tip OUTER JOIN... ON nu returneaz\u0103 doar liniile rezultate din corelarea liniilor cu valori nule pe coloanele de join. Acest tip de join include \u0219i liniile cu valori nenule.",
                  "Un join de tip OUTER JOIN... ON nu returneaz\u0103 doar liniile rezultate din corelarea liniilor cu valori nenule. Acest tip de join include \u0219i liniile cu valori nule.",
                  "Corect, un join de tip OUTER JOIN... ON returneaz\u0103 liniile rezultate din corelarea liniilor cu valori nule \u0219i nenule pe coloanele de join rela\u021bie. Acest tip de join include toate liniile din ambele tabele.",
                ],
                20: [
                  "O baz\u0103 de date SQL nu suport\u0103 direct opera\u021biile de normalizare. Normalizarea este un proces de design al bazei de date, nu o opera\u021bie care se poate efectua pe o baz\u0103 de date existent\u0103.",
                  "O baz\u0103 de date SQL este \xeen mod clar rela\u021bional\u0103 \u0219i folose\u0219te scheme pentru modelarea datelor. Sistemele de gestionare a bazelor de date SQL se bazeaz\u0103 pe modelul rela\u021bional de date.",
                  "Corect, o baz\u0103 de date SQL folose\u0219te chei de identificare pentru reg\u0103sirea datelor. Acestea sunt esen\u021biale pentru a crea rela\u021bii \xeentre tabele \u0219i pentru a asigura integritatea datelor.",
                ],
                21: [
                  "Inserarea datelor \xeentr-o tabel\u0103, prin intermediul unui view, nu se poate face \xeentotdeauna, doar dac\u0103 se respect\u0103 tipurile de date declarate \xeen tabel\u0103. Exist\u0103 restric\u021bii suplimentare care pot \xeempiedica aceast\u0103 ac\u021biune, cum ar fi dac\u0103 view-ul se bazeaz\u0103 pe mai multe tabele.",
                  "Corect, inserarea datelor \xeentr-o tabel\u0103, prin intermediul unui view, se poate face doar prin vederile create pe o singur\u0103 tabel\u0103, respect\xe2nd constr\xe2ngerile de integritate. Dac\u0103 view-ul este bazat pe mai multe tabele, opera\u021biunea de inserare poate fi imposibil\u0103.",
                  "Inserarea datelor \xeentr-o tabel\u0103, prin intermediul unui view, este posibil\u0103 \xeen anumite condi\u021bii. Un view nu este doar pentru vizualizarea datelor, de\u0219i este cel mai des utilizat \xeen acest scop. Un view poate fi folosit \u0219i pentru a insera, actualiza sau \u0219terge date, cu anumite restric\u021bii.",
                ],
                22: [
                  "Un atribut este corect definit ca o proprietate care descrie o caracteristic\u0103 a unei entit\u0103\u021bi. \xcentr-o baz\u0103 de date, acesta poate reprezenta o caracteristic\u0103 specific\u0103 a entit\u0103\u021bii, cum ar fi numele sau adresa.",
                  "Un atribut nu este un obiect al bazei de date. \xcen schimb, reprezint\u0103 o proprietate specific\u0103 a unei entit\u0103\u021bi \xeen cadrul bazei de date.",
                  "Un atribut nu este o colec\u021bie de date. De\u0219i poate con\u021bine multiple valori, un atribut reprezint\u0103 o singur\u0103 caracteristic\u0103 a unei entit\u0103\u021bi.",
                ],
                23: [
                  "Modelul ierarhic organizeaz\u0103 datele \xeentr-o structur\u0103 de tip arbore, nu \xeentr-un graf orientat. Deci aceast\u0103 afirma\u021bie este incorect\u0103.",
                  "Modelul de re\u021bea organizeaz\u0103 datele sub forma unui graf orientat. Aceasta este cea mai potrivit\u0103 descriere pentru acest tip de model de baze de date.",
                  "Op\u021biunea nu este clar\u0103 \u0219i pare s\u0103 fie gre\u0219it\u0103. Organizarea datelor sub forma unui graf orientat este specific\u0103 modelului de re\u021bea, nu altor modele.",
                ],
                24: [
                  "Independen\u021ba logic\u0103 a datelor nu se refer\u0103 la schimbarea schemei externe f\u0103r\u0103 modificarea schemelor interne. Aceasta este o interpretare gre\u0219it\u0103 a termenului.",
                  "Independen\u021ba logic\u0103 a datelor se refer\u0103 corect la capacitatea de a schimba schema conceptual\u0103 f\u0103r\u0103 a modifica schemele externe. Aceasta permite modificarea organiz\u0103rii datelor f\u0103r\u0103 a afecta interfe\u021bele de utilizator.",
                  "Independen\u021ba logic\u0103 a datelor nu se refer\u0103 la schimbarea schemei interne f\u0103r\u0103 modificarea schemei conceptuale. Aceasta este o interpretare gre\u0219it\u0103 a termenului.",
                ],
                26: [
                  "Elementele unei rela\u021bii \xeen modelul rela\u021bional nu sunt numite domenii. Domeniul este setul posibil de valori pe care le poate lua un atribut.",
                  "Elementele unei rela\u021bii \xeen modelul rela\u021bional nu sunt numite atribute. Un atribut este o proprietate a unei entit\u0103\u021bi.",
                  "Elementele unei rela\u021bii \xeen modelul rela\u021bional sunt corect numite tuple. Acestea reprezint\u0103 \xeenregistr\u0103rile sau r\xe2ndurile \xeentr-o tabel\u0103.",
                ],
                27: [
                  "Schema unei rela\u021bii \xeen modelul rela\u021bional reprezint\u0103 corect structura unei tabele. Ea defineste numele tabelului, numele atributelor \u0219i tipul fiec\u0103rui atribut.",
                  "Schema unei rela\u021bii \xeen modelul rela\u021bional nu este o reprezentare schematic\u0103 a rela\u021biei. De\u0219i poate fi utilizat\u0103 pentru a ilustra rela\u021bia, este mai mult o defini\u021bie a structurii tabelei.",
                  "Schema unei rela\u021bii \xeen modelul rela\u021bional nu este un domeniu de valori pentru rela\u021bie. Ea define\u0219te structura tabelei, dar nu limiteaz\u0103 valorile pe care le poate lua o rela\u021bie.",
                ],
                28: [
                  "Cheia primar\u0103 a unei rela\u021bii nu accept\u0103 valori nule pe coloanele care o definesc. Este necesar ca aceste valori s\u0103 fie unice \u0219i non-nule pentru a identifica \xeen mod unic \xeenregistr\u0103rile din tabel.",
                  "Cheia primar\u0103 a unei rela\u021bii nu accept\u0103 valori duplicate pe coloanele care o definesc. Cheia primar\u0103 trebuie s\u0103 fie unic\u0103 pentru a identifica \xeen mod unic fiecare \xeenregistrare din tabel.",
                  "Ambele op\u021biuni sunt corecte. Cheia primar\u0103 a unei rela\u021bii nu accept\u0103 nici valori nule, nici valori duplicate pe coloanele care o definesc. Aceasta este o condi\u021bie fundamental\u0103 \xeen orice sistem de baze de date.",
                ],
                29: [
                  "\u0218tergerea datelor de pe o coloan\u0103 care are o cheie str\u0103in\u0103 definit\u0103 nu necesit\u0103 mai \xeent\xe2i \u0219tergerea datelor de pe coloana din tabelul cu care este rela\u021bionat\u0103. Aceasta depinde de tipul de constr\xe2ngere a integrit\u0103\u021bii referen\u021biale definit.",
                  "\u0218tergerea datelor nu necesit\u0103 mai \xeent\xe2i \u0219tergerea datelor de pe coloana rela\u021bionat\u0103. Ordinea nu este obligatorie \u0219i va depinde de restric\u021biile impuse de schema bazei de date.",
                  "\xcen realitate, nu exist\u0103 nicio restric\u021bie specific\u0103 care s\u0103 impun\u0103 ordinea \xeen care se \u0219terg datele de pe o coloan\u0103 cu o cheie str\u0103in\u0103. Acest lucru va depinde de set\u0103rile specifice ale bazei de date \u0219i de schema rela\u021bional\u0103.",
                ],
                30: [
                  "Modelul Entitate-Asociere permite reprezentarea bazei de date prin Entit\u0103\u021bi, atribute ale entit\u0103\u021bilor \u0219i asocieri. Acesta este un mod clasic de a reprezenta informa\u021biile \xeentr-o baz\u0103 de date.",
                  "Modelul Entitate-Asociere nu se bazeaz\u0103 doar pe Atribute, asocieri \u0219i constr\xe2ngeri de integritate. Aceasta include \u0219i entit\u0103\u021bi, care sunt componente fundamentale ale modelului.",
                  "Modelul Entitate-Asociere nu este limitat doar la entit\u0103\u021bi, atribute ale entit\u0103\u021bilor \u0219i chei. Asocierile sunt de asemenea un element cheie al acestui model.",
                ],
                31: [
                  "R\u0103spunsul \u201eEntit\u0103\u021bile au informa\u021bii descriptive iar atributele nu au\u201d este par\u021bial adev\u0103rat. Entit\u0103\u021bile \xeentr-un model Entitate-Asociere sunt reprezentate prin atribute, care sunt caracteristicile entit\u0103\u021bilor. Entit\u0103\u021bile con\u021bin informa\u021bii descriptive despre obiecte din lumea real\u0103, \xeen timp ce atributele reprezint\u0103 detaliile specifice asociate entit\u0103\u021bilor.",
                  "R\u0103spunsul \u201eAtributele multivalorice trebuie reclasificate \xeen entit\u0103\u021bi\u201d este, de asemenea, par\u021bial adev\u0103rat. Atributele multivalorice sunt atribute care pot avea mai multe valori pentru o singur\u0103 entitate. Pentru a simplifica modelul \u0219i a elimina ambiguitatea, este adesea o practic\u0103 bun\u0103 s\u0103 reclassific\u0103m atributele multivalorice ca entit\u0103\u021bi separate.",
                  "R\u0103spunsul \u201eAmbele variante sunt adev\u0103rate\u201d este corect. Combina\u021bia celor dou\u0103 afirma\u021bii formeaz\u0103 o imagine mai complet\u0103 a regulilor de modelare \xeen modelul Entitate-Asociere. Entit\u0103\u021bile con\u021bin informa\u021bii descriptive \u0219i atributele multivalorice ar trebui s\u0103 fie reclasificate ca entit\u0103\u021bi pentru a simplifica modelul \u0219i a elimina ambiguit\u0103\u021bile. Acest r\u0103spuns recunoa\u0219te corect c\u0103 ambele afirma\u021bii sunt valide \xeen contextul model\u0103rii Entitate-Asociere.",
                ],
                32: [
                  "Rela\u021bia dintre entitatea AUTOR \u0219i entitatea C\u0102R\u021aI este de tipul 1:N, deoarece un autor poate avea una sau mai multe c\u0103r\u021bi, dar o carte are un singur autor.",
                  "Rela\u021bia dintre entit\u0103\u021bile AUTOR \u0219i C\u0102R\u021aI nu este N:1 sau N:N. Un autor poate avea una sau mai multe c\u0103r\u021bi, dar fiecare carte are un singur autor.",
                  "Rela\u021bia dintre entit\u0103\u021bile AUTOR \u0219i C\u0102R\u021aI nu este de tipul 1:1 sau N:N. Un autor poate avea una sau mai multe c\u0103r\u021bi, dar fiecare carte are un singur autor.",
                ],
                33: [
                  "O dependen\u021b\u0103 func\u021bional\u0103 nu este doar o descriere a tipurilor de atribute. Este mai degrab\u0103 o rela\u021bie care exist\u0103 \xeentre atribute \xeentr-o baz\u0103 de date.",
                  "O dependen\u021b\u0103 func\u021bional\u0103 reprezint\u0103 o leg\u0103tur\u0103 \xeentre atribute. Aceasta afirm\u0103 c\u0103 valoarea unui atribut (sau un set de atribute) determin\u0103 valoarea altui atribut (sau set de atribute).",
                  "O dependen\u021b\u0103 func\u021bional\u0103 nu descrie at\xe2t tipurile de atribute, c\xe2t \u0219i leg\u0103tura dintre atribute. Aceasta este mai degrab\u0103 o leg\u0103tur\u0103 \xeentre atribute care reflect\u0103 constr\xe2ngerile \xeentre datele dintr-o baz\u0103 de date.",
                ],
                34: [
                  "\xcen cazul \xeen care Y este un subset al lui X, atunci X->Y se ob\u021bine prin axioma de Reflexivitate. Acesta este un concept fundamental \xeen teoria dependen\u021belor func\u021bionale.",
                  "Dac\u0103 Y este un subset al lui X, X->Y nu se ob\u021bine prin axioma de Tranzitivitate. Axioma de Tranzitivitate se refer\u0103 la situa\u021bia \xeen care dac\u0103 A->B \u0219i B->C, atunci A->C.",
                  "Dac\u0103 Y este un subset al lui X, X->Y nu se ob\u021bine prin axioma de Augmentare. Axioma de Augmentare se refer\u0103 la situa\u021bia \xeen care dac\u0103 A->B, atunci AC->BC.",
                ],
                35: [
                  "Op\u021biunea cu 'descompunere' este incorect\u0103. Regula de descompunere implic\u0103 separarea unei dependen\u021be func\u021bionale \xeen dou\u0103 sau mai multe dependen\u021be mai mici, nu combinarea lor \xeentr-una singur\u0103.",
                  "Op\u021biunea cu 'tranzitivitate' este incorect\u0103. Regula de tranzitivitate se refer\u0103 la cazul \xeen care dac\u0103 X -> Y \u0219i Y -> Z, atunci X -> Z. \xcens\u0103, \xeen cazul de fa\u021b\u0103, avem X -> Y \u0219i X -> Z, ceea ce ne duce la X -> YZ prin regula de reuniune, nu de tranzitivitate.",
                  "Op\u021biunea cu 'reuniune' este corect\u0103. \xcen cazul de fa\u021b\u0103, avem dou\u0103 dependen\u021be func\u021bionale separate, X -> Y \u0219i X -> Z, \u0219i putem combina aceste dou\u0103 dependen\u021be \xeentr-una singur\u0103, X -> YZ, folosind regula de reuniune.",
                ],
                36: [
                  "Op\u021biunea cu 'AC' este incorect\u0103. 'AC' nu poate fi supercheie, deoarece nu are puterea de a determina toate celelalte atribute ale rela\u021biei R. Adic\u0103, nu exist\u0103 o dependen\u021b\u0103 func\u021bional\u0103 \xeen setul F care s\u0103 demonstreze asta.",
                  "Op\u021biunea cu 'AB' este corect\u0103. 'AB' poate fi considerat\u0103 o supercheie, deoarece aceasta determin\u0103 toate celelalte atribute ale rela\u021biei R. Avem dependen\u021ba func\u021bional\u0103 AB -> CD \xeen setul F, care \xeempreun\u0103 cu C -> DE ne asigur\u0103 aceasta.",
                  "Op\u021biunea cu 'BC' este incorect\u0103. Nu exist\u0103 o dependen\u021b\u0103 func\u021bional\u0103 \xeen setul F care s\u0103 arate c\u0103 'BC' ar putea determina toate celelalte atribute ale rela\u021biei R.",
                ],
                37: [
                  "Op\u021biunea cu 'Dependenta partiala' este corect\u0103. O dependen\u021b\u0103 par\u021bial\u0103 exist\u0103 atunci c\xe2nd un atribut este func\u021bional dependent de o parte a unei chei. \xcen acest caz, X este strict inclus \xeentr-o cheie, ceea ce define\u0219te o dependen\u021b\u0103 par\u021bial\u0103.",
                  "Op\u021biunea cu 'Dependenta tranzitiva' este incorect\u0103. O dependen\u021b\u0103 tranzitiv\u0103 exist\u0103 atunci c\xe2nd un atribut este dependent func\u021bional de un alt atribut care nu este o cheie. \xcens\u0103 \xeen acest caz, X este strict inclus \xeentr-o cheie.",
                  "Op\u021biunea cu 'Dependenta obtinuta prin descompunere' este incorect\u0103. Acest tip de dependen\u021b\u0103 apare \xeen urma unei opera\u021biuni de descompunere a rela\u021biei. \xcen cazul nostru, X este strict inclus \xeentr-o cheie, care reprezint\u0103 o dependen\u021b\u0103 par\u021bial\u0103, nu una ob\u021binut\u0103 prin descompunere.",
                ],
                38: [
                  "Op\u021biunea cu 'Da, conform definitiei' este incorect\u0103. O rela\u021bie este \xeen FN2 dac\u0103 este \xeen FN1 \u0219i nu exist\u0103 nicio dependen\u021b\u0103 par\u021bial\u0103 \xeentre atributele non-cheie. \xcen acest caz, exist\u0103 dependen\u021be par\u021biale, deci rela\u021bia nu este \xeen FN2.",
                  "Op\u021biunea cu 'Nu, pentru ca are dependente partiale' este corect\u0103. Rela\u021bia nu este \xeen FN2 deoarece exist\u0103 dependen\u021be par\u021biale \xeentre atributele non-cheie. Pentru a fi \xeen FN2, o rela\u021bie trebuie s\u0103 fie \xeen FN1 \u0219i s\u0103 nu aib\u0103 dependen\u021be par\u021biale.",
                  "Op\u021biunea cu 'Nu, pt ca nu este in FN1' este incorect\u0103. FN1 este un criteriu necesar, dar nu suficient pentru FN2. \xcen acest caz, rela\u021bia poate fi \xeen FN1, dar existen\u021ba dependen\u021belor par\u021biale \xeempiedic\u0103 trecerea la FN2.",
                ],
                39: [
                  "Op\u021biunea cu 'A,D' este incorect\u0103. Atributele prime sunt acelea care fac parte dintr-o cheie. \xcen acest caz, cheile sunt AD \u0219i BD, deci atributele prime sunt A, B \u0219i D.",
                  "Op\u021biunea cu 'A,B,D' este corect\u0103. Atributele prime sunt acelea care fac parte dintr-o cheie. \xcen acest caz, cheile sunt AD \u0219i BD, deci atributele prime sunt A, B \u0219i D.",
                  "Op\u021biunea cu 'B,C,E' este incorect\u0103. Atributele prime sunt acelea care fac parte dintr-o cheie. \xcen acest caz, cheile sunt AD \u0219i BD, deci atributele prime sunt A, B \u0219i D, nu B, C \u0219i E.",
                ],
                40: [
                  "R\u0103spunsul t\u0103u este incorect. Atunci c\xe2nd spui c\u0103 sunt 2 chei distincte pentru rela\u021bia R, nu iei \xeen considerare toate dependen\u021bele func\u021bionale. Analiz\xe2nd dependen\u021bele func\u021bionale A\u2192C, B\u2192A, C\u2192B, \u0219i E\u2192D, putem vedea c\u0103 cheile corecte pentru rela\u021bia R sunt AE, BE \u0219i CE, deci exist\u0103 de fapt 3 chei distincte.",
                  "R\u0103spunsul t\u0103u este incorect. Aleg\xe2nd 4 ca num\u0103r de chei distincte, exagerezi num\u0103rul de chei care pot fi derivate din dependen\u021bele func\u021bionale date. Dac\u0103 analizezi dependen\u021bele A\u2192C, B\u2192A, C\u2192B \u0219i E\u2192D, vei observa c\u0103 exist\u0103 3 chei distincte pentru rela\u021bia R: AE, BE \u0219i CE.",
                  "Felicit\u0103ri! R\u0103spunsul t\u0103u este corect. Rela\u021bia R are \xeentr-adev\u0103r 3 chei distincte. Analiz\xe2nd dependen\u021bele func\u021bionale A\u2192C, B\u2192A, C\u2192B, \u0219i E\u2192D, observ\u0103m c\u0103 putem identifica trei chei candidate care sunt minimale \u0219i care pot determina toate atributele din rela\u021bia R. Aceste chei sunt AE, BE \u0219i CE.",
                ],
                41: [
                  "Op\u021biunea cu 'FNBC' este incorect\u0103. Forma normal\u0103 Boyce-Codd (FNBC) este o condi\u021bie mai puternic\u0103 dec\xe2t FN3, care elimin\u0103 anomalii suplimentare. \xcen acest caz, rela\u021bia R nu respect\u0103 condi\u021biile pentru FNBC.",
                  "Op\u021biunea cu 'FN3' este incorect\u0103. FN3 implic\u0103 absen\u021ba dependen\u021belor tranzitive \xeentr-o rela\u021bie, ceea ce nu este cazul aici. Prin urmare, R nu este \xeen FN3.",
                  "Op\u021biunea cu 'Ambele variante sunt corecte' este corect\u0103. R nu este nici \xeen FN3, nici \xeen FNBC, a\u0219a cum reiese din analiza dependen\u021belor func\u021bionale. Prin urmare, niciuna dintre op\u021biuni nu este corect\u0103 individual, deci ambele sunt corecte.",
                ],
                42: [
                  "Op\u021biunea cu '{A\u2192B, B\u2192A}' este corect\u0103. Proiec\u021bia unei mul\u021bimi de dependen\u021be func\u021bionale F pe o submul\u021bime de atribute include toate dependen\u021bele din F care implic\u0103 numai atributele din submul\u021bime. \xcen acest caz, doar dependen\u021bele A\u2192B \u0219i B\u2192A se \xeencadreaz\u0103 \xeen aceast\u0103 categorie.",
                  "Op\u021biunea cu '{A\u2192B, E\u2192B}' este incorect\u0103. Proiec\u021bia unei mul\u021bimi de dependen\u021be func\u021bionale F pe o submul\u021bime de atribute include toate dependen\u021bele din F care implic\u0103 numai atributele din submul\u021bime. \xcen acest caz, nu exist\u0103 o dependen\u021b\u0103 E\u2192B \xeen F.",
                  "Op\u021biunea cu 'Ambele variante sunt gresite' este incorect\u0103. Prima variant\u0103 este corect\u0103, deoarece A\u2192B \u0219i B\u2192A sunt singurele dependen\u021be care implic\u0103 doar atribute din submul\u021bimea ABED.",
                ],
                43: [
                  "Op\u021biunea cu 'ABC' este corect\u0103. \xcenchiderea unui set de atribute X, notat\u0103 X+, este setul tuturor atributelor care pot fi determinate func\u021bional de X. \xcen acest caz, din A\u2192C \u0219i B\u2192A, putem determina atributul B, deci \xeenchiderea AC este ABC.",
                  "Op\u021biunea cu 'ABCE' este incorect\u0103. E nu poate fi determinat func\u021bional de AC \xeen acest set de dependen\u021be func\u021bionale, deci nu face parte din \xeenchiderea AC.",
                  "Op\u021biunea cu 'ABCDE' este incorect\u0103. D nu poate fi determinat func\u021bional de AC \xeen acest set de dependen\u021be func\u021bionale, deci nu face parte din \xeenchiderea AC.",
                ],
                44: [
                  "R\u0103spunsul corect este c\u0103 joinul extern complet al celor dou\u0103 rela\u021bii dup\u0103 condi\u021bia (R.A=S.A) \u0219i (R.B=S.B) are 4 tupluri. Acest lucru se bazeaz\u0103 pe definirea oper\u0103rii de join extern complet \xeen care toate \xeenregistr\u0103rile din ambele tabele sunt returnate, indiferent dac\u0103 exist\u0103 sau nu o potrivire.",
                  "Niciun join extern complet al rela\u021biilor R \u0219i S nu va rezulta \xeen 3 tupluri dup\u0103 condi\u021bia (R.A=S.A) \u0219i (R.B=S.B). Este posibil ca acest num\u0103r s\u0103 fie prea mic dac\u0103 sunt prezente mai multe \xeenregistr\u0103ri care \xeendeplinesc condi\u021bia de join.",
                  "Nu este corect c\u0103 joinul extern complet al rela\u021biilor R \u0219i S va avea 5 tupluri dup\u0103 condi\u021bia (R.A=S.A) \u0219i (R.B=S.B). Acest num\u0103r poate fi prea mare dac\u0103 nu exist\u0103 suficiente \xeenregistr\u0103ri care \xeendeplinesc condi\u021bia de join.",
                ],
                45: [
                  "Corect. Pentru o cheie PRIMARY KEY, nu se accept\u0103 valori nule sau duplicate. Aceasta este o condi\u021bie necesar\u0103 pentru a asigura unicitatea \u0219i non-nulitatea \xeenregistr\u0103rilor \xeentr-o baz\u0103 de date.",
                  "Incorect. Nu se accept\u0103 valori nule pe coloanele care definesc o cheie PRIMARY KEY. Aceasta este o regul\u0103 fundamental\u0103 pentru a asigura unicitatea \xeenregistr\u0103rilor \xeentr-o baz\u0103 de date.",
                  "Incorect. Coloanele care definesc o cheie PRIMARY KEY nu pot con\u021bine valori duplicate sau nule. \xcen caz contrar, acestea nu ar putea fi utilizate pentru a identifica \xeen mod unic \xeenregistr\u0103rile.",
                ],
                46: [
                  "Corect. Clauza CHECK for\u021beaz\u0103 valoarea unei coloane s\u0103 verifice o condi\u021bie prestabilit\u0103 dup\u0103 ce se realizeaz\u0103 condi\u021bia de join. Acesta este un mijloc de a asigura integritatea datelor.",
                  "Clauza CHECK nu for\u021beaz\u0103 valoarea unei linii s\u0103 verifice o condi\u021bie prestabilit\u0103 dup\u0103 ce se realizeaz\u0103 condi\u021bia de join. Clauza CHECK se aplic\u0103 la nivel de coloan\u0103, nu de linie.",
                ],
                47: [
                  "Corect, cu acela\u0219i con\u021binut \u0219i nume al tabelului, o tabel\u0103 poate fi modificat\u0103 printr-un view. Aceasta este o caracteristic\u0103 a sistemelor de gestiune a bazelor de date care permit opera\u021bii DML prin view-uri.",
                  "Nu este adev\u0103rat c\u0103 nu po\u021bi modifica o tabel\u0103 printr-un view. De fapt, multe sisteme de gestiune a bazelor de date permit acest lucru, dac\u0103 view-ul este definit \xeentr-un mod care permite modificarea.",
                  "De\u0219i \xeen anumite condi\u021bii o tabel\u0103 poate fi modificat\u0103 printr-un view, aceasta nu este \xeentotdeauna cazul. Prin urmare, afirma\u021bia c\u0103 acest lucru este posibil \u201e\xeen anumite condi\u021bii\u201d este \xeen esen\u021b\u0103 fals\u0103.",
                ],
                48: [
                  "O rela\u021bie \xeen forma normal\u0103 FNB nu este \xeentotdeauna \u0219i \xeen forma normal\u0103 FN4. FN4 implic\u0103 o serie de condi\u021bii suplimentare care pot s\u0103 nu fie \xeendeplinite \xeen toate cazurile.",
                  "Corect, o rela\u021bie \xeen forma normal\u0103 FNB este \xeentotdeauna \u0219i \xeen forma normal\u0103 FN3. FN3 este un subset al FNB, astfel c\u0103 orice rela\u021bie care este \xeen FNB este, de asemenea, \xeen FN3.",
                  "Afirma\u021bia c\u0103 niciuna dintre variante nu este corect\u0103 este fals\u0103. De fapt, o rela\u021bie \xeen forma normal\u0103 FNB este \xeentotdeauna \u0219i \xeen forma normal\u0103 FN3.",
                ],
                49: [
                  "Func\u021bia stddev nu poate fi folosit\u0103 cu alte tipuri de date dec\xe2t cele numerice. Aceasta este o func\u021bie de agregare care calculeaz\u0103 devia\u021bia standard a unui set de valori numerice.",
                  "Func\u021bia avg nu poate fi folosit\u0103 cu alte tipuri de date dec\xe2t cele numerice. Aceasta este o func\u021bie de agregare care calculeaz\u0103 media unui set de valori numerice.",
                  "Corect, func\u021bia count poate fi folosit\u0103 \u0219i cu alte tipuri de date dec\xe2t cele numerice. Aceasta num\u0103r\u0103 num\u0103rul de \xeenregistr\u0103ri, indiferent de tipul de date al coloanei.",
                ],
                50: [
                  "Nu este adev\u0103rat c\u0103 nu este obligatoriu ca subcererile s\u0103 fie incluse \xeentre paranteze. Subcererile trebuie \xeentotdeauna s\u0103 fie \xeenchise \xeentre paranteze pentru a delimita acestea de restul interog\u0103rii.",
                  "Nu este adev\u0103rat c\u0103 subcererile pot fi ordonate. Rezultatele subcererilor nu pot fi ordonate folosind clauza ORDER BY. Ordinea este determinat\u0103 de cererea principal\u0103.",
                  "Corect, subcererile pot folosi func\u021bii de grup \u0219i clauza GROUP BY. Acestea permit agregarea datelor \xeen cadrul subcererii.",
                ],
                51: [
                  "Descompunerea p = (ABC, AEC) nu p\u0103streaz\u0103 dependen\u021bele func\u021bionale ale rela\u021biei R. Descompunerile trebuie s\u0103 fie efectuate \xeen a\u0219a fel \xeenc\xe2t dependen\u021bele func\u021bionale ale rela\u021biei originale s\u0103 fie p\u0103strate.",
                  "Corect, descompunerea p=(BDA, CAE) p\u0103streaz\u0103 dependen\u021bele func\u021bionale ale rela\u021biei R. Acest lucru se datoreaz\u0103 faptului c\u0103 toate dependen\u021bele din setul F pot fi deduse din aceast\u0103 descompunere.",
                  "Descompunerea p=(ABE, ABD) nu p\u0103streaz\u0103 dependen\u021bele func\u021bionale ale rela\u021biei R. \xcen acest caz, exist\u0103 dependen\u021be care nu pot fi deduse din aceast\u0103 descompunere.",
                ],
                52: [
                  "Cheia (ID_telefon, ID_furnizor) este \u0219i supercheie a rela\u021biei, deci nu exist\u0103 dependen\u021be tranzitive sau partiale, ceea ce \xeenseamn\u0103 c\u0103 rela\u021bia este \xeen a treia form\u0103 normal\u0103 (3NF).",
                  "Dependen\u021bele par\u021biale apar atunci c\xe2nd un atribut non-cheie este func\u021bional dependent de o parte a cheii primare. \xcen acest caz, cheia primar\u0103 este format\u0103 din ambele atribute, deci nu exist\u0103 dependen\u021be par\u021biale.",
                  "Cheia (ID_telefon, ID_furnizor) este \u0219i supercheie a rela\u021biei, deci nu exist\u0103 dependen\u021be tranzitive sau partiale. Astfel, aceast\u0103 rela\u021bie este \xeen a treia form\u0103 normal\u0103 (3NF).",
                ],
                53: [
                  "\xcentr-o ierarhie de incluziune, o instan\u021b\u0103 a unei subentit\u0103\u021bi se poate reg\u0103si \u0219i \xeen alte subentit\u0103\u021bi aflate \xeen rela\u021bie de incluziune cu entitatea principal\u0103. Acesta este un comportament normal \xeen modelele de date entitate-asociere.",
                  "\xcentr-o ierarhie de incluziune, o instan\u021b\u0103 a unei subentit\u0103\u021bi poate apar\u021bine mai multor subentit\u0103\u021bi simultan. Afirmarea c\u0103 o instan\u021b\u0103 a unei subentit\u0103\u021bi se reg\u0103se\u0219te doar \xeen acea subentitate nu este corect\u0103.",
                  "\xcentr-o ierarhie de incluziune, o instan\u021b\u0103 a unei subentit\u0103\u021bi poate apar\u021bine mai multor subentit\u0103\u021bi simultan. Nu este necesar ca o instan\u021b\u0103 s\u0103 apar\u021bin\u0103 tuturor subentit\u0103\u021bilor sau entit\u0103\u021bii principale.",
                ],
                54: [
                  "Aceasta nu este o afirmatie corecta. La transformarea in relational, o asociere unara multi-multi nu devine o coloana in tabela. Aceasta asociere se transforma intr-o tabela separata.",
                  "Aceasta nu este o afirmatie corecta. La transformarea in relational, o asociere unara multi-multi nu devine o linie in tabela. Aceasta asociere se transforma intr-o tabela separata.",
                  "Aceasta este o afirmatie corecta. La transformarea in relational, o asociere unara multi-multi devine o tabela. Aceasta reprezinta modul standard de a modela aceasta tip de asociere in modelul relational.",
                ],
                55: [
                  "Oracle NoSQL este o baz\u0103 de date NoSQL care utilizeaz\u0103 un model orientat pe valorile cheie, nu pe coloane.",
                  "MongoDB este o baz\u0103 de date orientat\u0103 pe documente, nu pe coloane. Prin urmare, nu utilizeaz\u0103 modelul de stocare a datelor orientat pe coloane.",
                  "Cassandra este o baz\u0103 de date NoSQL care utilizeaz\u0103 un model de stocare a datelor orientat pe coloane. Ea este proiectat\u0103 pentru a gestiona cantit\u0103\u021bi mari de date distribuite pe multe servere.",
                ],
                56: [
                  "Comanda CREATE TABLE poate include subcereri pentru a popula tabela cu date la creare.",
                  "Comanda DROP nu poate fi utilizat\u0103 cu subcereri. Aceasta este folosit\u0103 pentru a \u0219terge obiecte de baz\u0103 de date, cum ar fi tabelele, \u0219i nu necesit\u0103 o subcerere.",
                  "Comanda INSERT poate include subcereri pentru a introduce date \xeentr-o tabel\u0103.",
                ],
                58: [
                  "Cheia lui R este de fapt 'CE'. Acest lucru se datoreaz\u0103 faptului c\u0103 niciun alt set de atribute nu poate fi utilizat pentru a determina \xeen mod unic toate celelalte atribute din rela\u021bia R.",
                  "ABCE nu poate fi o cheie pentru R, deoarece setul de atribute CE este suficient pentru a determina \xeen mod unic toate celelalte atribute \xeen rela\u021bia R.",
                  "ACE nu poate fi o cheie pentru R, deoarece setul de atribute CE este suficient pentru a determina \xeen mod unic toate celelalte atribute \xeen rela\u021bia R.",
                ],
                59: [
                  "Independen\u021ba fizic\u0103 a datelor nu implic\u0103 posibilitatea de a schimba schema fizic\u0103 f\u0103r\u0103 a modifica schema conceptual\u0103. Ea se refer\u0103 la capacitatea de a modifica structura fizic\u0103 a bazei de date f\u0103r\u0103 a afecta utilizatorii sau aplica\u021biile care acceseaz\u0103 datele.",
                  "Independen\u021ba fizic\u0103 a datelor nu se refer\u0103 la schimbarea schemei fizice f\u0103r\u0103 a modifica schemele externe. Ea se refer\u0103 la capacitatea de a modifica structura fizic\u0103 a bazei de date f\u0103r\u0103 a afecta utilizatorii sau aplica\u021biile care acceseaz\u0103 datele.",
                  "Independen\u021ba fizic\u0103 a datelor se refer\u0103 la capacitatea de a modifica structura fizic\u0103 a bazei de date f\u0103r\u0103 a afecta utilizatorii sau aplica\u021biile care acceseaz\u0103 datele, ceea ce include at\xe2t schema conceptual\u0103, c\xe2t \u0219i schemele externe.",
                ],
                60: [
                  "C\xe2nd se creeaz\u0103 \xeen Oracle SQL o cheie primar\u0103 (PRIMARY KEY), se creeaz\u0103 automat o constr\xe2ngere NOT NULL, o constr\xe2ngere UNIQUE \u0219i un INDEX. Aceste constr\xe2ngeri asigur\u0103 c\u0103 valorile cheii primare sunt unice \u0219i c\u0103 nu sunt valori nule.",
                  "C\xe2nd se creeaz\u0103 \xeen Oracle SQL o cheie primar\u0103 (PRIMARY KEY), nu se creeaz\u0103 doar o constr\xe2ngere NOT NULL, ci \u0219i o constr\xe2ngere UNIQUE \u0219i un INDEX. Aceste constr\xe2ngeri asigur\u0103 c\u0103 valorile cheii primare sunt unice \u0219i c\u0103 nu sunt valori nule.",
                  "C\xe2nd se creeaz\u0103 \xeen Oracle SQL o cheie primar\u0103 (PRIMARY KEY), nu se creeaz\u0103 doar o constr\xe2ngere UNIQUE, ci \u0219i o constr\xe2ngere NOT NULL \u0219i un INDEX. Aceste constr\xe2ngeri asigur\u0103 c\u0103 valorile cheii primare sunt unice \u0219i c\u0103 nu sunt valori nule.",
                ],
                61: [
                  "Rela\u021biile nu provin din entit\u0103\u021bi \u0219i asocieri \xeen procesul de transformare din modelul EA \xeen modelul MR. Aceasta este o \xeen\u021belegere gre\u0219it\u0103 a procesului de transformare.",
                  "De asemenea, rela\u021biile nu provin din entit\u0103\u021bi \u0219i atribute care sunt chei externe. Procesul de transformare presupune conversia modelului Entitate-Asociere \xeen modelul Rela\u021bional.",
                  "Aceast\u0103 op\u021biune este corect\u0103. Ambele afirma\u021bii de mai sus sunt adev\u0103rate \xeen contextul transform\u0103rii din modelul EA \xeen modelul MR.",
                ],
                62: [
                  "Aceasta nu este o afirmatie corecta. In sisteme NoSQL cu stocare cheie-valoare, operatiile principale nu sunt Insert, Update, Delete, Find. In schimb, operatiile principale sunt Insert, Fetch, Update, Delete.",
                  "Aceasta este o afirmatie corecta. In sisteme NoSQL cu stocare cheie-valoare, operatiile principale sunt Insert, Fetch, Update, Delete. Acestea permit manipularea si accesarea datelor eficient.",
                  "Aceasta nu este o afirmatie corecta. In sisteme NoSQL cu stocare cheie-valoare, operatiile principale nu sunt Load, Update, Delete, Search. In schimb, operatiile principale sunt Insert, Fetch, Update, Delete.",
                ],
                63: [
                  "Aceasta nu este o defini\u021bie corect\u0103 a planific\u0103rii. Planificarea nu se refer\u0103 la ordinea \xeen care sunt scrise datele \xeen tabelele bazei de date.",
                  "De asemenea, planificarea nu se refer\u0103 la ordonarea tranzac\u021biilor dup\u0103 opera\u021biunile pe care le execut\u0103. Acesta este un aspect al gestiunii tranzac\u021biilor, nu al planific\u0103rii.",
                  "Aceasta este o defini\u021bie corect\u0103 a planific\u0103rii. Planificarea se refer\u0103 la ordinea \xeen care sunt executa\u021bi pa\u0219ii elementari ai unui set de tranzac\u021bii.",
                ],
                64: [
                  "Aceasta este o abordare incorect\u0103 a \u0219tergerii datelor dintr-o tabel\u0103 care are o cheie FOREIGN KEY definit\u0103. \xcenainte de a \u0219terge datele, trebuie s\u0103 v\u0103 asigura\u021bi c\u0103 nu exist\u0103 date asociate \xeen tabela unde este definit\u0103 cheia FOREIGN KEY.",
                  "Aceasta este o abordare corect\u0103 a \u0219tergerii datelor dintr-o tabel\u0103 care are o cheie FOREIGN KEY definit\u0103. Trebuie s\u0103 \u0219terge\u021bi mai \xeent\xe2i datele asociate din tabela unde este definit\u0103 cheia FOREIGN KEY.",
                  "Aceasta este o afirma\u021bie incorect\u0103. Exist\u0103 restric\u021bii \xeen \u0219tergerea datelor dintr-o tabel\u0103 care are o cheie FOREIGN KEY definit\u0103.",
                ],
                65: [
                  "Bazele de date SQL nu utilizeaz\u0103 \xeen mod obi\u0219nuit algoritmul MapReduce pentru prelucrarea datelor. Acest algoritm este mai frecvent utilizat cu bazele de date NoSQL.",
                  "Aceasta este o afirma\u021bie corect\u0103. Bazele de date NoSQL folosesc de obicei algoritmul MapReduce pentru prelucrarea datelor, \xeen special pentru opera\u021biuni de filtrare \u0219i sortare a datelor.",
                  "Ambele tipuri de baze de date nu utilizeaz\u0103 \xeen mod obi\u0219nuit algoritmul MapReduce. Algoritmul este mai specific pentru bazele de date NoSQL.",
                ],
                66: [
                  "Aceasta este o afirma\u021bie corect\u0103. \xcen Oracle SQL, operatorul SOME este sinonim cu operatorul ANY c\xe2nd este folosit \xeentr-o clauz\u0103 HAVING care con\u021bine o subcerere care poate \xeentoarce mai multe linii.",
                  "Operatorul SOME nu este sinonim cu operatorul ALL \xeen Oracle SQL. Ace\u0219tia au semnifica\u021bii diferite \u0219i sunt utiliza\u021bi \xeen contexte diferite.",
                  "Operatorul SOME nu este sinonim cu operatorul IN \xeen Oracle SQL. Operatorul IN este utilizat pentru a testa dac\u0103 o valoare se g\u0103se\u0219te \xeentr-un set specificat.",
                ],
                67: [
                  "\xcen Oracle SQL, o subcerere poate fi utilizat\u0103 \xeen clauza HAVING. Aceasta poate fi folosit\u0103 pentru a filtra rezultatele unei cereri \xeen func\u021bie de o condi\u021bie care depinde de datele dintr-o alt\u0103 tabel\u0103.",
                  "\xcen Oracle SQL, o subcerere poate fi utilizat\u0103 \u0219i \xeen clauza ORDER BY. Aceasta poate fi folosit\u0103 pentru a ordona rezultatele unei cereri \xeen func\u021bie de o condi\u021bie care depinde de datele dintr-o alt\u0103 tabel\u0103.",
                  "\xcen Oracle SQL, o subcerere nu poate fi utilizat\u0103 \xeen clauza GROUP BY. Aceasta este o restric\u021bie a limbajului SQL.",
                ],
                68: [
                  "Aceasta este o afirma\u021bie incorect\u0103. FN3 nu este inclus\u0103 \xeen FNBC. O rela\u021bie poate fi \xeen FN3 f\u0103r\u0103 a fi neap\u0103rat \u0219i \xeen FNBC.",
                  "Aceasta este o afirma\u021bie corect\u0103. O rela\u021bie poate fi \xeen FN3, dar nu \u0219i \xeen FNBC dac\u0103 con\u021bine dependen\u021be care nu au \xeen partea st\xe2ng\u0103 o supercheie.",
                  "Aceasta este o afirma\u021bie incorect\u0103. FNBC nu este inclus\u0103 \xeen FN3. O rela\u021bie poate fi \xeen FN3 f\u0103r\u0103 a fi neap\u0103rat \u0219i \xeen FNBC.",
                ],
                69: [
                  "Aceasta este o afirmatie corecta. Termenul NoSQL inseamna 'Not Only SQL', adica nu numai SQL. Acest lucru indica faptul ca sistemele NoSQL nu se limiteaza la modelele traditionale relationale oferite de SQL.",
                  "Aceasta nu este o afirmatie corecta. NoSQL nu inseamna 'No SQL'. NoSQL este un termen care se refera la sistemele de baze de date care nu se bazeaza exclusiv pe modelul relational SQL.",
                  "Aceasta nu este o afirmatie corecta. NoSQL nu inseamna 'No Old SQL'. NoSQL este un termen care se refera la sistemele de baze de date care nu se bazeaza exclusiv pe modelul relational SQL.",
                ],
                70: [
                  "Aceasta nu este o afirmatie corecta. Nu toate dependentele multivalorice X ->-> Y unde Y \u2264 X sunt triviale. O dependenta multivalorica este triviala doar daca Y este submultime a lui X.",
                  "Aceasta nu este o afirmatie corecta. O dependenta multivalorica X ->-> Y este triviala doar daca Y este submultime a lui X, indiferent daca X U Y = R.",
                  "Aceasta este o afirmatie corecta. Atat optiunea a cat si optiunea b sunt adevarate. O dependenta multivalorica X ->-> Y este triviala daca Y este submultime a lui X.",
                ],
                71: [
                  "Aceasta este o afirmatie corecta. In algebra relationala, selectia poate fi distribuita peste unire, ceea ce inseamna ca \u03c3 F (E1 \u22c3 E2) este echivalent cu \u03c3 F(E1) \u22c3 \u03c3 F(E2).",
                  "Aceasta nu este o afirmatie corecta. In algebra relationala, selectia nu poate fi distribuita peste intersectie, asa ca \u03c3 F (E1 \u22c3 E2) nu este echivalent cu \u03c3 F(E1) \u22c2 \u03c3 F(E2).",
                  "Aceasta nu este o afirmatie corecta. In algebra relationala, selectia nu poate fi distribuita peste join, asa ca \u03c3 F (E1 \u22c3 E2) nu este echivalent cu \u03c3 F(E1) \u22c8 \u03c3 F(E2).",
                ],
                72: [
                  "Aceasta nu este o afirmatie corecta. In Oracle SQL, o subcerere in clauza SELECT a unei cereri SELECT poate intoarce o singura coloana, dar poate contine mai multe linii.",
                  "Aceasta nu este o afirmatie corecta. Numarul de linii returnate de cererea principala nu influenteaza daca o subcerere poate fi utilizata in clauza SELECT.",
                  "Aceasta este o afirmatie corecta. In Oracle SQL, o subcerere in clauza SELECT a unei cereri SELECT poate intoarce o singura linie si o singura coloana.",
                ],
                73: [
                  "Aceasta nu este o afirmatie corecta. Faptul ca operatiile de scriere sunt intercalate cu operatiile de citire nu inseamna ca planificarea este neseriala.",
                  "Aceasta nu este o afirmatie corecta. Faptul ca o planificare este neseriala nu inseamna neaparat ca este si serializabila.",
                  "Aceasta este o afirmatie corecta. Planificarea este seriala deoarece tranzactiile nu au pasi intercalati.",
                ],
                74: [
                  "Aceasta nu este o afirmatie corecta. In Oracle SQL, corelarea coloanelor in clauza SELECT a unei cereri SELECT cu subcerere pe tabela temporara se face doar in clauza WHERE, nu si in clauza FROM.",
                  "Aceasta este o afirmatie corecta. In Oracle SQL, corelarea coloanelor in clauza SELECT a unei cereri SELECT cu subcerere pe tabela temporara se face in clauza WHERE a cererii.",
                  "Aceasta nu este o afirmatie corecta. In Oracle SQL, corelarea coloanelor in clauza SELECT a unei cereri SELECT cu subcerere pe tabela temporara nu se face in clauza FROM a cererii.",
                ],
                75: [
                  "Aceasta nu este o afirmatie corecta. Intr-o ierarhie de generalizare a unei entitati E in modelul EA, o instanta a unei submultimi nu se poate regasi si in alte submultimi aflate in relatie de generalizare cu E.",
                  "Aceasta nu este o afirmatie corecta. Intr-o ierarhie de generalizare a unei entitati E in modelul EA, nu toate instantele unei submultimi a lui E se regasesc in toate submultimile cat si in E.",
                  "Aceasta este o afirmatie corecta. Intr-o ierarhie de generalizare a unei entitati E in modelul EA, fiecare instanta a unei submultimi a lui E se regaseste numai in acea submultime si in E.",
                ],
                76: [
                  "Aceasta nu este o afirmatie corecta. I din ACID nu reprezinta 'Independenta'. ACID este un acronim pentru Atomicitate, Coerenta, Izolare si Durabilitate. 'I' se refera la 'Izolare'.",
                  "Aceasta nu este o afirmatie corecta. I din ACID nu reprezinta 'Inamovibilitate'. ACID este un acronim pentru Atomicitate, Coerenta, Izolare si Durabilitate. 'I' se refera la 'Izolare'.",
                  "Aceasta este o afirmatie corecta. I din ACID reprezinta 'Izolare'. Acest termen se refera la faptul ca fiecare tranzactie se executa intr-un mod izolat fata de celelalte tranzactii.",
                ],
                77: [
                  "Aceasta nu este o afirmatie corecta. Comanda nu verifica daca angajatii au primit comision. Ea calculeaza media salariului plus comisionul pentru fiecare job, indiferent daca angajatii au primit sau nu comision.",
                  "Aceasta nu este o afirmatie corecta. Comanda nu creeaza un view cu salariile medii pe fiecare job. Ea calculeaza media salariului plus comisionul pentru fiecare job, nu doar salariul mediu.",
                  "Aceasta este o afirmatie corecta. Comanda va genera o eroare de sintaxa deoarece formula avg(sal_ang+com_ang) nu este corecta. Trebuie sa fie avg(sal_ang)+avg(com_ang) pentru a calcula media separat pentru salariu si comision.",
                ],
                78: [
                  "Aceasta nu este o afirmatie corecta. Daca relatia R poate fi reconstruita prin orice metoda de join din relatiile rezultate, dar apar date redundante, atunci se pierd date.",
                  "Aceasta este o afirmatie corecta. Daca relatia R poate fi reconstruita identic prin join-ul natural al relatiilor rezultate, atunci nu se pierd date.",
                  "Aceasta nu este o afirmatie corecta. Daca relatia R nu poate fi refacuta din relatiile rezultate din descompunere, atunci se pierd date.",
                ],
                79: [
                  "Aceasta nu este o afirmatie corecta. Comanda ROLLBACK nu poate recupera datele pierdute dupa stergerea unei tabele din dictionar. Stergerea unei tabele din dictionar este definitiva si ireversibila.",
                  "Aceasta este o afirmatie corecta. Daca ai sters accidental datele dintr-o tabela, poti folosi comanda ROLLBACK pentru a le recupera. Este important de retinut ca aceasta operatiune este posibila doar daca nu ai executat deja comanda COMMIT dupa stergere.",
                  "Aceasta nu este o afirmatie corecta. Comanda ROLLBACK nu poate recupera datele sterse prin comanda TRUNCATE. Aceasta din urma sterge definitiv toate inregistrarile dintr-o tabela, fara posibilitatea de a fi recuperate.",
                ],
                80: [
                  "Aceasta este o afirmatie corecta. Atunci cand o relatie R se descompune, fiecare relatie din descompunere mosteneste proiectia lui R pe multimea de atribute a relatiei rezultate din descompunere.",
                  "Aceasta nu este o afirmatie corecta. O relatie rezultata din descompunerea relatiei R nu mosteneste toate datele lui R, ci doar proiectia lui R pe multimea de atribute a relatiei rezultate din descompunere.",
                  "Aceasta nu este o afirmatie corecta. Nu este adevarat ca fiecare relatie descompusa mosteneste toate datele relatiei R si proiectia lui R pe multimea de atribute a relatiei rezultate din descompunere.",
                ],
                81: [
                  "Aceasta nu este o afirmatie corecta. Executarea comenzii SAVE nu recupereaza datele sterse prin comanda DELETE. Este important de retinut ca pentru recuperarea datelor sterse, trebuie sa executi comanda ROLLBACK inainte de a executa comanda COMMIT.",
                  "Aceasta nu este o afirmatie corecta. Dupa executarea comenzii COMMIT, datele sterse nu mai pot fi recuperate, chiar si daca se executa comanda ROLLBACK.",
                  "Aceasta este o afirmatie corecta. Daca ai sters accidental date dintr-o tabela si nu ai executat comanda COMMIT dupa stergere, poti recupera datele prin executarea comenzii ROLLBACK.",
                ],
                82: [
                  "Aceasta nu este o afirmatie corecta. Descompunerea p = (AB, BCD, AEF, CDE) nu pastreaza dependentele functionale pe F. Verificarea dependerilor functionale arata ca nu toate dependentele din F sunt satisfacute in descompunere.",
                  "Aceasta nu este o afirmatie corecta. Algoritmul de verificare poate fi aplicat in acest caz si arata ca descompunerea p = (AB, BCD, AEF, CDE) nu pastreaza dependentele functionale pe F.",
                  "Grila e corecta conform review-ului, dar de fapt pastreaza dependentele functionale pe F - Aceasta este o afirmatie corecta. Descompunerea p = (AB, BCD, AEF, CDE) nu pastreaza dependentele functionale pe F. Algoritmul de verificare arata ca exista dependente functionale care nu sunt satisfacute in descompunere.",
                ],
                83: [
                  "Aceasta este o afirmatie corecta. Comanda TRUNCATE sterge toate inregistrarile dintr-o tabela. Este important de retinut ca aceasta operatie este ireversibila si datele nu mai pot fi recuperate.",
                  "Aceasta nu este o afirmatie corecta. Comanda TRUNCATE nu are nicio legatura cu trunchierea unei date calendaristice la un format indicat. Aceasta comanda este folosita pentru a sterge toate inregistrarile dintr-o tabela.",
                  "Aceasta nu este o afirmatie corecta. Comanda TRUNCATE nu are nicio legatura cu aproximarea unui numar zecimal fara a-l rotunji. Aceasta comanda este folosita pentru a sterge toate inregistrarile dintr-o tabela.",
                ],
                84: [
                  "Aceasta este o afirmatie corecta. Planificarea dat\u0103 nu este conflict-serializabila deoarece graful de dependenta contine cicluri. Acesta este un principiu cheie in evaluarea serializabilitatii conflictelor.",
                  "Aceasta nu este o afirmatie corecta. Faptul ca operatiile se executa pe acelasi articol nu inseamna neaparat ca planificarea nu este conflict-serializabila. Important este daca exista cicluri in graful de dependenta.",
                  "Aceasta nu este o afirmatie corecta. Intercalarea operatiilor de scriere cu cele de citire nu garanteaza ca planificarea este conflict-serializabila. Important este daca exista cicluri in graful de dependenta.",
                ],
                85: [
                  "Aceasta este o afirmatie corecta. O multime de atribute X este supercheie pentru relatia R daca X determina functional toate atributele relatiei R. Aceasta este definitia unei superchei in contextul dependentei functionale.",
                  "Aceasta nu este o afirmatie corecta. Faptul ca X este o multime minimala nu inseamna neaparat ca X este supercheie pentru relatia R. Supercheia este determinata de dependentele functionale, nu de marimea multimii de atribute.",
                  "Aceasta nu este o afirmatie corecta. O multime de atribute X este supercheie pentru relatia R daca X determina functional toate atributele relatiei R, nu daca X este o multime minimala si determina functional toate atributele relatiei R.",
                ],
                86: [
                  "Aceasta nu este o afirmatie corecta. Descompunerea p = (AB, BC, DEF, CD) nu este in FN3 cu pastrarea dependentelor functionale si proprietatea J.f.p. Nu toate dependentele functionale sunt satisfacute in descompunere.",
                  "Aceasta nu este o afirmatie corecta. Descompunerea p = (AB, BCDEF) nu este in FN3 cu pastrarea dependentelor functionale si proprietatea J.f.p. Nu toate dependentele functionale sunt satisfacute in descompunere.",
                  "Aceasta este o afirmatie corecta. Descompunerea p = (ABF, BE, DB, EA, CD) este in FN3 cu pastrarea dependentelor functionale si proprietatea J.f.p. Toate dependentele functionale sunt satisfacute in descompunere.",
                ],
                87: [
                  "Aceasta nu este o afirmatie corecta. Regurile de inferenta nu sunt folosite pentru a reduce numarul de dependente functionale. Scopul lor principal este deducerea altor dependente functionale pornind de la cele date.",
                  "Aceasta nu este o afirmatie corecta. Regurile de inferenta nu sunt utilizate pentru a descrie asocierea dintre entitati. Ele sunt folosite pentru a deduce alte dependente functionale pornind de la cele existente.",
                  "Aceasta este o afirmatie corecta. Regurile de inferenta sunt utilizate pentru a deduce alte dependente functionale pornind de la cele date. Acestea sunt esentiale in procesul de normalizare a bazelor de date.",
                ],
                88: [
                  "Aceasta nu este o afirmatie corecta. Protocolul de blocare in doua faze nu garanteaza serializabilitatea doar pentru doua tranzactii. Acesta asigura serializabilitatea la executia simultana a oricaror tranzactii.",
                  "Aceasta nu este o afirmatie corecta. Protocolul de blocare in doua faze nu este folosit doar pentru o singura tranzactie. Acesta asigura serializabilitatea la executia simultana a oricaror tranzactii.",
                  "Aceasta este o afirmatie corecta. Protocolul de blocare in doua faze garanteaza serializabilitatea la executia simultana a oricaror tranzactii. Acest protocol este folosit pentru a evita conflictele si pentru a asigura coeren\u021ba datelor.",
                ],
              },
              w = {
                2: [
                  "R\u0103spunsul 'FN2' este incorect. \xcen problema dat\u0103, forma normal\u0103 a lui \u03c1 poate fi determinat\u0103 analiz\xe2nd dependen\u021bele func\u021bionale \u0219i descompunerea dat\u0103. Alegerea 'FN2' ar \xeensemna c\u0103 rela\u021bia este \xeen cea de-a doua form\u0103 normal\u0103, \xeens\u0103 \xeen acest caz, \u03c1 satisface \u0219i a treia form\u0103 normal\u0103 \u0219i forma normal\u0103 FCNB. Trebuie s\u0103 identific\u0103m cea mai puternic\u0103 form\u0103 normal\u0103 care este satisf\u0103cut\u0103 de rela\u021bie, care \xeen acest caz este FCNB.",
                  "R\u0103spunsul 'FN3' este incorect. De\u0219i rela\u021bia \u03c1 satisface a treia form\u0103 normal\u0103, acesta nu este r\u0103spunsul corect deoarece \u03c1 este \u0219i \xeen forma normal\u0103 FCNB, care este mai puternic\u0103 dec\xe2t FN3. Forma normal\u0103 FCNB este o form\u0103 mai restrictiv\u0103 dec\xe2t FN3 \u0219i este preferabil\u0103 atunci c\xe2nd se dore\u0219te o structur\u0103 de baz\u0103 de date care reduce redundan\u021ba datelor \u0219i asigur\u0103 integritatea acestora.",
                  "R\u0103spunsul 'FNBC' este corect. \u03c1 satisface Forma Normal\u0103 Boyce-Codd (FCNB), care este cea mai puternic\u0103 dintre formele normale men\u021bionate \xeen problem\u0103. FCNB se concentreaz\u0103 pe eliminarea dependen\u021belor func\u021bionale redundante \u0219i pe asigurarea faptului c\u0103 fiecare dependen\u021b\u0103 func\u021bional\u0103 este determinat\u0103 de o cheie candidat\u0103. Acest lucru reduce riscul de anomalii \xeen inserarea, \u0219tergerea sau actualizarea datelor din baza de date.",
                ],
                3: [
                  "R\u0103spunsul este incorect. Un join nu implic\u0103 o selec\u021bie pe reuniunea R \u0219i S. Reuniunea R \u0219i S ar conduce la toate combina\u021biile posibile, care nu este scopul unui join.",
                  "R\u0103spunsul este corect. Un join pe dou\u0103 rela\u021bii R \u0219i S implic\u0103 realizarea unui produs cartezian pe R \u0219i S urmat de o selec\u021bie cu condi\u021bia F. Aceasta \xeenseamn\u0103 c\u0103 doar perechile de r\xe2nduri care satisfac condi\u021bia F sunt incluse \xeen rezultat.",
                  "R\u0103spunsul este incorect. Un join nu implic\u0103 o intersec\u021bie pe R \u0219i S cu condi\u021bia F. Intersec\u021bia ar implica doar elementele comune dintre R \u0219i S, nu \u0219i combin\u0103rile care satisfac F.",
                ],
                4: [
                  "R\u0103spunsul este corect. Cele dou\u0103 opera\u021bii sunt echivalente \u0219i reprezint\u0103 un semi-join. Un semi-join este o form\u0103 de join care combin\u0103 o opera\u021bie de join \u0219i o opera\u021bie de selec\u021bie, reduc\xe2nd volumul de date care trebuie transferat \xeentre loca\u021bii.",
                  "R\u0103spunsul este incorect. Chiar dac\u0103 cele dou\u0103 opera\u021bii pot p\u0103rea diferite la prima vedere, ele sunt de fapt echivalente \u0219i reprezint\u0103 un semi-join.",
                  "R\u0103spunsul este incorect. Cele dou\u0103 opera\u021bii nu reprezint\u0103 un join natural. Un join natural combin\u0103 automat toate perechile de coloane cu acela\u0219i nume, dar cele dou\u0103 opera\u021bii de mai sus nu fac acest lucru.",
                ],
                5: [
                  "R\u0103spunsul nu este corect. Expresia nu ar trebui s\u0103 returneze o eroare, dat fiind faptul c\u0103 toate valorile coloanei DEPTNO sunt valabile. Expresia ar trebui s\u0103 returneze o valoare pentru fiecare linie din tabela EMP.",
                  "R\u0103spunsul nu este corect. De\u0219i valorile coloanei DEPTNO sunt limitate la trei valori unice, acest lucru nu \xeenseamn\u0103 c\u0103 rezultatul ar fi limitat la trei linii. Expresia poate returna o valoare pentru fiecare linie din tabela EMP.",
                  "R\u0103spunsul este corect. Expresia poate returna o valoare pentru fiecare dintre cele 14 linii din tabela EMP, deci num\u0103rul maxim de linii pe care le-ar putea returna este 14.",
                ],
                7: [
                  "R\u0103spunsul 'ABCE' nu este corect. Cheia R trebuie s\u0103 fie minim\u0103 \u0219i s\u0103 poat\u0103 determina toate celelalte atribute. ABCE nu este minim \u0219i nu poate determina toate atributele lui R.",
                  "R\u0103spunsul 'DCE' nu este corect. De\u0219i DCE poate determina unele atribute ale lui R, nu este o cheie pentru R deoarece nu este minim \u0219i nu poate determina toate atributele lui R.",
                  "R\u0103spunsul 'CE' este corect. Cheia R este minim\u0103 \u0219i poate determina toate celelalte atribute ale lui R. Prin urmare, 'CE' este o cheie a lui R.",
                ],
                8: [
                  "Pentru a fi in FN3 trebuie sa aiba un atribut prim sau X sa fie supercheie pentru R' este un r\u0103spuns corect. Acest lucru explic\u0103 \xeen detaliu criteriile pentru ca un set de date s\u0103 fie \xeen FN3 \u0219i nu \xeen FNBC.",
                ],
                9: [
                  "R\u0103spunsul 'Produs cartezian urmat de un select' este corect. Aceasta este defini\u021bia unui join \xeen baza de date.",
                ],
                10: [
                  "R\u0103spunsul 'Nodurile sunt asimilate tabelelor si operatorilor: graful are un nod rezultat, fiind un nod tabela care reprezinta rezultatul interogarii si nodurile la care nu sosesc arcuri se numesc noduri de baza, iar celelalte noduri intermediare' este corect. Acesta este con\u021binutul nodurilor unui graf de strategie.",
                ],
                11: [
                  "Este in FNBC si daca orice dependenta multivalorica netriviala X Y are in partea stanga o supercheie' este r\u0103spunsul corect. Acest lucru descrie criteriile pentru ca o rela\u021bie s\u0103 fie \xeen FN4.",
                ],
                12: [
                  "'dependenta jonctionala care reconstruieste schema originala este una triviala si fiecare relatie in dependenta jonctionala constituie cu toate atributele sale o supercheie a relatiei originale' este r\u0103spunsul corect. Acestea sunt criteriile pentru ca o rela\u021bie s\u0103 fie \xeen FN5.",
                ],
                13: [
                  "'de sortare' este r\u0103spunsul corect. Operatorul Tau este un operator de sortare \xeen baza de date.",
                ],
                14: [
                  "Dac\u0103 se efectueaz\u0103 un join simplu pe dou\u0103 rela\u021bii R \u0219i S, rezult\u0103 un produs cartezian \xeentre R \u0219i S, urmat de o selec\u021bie aplicat\u0103 asupra rezultatului ob\u021binut, utiliz\xe2nd condi\u021bia F. Acest lucru se \xeent\xe2mpl\u0103 pentru a ob\u021bine \xeen final doar \xeenregistr\u0103rile care satisfac condi\u021bia specificat\u0103 \xeen selec\u021bie.",
                  "Varianta aleas\u0103 nu este corect\u0103. Un join simplu pe dou\u0103 rela\u021bii R \u0219i S nu implic\u0103 o selec\u021bie pe reuniunea R \u0219i S. Procesul de join const\u0103 \xeen combinarea \xeenregistr\u0103rilor din cele dou\u0103 rela\u021bii baz\xe2ndu-se pe condi\u021bia de egalitate specificat\u0103.",
                  "Varianta aleas\u0103 nu este corect\u0103. Un join simplu pe dou\u0103 rela\u021bii R \u0219i S nu implic\u0103 o intersectare \xeentre R \u0219i S. Join-ul const\u0103 \xeen combinarea \xeenregistr\u0103rilor bazat\u0103 pe o condi\u021bie de egalitate specificat\u0103, iar rezultatul con\u021bine doar \xeenregistr\u0103rile care \xeendeplinesc condi\u021bia specificat\u0103.",
                ],
                15: [
                  "Op\u021biunea nu este corect\u0103. Acesta ar fi fost adev\u0103rat dac\u0103 am fi avut 'F inclus sau egal in G+', \xeens\u0103 nu 'G inclus sau egal in F+'. Dependen\u021bele func\u021bionale \xeen G pot fi mai multe dec\xe2t cele care pot fi inferate din F, ceea ce face ca G s\u0103 nu fie neap\u0103rat echivalent cu F.",
                  "Op\u021biunea este corect\u0103. Dou\u0103 mul\u021bimi de dependen\u021be func\u021bionale F \u0219i G sunt echivalente dac\u0103 \xeenchiderile lor sunt egale, adic\u0103 F+ = G+. Acest lucru \xeenseamn\u0103 c\u0103 fiecare dependen\u021b\u0103 func\u021bional\u0103 care poate fi inferat\u0103 din F poate fi, de asemenea, inferat\u0103 din G \u0219i invers.",
                  "Op\u021biunea nu este corect\u0103. F = G nu \xeenseamn\u0103 neap\u0103rat c\u0103 F \u0219i G sunt echivalente. Echivalen\u021ba necesit\u0103 ca \xeenchiderile lor, F+ \u0219i G+, s\u0103 fie egale. Chiar dac\u0103 F \u0219i G pot avea acelea\u0219i dependen\u021be func\u021bionale, este posibil ca dependen\u021bele func\u021bionale care pot fi inferate s\u0103 fie diferite.",
                ],
                16: [
                  "'X determina func\u021bional toate atributele rela\u021biei R' nu este suficient pentru a face X o cheie. Cheia nu doar c\u0103 determin\u0103 toate celelalte atribute, dar trebuie s\u0103 fie \u0219i minim\u0103.",
                  "'X este mul\u021bime minim\u0103' nu este suficient pentru a face X o cheie. Cheia trebuie s\u0103 fie minim\u0103, dar trebuie s\u0103 \u0219i determine func\u021bional toate celelalte atribute ale rela\u021biei.",
                  "'Ambele condi\u021bii simultan' este r\u0103spunsul corect. Pentru ca un set de atribute X s\u0103 fie o cheie pentru o rela\u021bie R, X trebuie s\u0103 fie minim \u0219i s\u0103 determine func\u021bional toate celelalte atribute ale lui R.",
                ],
                17: [
                  "Op\u021biunea este corect\u0103. AD este o cheie pentru R deoarece atributul D determin\u0103 E, iar A determin\u0103 restul atributelor prin lan\u021bul de dependen\u021be func\u021bionale.",
                  "Op\u021biunea nu este corect\u0103. CD nu poate fi o cheie pentru R deoarece atributul C nu determin\u0103 niciun alt atribut \u0219i atributul D determin\u0103 doar E.",
                  "Op\u021biunea nu este corect\u0103. ACD nu este o cheie pentru R deoarece AD este suficient pentru a determina toate celelalte atribute.",
                ],
                18: [
                  "Op\u021biunea este corect\u0103. Descompunerea P = (AD, BCD) este \xeen FNCB \u0219i p\u0103streaz\u0103 proprietatea j.f.p. pentru c\u0103 nu introduce dependen\u021be func\u021bionale noi sau pierde vechi.",
                  "Op\u021biunea nu este corect\u0103. Descompunerea P = (AB, BCD) nu p\u0103streaz\u0103 proprietatea j.f.p. pentru c\u0103 nu poate exprima dependen\u021ba func\u021bional\u0103 D\u2192A.",
                  "Op\u021biunea nu este corect\u0103. Descompunerea P = (ABC, CD) nu este \xeen FNCB pentru c\u0103 AB nu este o cheie \xeen niciuna dintre subrela\u021bii.",
                ],
                19: [
                  "Gresit. Asta e corecta la varianta fara *NU*. Descompunerea P = (ABF, BE, DB, EA, CD) nu este \xeen FN3 \u0219i nu p\u0103streaz\u0103 dependen\u021bele func\u021bionale \u0219i proprietatea j.f.p. Motivul este c\u0103 multimea {ABF, BE, DB, EA, CD} nu respect\u0103 condi\u021bia ca pentru fiecare dependen\u021b\u0103 func\u021bional\u0103 X \u2192 Y din F, X trebuie s\u0103 fie super-cheie sau Y s\u0103 fac\u0103 parte dintr-o cheie. \xcen plus, descompunerea nu este f\u0103r\u0103 pierderi, deoarece nu putem reconstitui rela\u021bia original\u0103 R din aceste sub-multimi.",
                  "Probabil e corect, mai e una posibila. Descompunerea P = (AB, BCDEF) nu este \xeen FN3, dar p\u0103streaz\u0103 dependen\u021bele func\u021bionale \u0219i proprietatea j.f.p. Aceasta este de fapt r\u0103spunsul corect. Descompunerea nu satisface FN3 pentru c\u0103 exist\u0103 o dependen\u021b\u0103 tranzitiv\u0103 prin B. B determin\u0103 E, \u0219i prin E putem determina A, deci avem o dependen\u021b\u0103 tranzitiv\u0103 B \u2192 E \u2192 A.",
                  "Probabil e corect, dar mai putin probabil. Mai e una. Descompunerea P = (AB, BC, DEF, CD) poate fi \xeen FN3 \u0219i s\u0103 p\u0103streze dependen\u021bele func\u021bionale \u0219i proprietatea j.f.p. Aceasta descompunere respect\u0103 condi\u021bia ca pentru fiecare dependen\u021b\u0103 func\u021bional\u0103 X \u2192 Y din F, X s\u0103 fie super-cheie sau Y s\u0103 fac\u0103 parte dintr-o cheie. De asemenea, este f\u0103r\u0103 pierderi, ceea ce \xeenseamn\u0103 c\u0103 putem reconstitui rela\u021bia original\u0103 R folosind aceste sub-multimi.",
                ],
                20: [
                  "'\u2374 = (ABC, BCDE)' este r\u0103spunsul corect. Aceast\u0103 descompunere p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale \u0219i toate rela\u021biile rezultate sunt \xeen Forma Normal\u0103 a Treia (FN3).",
                  "'\u2374 = (AB, BC, DE)' nu este r\u0103spunsul corect. Aceast\u0103 descompunere nu p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale ale lui R.",
                  "'\u2374 = (AB, BCDE)' nu este r\u0103spunsul corect. Aceast\u0103 descompunere nu p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale ale lui R.",
                ],
                21: [
                  "Op\u021biunea este corect\u0103. Regula este valid\u0103, deoarece semnifica\u021bia este echivalent\u0103 cu diferen\u021ba \xeentre dou\u0103 mul\u021bimi.",
                  "Op\u021biunea nu este corect\u0103. Intersec\u021bia dintre dou\u0103 mul\u021bimi nu poate fi egal\u0103 cu diferen\u021ba dintre ele.",
                  "Op\u021biunea nu este corect\u0103. Uniunea dintre dou\u0103 mul\u021bimi nu poate fi egal\u0103 cu diferen\u021ba dintre ele.",
                ],
                22: [
                  "Op\u021biunea este corect\u0103. \xcentr-un graf de strategii, nodurile pot reprezenta at\xe2t tabelele, c\xe2t \u0219i operatorii. Aceasta este o caracteristic\u0103 a grafurilor de strategii utilizate \xeen optimizarea interog\u0103rilor SQL.",
                  "Op\u021biunea nu este corect\u0103. \xcentr-un graf de strategii, nodurile nu reprezint\u0103 doar tabelele, ci \u0219i operatorii.",
                  "Op\u021biunea nu este corect\u0103. \xcentr-un graf de strategii, nodurile nu reprezint\u0103 doar operatorii, ci \u0219i tabelele.",
                ],
                23: [
                  "Op\u021biunea este corect\u0103. Dac\u0103 o subcerere SQL returneaz\u0103 o pereche de coloane, \xeen clauza WHERE a cererii principale se poate folosi operatorul IN \xeentre perechile de coloane specificate \xeentre paranteze.",
                  "Op\u021biunea nu este corect\u0103. Nu pute\u021bi folosi operatorul \u201c=\u201d \xeentre perechile de coloane \xeen acest context.",
                  "Op\u021biunea nu este corect\u0103. Nu pute\u021bi folosi orice operator \xeentre perechile de coloane \xeen acest context.",
                ],
                24: [
                  "Op\u021biunea este corect\u0103. \xcentr-un join de tip JOIN ... ON, condi\u021bia de join se pune doar pe coloanele de acela\u0219i tip.",
                  "Op\u021biunea nu este corect\u0103. Condi\u021bia de join nu se pune doar pe coloanele cu acela\u0219i nume.",
                  "Op\u021biunea nu este corect\u0103. Condi\u021bia de join nu se pune doar pe coloanele cu acela\u0219i tip \u0219i nume.",
                ],
                25: [
                  "Op\u021biunea este corect\u0103. Bazele de date NoSQL permit duplicarea datelor deoarece acestea nu sunt normalizate, ceea ce le permite s\u0103 fie extrem de flexibile.",
                  "Op\u021biunea este corect\u0103. Bazele de date NoSQL permit procesarea paralel\u0103 a datelor. Aceasta este o caracteristic\u0103-cheie care le permite s\u0103 gestioneze volume mari de date \u0219i s\u0103 ofere performan\u021b\u0103 ridicat\u0103.",
                  "Op\u021biunea este corect\u0103. Bazele de date NoSQL sunt adesea recomandate pentru gestionarea documentelor datorit\u0103 flexibilit\u0103\u021bii lor \u0219i a capacitatea de a stoca diverse tipuri de date.",
                ],
                26: [
                  "'O proprietate a unei coloane' nu este r\u0103spunsul corect. \xcen modelul rela\u021bional, un atribut nu este o proprietate a unei coloane.",
                  "'O coloana a unei tabele' este r\u0103spunsul corect. \xcen modelul rela\u021bional, un atribut este echivalentul unei coloane dintr-o tabel\u0103.",
                  "'Tipul unei coloane' nu este r\u0103spunsul corect. \xcen modelul rela\u021bional, un atribut nu reprezint\u0103 tipul unei coloane.",
                ],
                27: [
                  "'FN2' nu este r\u0103spunsul corect. Rela\u021bia dat\u0103 se \xeencadreaz\u0103 \xeentr-o form\u0103 normal\u0103 mai \xeenalt\u0103.",
                  "'FN1' nu este r\u0103spunsul corect. Rela\u021bia dat\u0103 se \xeencadreaz\u0103 \xeentr-o form\u0103 normal\u0103 mai \xeenalt\u0103.",
                  "'FN3' este r\u0103spunsul corect. \xcentruc\xe2t toate dependen\u021bele func\u021bionale sunt satisf\u0103cute, rela\u021bia se \xeencadreaz\u0103 \xeen Forma Normal\u0103 a Treia (FN3).",
                ],
                28: [
                  "'Relatia R nu poate fi refacuta niciodata prin join din relatiile rezultate din descompunere' nu este corect. \xcen func\u021bie de modul \xeen care a fost efectuat\u0103 descompunerea, este posibil s\u0103 reconstituim rela\u021bia R folosind join-uri.",
                  "'Daca descompunerea este incorecta se pot pierde date si dependente din R prin descompunere' este corect. Descompunerile necorespunz\u0103toare pot duce la pierderea datelor \u0219i a dependen\u021belor din rela\u021bia original\u0103 R.",
                  "'Relatia R poate fi refacuta intotdeauna prin join din relatiile rezultate din descompunere' nu este corect. Refacerea R prin join este posibil\u0103 doar dac\u0103 descompunerea a fost efectuat\u0103 corect.",
                ],
                29: [
                  "'Multimea tuplurilor care indeplinesc constrangerile de integritate' nu este corect. Rezultatul cererii nu se limiteaz\u0103 la tupluri care \xeendeplinesc restric\u021biile de integritate.",
                  "'Multimea tuplurilor care au atribute intr-un domeniu' nu este corect. Rezultatul cererii nu se limiteaz\u0103 la tupluri cu atribute \xeentr-un anumit domeniu.",
                  "'Multimea tuplurilor care verifica una sau mai multe formule' este corect. \xcen calculul rela\u021bional pe tupluri, rezultatul unei cereri este multimea tuplurilor care \xeendeplinesc una sau mai multe formule.",
                ],
                30: [
                  "'A' este r\u0103spunsul corect. Consider\xe2nd dependen\u021bele func\u021bionale, 'A' poate fi o cheie pentru rela\u021bia R, deoarece toate celelalte atribute pot fi determinate prin 'A'.",
                  "'ADE' nu este r\u0103spunsul corect. Nu este nevoie de 'DE' pentru a forma o cheie, deoarece 'A' este suficient pentru a determina toate celelalte atribute.",
                  "'AD' nu este r\u0103spunsul corect. Nu este necesar 'D' pentru a forma o cheie, deoarece 'A' este suficient pentru a determina toate celelalte atribute.",
                ],
                31: [
                  "'Multimi de date care contin valori duplicate' este r\u0103spunsul corect. Multiset-urile sunt colec\u021bii care permit valorile duplicate.",
                  "'O relatie care are mai multe tupluri unicat' nu este r\u0103spunsul corect. Multiseturile nu necesit\u0103 unicitate a tuplurilor.",
                  "'O relatie care contine tupluri duplicate' nu este r\u0103spunsul corect. De\u0219i multiseturile permit duplicate, nu se refer\u0103 strict la rela\u021bii cu tupluri duplicate.",
                ],
                32: [
                  "'Un identificator de unicitate pentru valorile nenule ale atributului respectiv' nu este r\u0103spunsul corect. O cheie \xeen modelul rela\u021bional nu se refer\u0103 doar la valorile nenule ale unui atribut.",
                  "'Un identificator unic numai pentru valorile atributului pe care este creata' nu este r\u0103spunsul corect. O cheie \xeen modelul rela\u021bional nu se refer\u0103 doar la valorile unui anumit atribut.",
                  "'O multime minimala de atribute care identifica unic fiecare tuplu al unei relatii' este r\u0103spunsul corect. O cheie \xeen modelul rela\u021bional identific\u0103 unic fiecare tuplu al unei rela\u021bii, folosind un set minimal de atribute.",
                ],
                33: [
                  "'Nu se poate aplica algoritmul de verificare in acest caz' nu este r\u0103spunsul corect. Algoritmul de verificare se poate aplica \xeen acest caz.",
                  "'Nu pastreaza dependentele functionale pe F' este r\u0103spunsul corect. Descompunerea dat\u0103 nu p\u0103streaz\u0103 dependen\u021bele func\u021bionale din setul F.",
                  "'Pastreaza dependentele functionale pe F' nu este r\u0103spunsul corect. Descompunerea dat\u0103 nu p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale din setul F.",
                ],
                34: [
                  "'O asociere dintre mai multe entitati' este r\u0103spunsul corect. O rela\u021bie logic\u0103 reprezint\u0103 o asocia\u021bie sau o leg\u0103tur\u0103 \xeentre mai multe entit\u0103\u021bi.",
                  "'Legatura dintre atributele entitatii' nu este r\u0103spunsul corect. O rela\u021bie logic\u0103 se refer\u0103 la leg\u0103turile dintre entit\u0103\u021bi, nu doar la atributele entit\u0103\u021bii.",
                  "'O descriere a unui atribut' nu este r\u0103spunsul corect. O rela\u021bie logic\u0103 nu se refer\u0103 la descrierea unui atribut.",
                ],
                35: [
                  "'Modelul ierarhic' nu este r\u0103spunsul corect. Modelul ierarhic organizeaz\u0103 datele \xeen structuri de tip arbore, nu \xeen tabele.",
                  "'Modelul relational' este r\u0103spunsul corect. Modelul rela\u021bional organizeaz\u0103 datele \xeen tabele sau rela\u021bii.",
                  "'Ambele variante sunt corecte' nu este r\u0103spunsul corect. Doar modelul rela\u021bional organizeaz\u0103 datele sub form\u0103 de tabele.",
                ],
                36: [
                  "'Variabile tuplu, constante si operatori' este r\u0103spunsul corect. O formul\u0103 \xeen modelul rela\u021bional este compus\u0103 din variabile tuplu, constante \u0219i operatori.",
                  "'Numai din variabile tuplu si constante' nu este r\u0103spunsul corect. O formul\u0103 \xeen modelul rela\u021bional include \u0219i operatori, nu doar variabile tuplu \u0219i constante.",
                  "'Numai din atributele unei relatii' nu este r\u0103spunsul corect. O formul\u0103 \xeen modelul rela\u021bional include variabile tuplu, constante \u0219i operatori, nu doar atributele unei rela\u021bii.",
                ],
                37: [
                  "R\u0103spunsul t\u0103u este incorect. Operatorul gamma nu este folosit doar pentru gruparea rela\u021biei R dup\u0103 atributele din list\u0103. \xcen timp ce face acest lucru, operatorul \u03b3 realizeaz\u0103 \u0219i opera\u021biuni la nivel de grup pe baza func\u021biilor specificate.",
                  "R\u0103spunsul t\u0103u este incorect. Operatorul gamma nu este folosit doar pentru utilizarea de func\u021bii la nivel de grup. \xcen timp ce face acest lucru, operatorul \u03b3 realizeaz\u0103 \u0219i gruparea rela\u021biei R dup\u0103 atributele din list\u0103.",
                  "Felicit\u0103ri! R\u0103spunsul t\u0103u este corect. Operatorul \u03b3 (gamma) din algebr\u0103 rela\u021bional\u0103 este utilizat pentru a grupa rela\u021bia R dup\u0103 atributele din list\u0103 \u0219i pentru a utiliza func\u021bii la nivel de grup.",
                ],
                38: [
                  "R\u0103spunsul t\u0103u este incorect. Modelul de date nu este descris de nivelul intern de organizare a datelor. Acesta se refer\u0103 mai mult la modul \xeen care datele sunt stocate fizic \xeen sistem, nu la structura lor logic\u0103.",
                  "R\u0103spunsul t\u0103u este incorect. Modelul de date nu este descris de nivelul extern de acces la date. Acesta se refer\u0103 la modul \xeen care utilizatorii interac\u021bioneaz\u0103 cu datele, nu la structura lor logic\u0103.",
                  "Excelent! Ai r\u0103spuns corect. Modelul de date este descris de nivelul conceptual al datelor, ceea ce \xeenseamn\u0103 c\u0103 \xee\u021bi ofer\u0103 o viziune global\u0103 asupra structurii logice a datelor.",
                ],
                39: [
                  "R\u0103spunsul t\u0103u este par\u021bial corect. \xcentr-adev\u0103r, cheia unei rela\u021bii reprezint\u0103 o mul\u021bime minim\u0103 de atribute care identific\u0103 \xeen mod unic un tuplu. Dar aceasta este \u0219i o constr\xe2ngere de integritate, pentru c\u0103 asigur\u0103 unicitatea \u0219i nu permite valori nule.",
                  "R\u0103spunsul t\u0103u este par\u021bial corect. Cheia unei rela\u021bii este de fapt o constr\xe2ngere de integritate, dar nu este singura sa func\u021bie. Ea serve\u0219te \u0219i ca o mul\u021bime minim\u0103 de atribute care identific\u0103 \xeen mod unic un tuplu \xeentr-o rela\u021bie.",
                  "Bravo! Ai r\u0103spuns corect. Cheia unei rela\u021bii \xeen modelul rela\u021bional este o mul\u021bime minim\u0103 de atribute care identific\u0103 \xeen mod unic un tuplu \u0219i, \xeen acela\u0219i timp, este o constr\xe2ngere de integritate.",
                ],
                40: [
                  "Ai r\u0103spuns corect! \xcentr-adev\u0103r, atunci c\xe2nd o rela\u021bie se descompune \xeen mai multe rela\u021bii, acestea pot avea at\xe2t atribute comune, c\xe2t \u0219i diferite.",
                  "R\u0103spunsul t\u0103u este incorect. Rela\u021biile ob\u021binute din descompunere nu trebuie neap\u0103rat s\u0103 aib\u0103 atribute comune. Ele pot avea at\xe2t atribute comune, c\xe2t \u0219i diferite.",
                  "R\u0103spunsul t\u0103u este incorect. Rela\u021biile ob\u021binute din descompunere nu trebuie neap\u0103rat s\u0103 aib\u0103 atribute diferite. Ele pot avea at\xe2t atribute comune, c\xe2t \u0219i diferite.",
                ],
                41: [
                  "R\u0103spunsul t\u0103u este incorect. Inchiderea multimii de atribute D+ nu este R. \xcentruc\xe2t avem regula D \u2192 E, atributul E face parte din inchiderea lui D, dar nu toate atributele R.",
                  "R\u0103spunsul t\u0103u este incorect. Inchiderea multimii de atribute D+ nu este BE. \xcentruc\xe2t avem regula D \u2192 E, atributul E face parte din inchiderea lui D, dar B nu.",
                  "Felicit\u0103ri! Ai r\u0103spuns corect. Inchiderea multimii de atribute D+ este \xeentr-adev\u0103r DE, deoarece exist\u0103 o dependen\u021b\u0103 func\u021bional\u0103 direct\u0103 \xeentre D \u0219i E.",
                ],
                42: [
                  "R\u0103spunsul t\u0103u este par\u021bial corect. \xcentr-adev\u0103r, unele atribute ale unei entit\u0103\u021bi pot fi reclasificate ca entit\u0103\u021bi \xeen anumite circumstan\u021be, dar acest lucru nu este limitat la situa\u021bia unei asocieri multi-unu.",
                  "R\u0103spunsul t\u0103u este par\u021bial corect. \xcentr-adev\u0103r, atributele multivalorice trebuie reclasificate ca entit\u0103\u021bi, dar acest lucru nu este singura regul\u0103 de modelare \xeen modelul Entitate-Asociere.",
                  "Ai r\u0103spuns corect! \xcen modelul Entitate-Asociere, atributele unei entit\u0103\u021bi care au o asociere multi-unu cu o alt\u0103 entitate pot fi reclasificate ca entit\u0103\u021bi, iar atributele multivalorice trebuie reclasificate ca entit\u0103\u021bi.",
                ],
                43: [
                  "Ai r\u0103spuns corect! Transformarea din modelul EA \xeen MR pentru entit\u0103\u021bile AUTORI \u0219i CARTI, aflate \xeentr-o rela\u021bie 1:N (1 pentru autori), va rezulta \xeen rela\u021biile CARTI(id_carte, titlu, editura, id_autor) \u0219i AUTORI(id_autor, nume, adresa).",
                  "R\u0103spunsul t\u0103u este incorect. \xcen transformarea din modelul EA \xeen MR, id_carte nu ar trebui s\u0103 apar\u0103 \xeen AUTORI, deoarece exist\u0103 o rela\u021bie de 1 la N \xeentre AUTORI \u0219i CARTI, ceea ce \xeenseamn\u0103 c\u0103 un autor poate avea mai multe c\u0103r\u021bi.",
                  "R\u0103spunsul t\u0103u este incorect. \xcen transformarea din modelul EA \xeen MR, numele autorului nu ar trebui s\u0103 apar\u0103 \xeen CARTI. \xcen schimb, CARTI ar trebui s\u0103 aib\u0103 un id_autor pentru a realiza leg\u0103tura cu tabelul AUTORI.",
                ],
                44: [
                  "R\u0103spunsul t\u0103u este incorect. De\u0219i este adev\u0103rat c\u0103 D->A are \xeen partea dreapt\u0103 atributul prim A, acest fapt nu este suficient pentru a garanta c\u0103 rela\u021bia este \xeen forma normal\u0103 FNBC. FNBC necesit\u0103 ca toate dependen\u021bele s\u0103 aib\u0103 o supercheie \xeen partea st\xe2ng\u0103, iar D->A violeaz\u0103 aceast\u0103 condi\u021bie.",
                  "R\u0103spunsul t\u0103u este incorect. De\u0219i cheia este \u0219i supercheie a rela\u021biei, acest fapt nu garanteaz\u0103 c\u0103 rela\u021bia este \xeen forma normal\u0103 FNBC. Pentru ca o rela\u021bie s\u0103 fie \xeen FNBC, toate dependen\u021bele func\u021bionale trebuie s\u0103 aib\u0103 o supercheie \xeen partea st\xe2ng\u0103, iar D->A nu \xeendepline\u0219te aceast\u0103 cerin\u021b\u0103.",
                  "R\u0103spunsul t\u0103u este corect. Rela\u021bia nu este \xeen forma normal\u0103 FNBC deoarece D->A violeaz\u0103 condi\u021bia de supercheie. \xcen FNBC, partea st\xe2ng\u0103 a fiec\u0103rei dependen\u021be func\u021bionale trebuie s\u0103 fie o supercheie. D nu este o supercheie, deci aceasta este o \xeenc\u0103lcare a regulii \u0219i rela\u021bia nu este \xeen FNBC.",
                ],
                45: [
                  "R\u0103spunsul t\u0103u este incorect. \xcen FN3, dac\u0103 avem o dependen\u021b\u0103 netrivial\u0103 X \u2192 A, X trebuie s\u0103 fie o supercheie pentru R sau A trebuie s\u0103 fie un atribut prim.",
                  "R\u0103spunsul t\u0103u este incorect. \xcen FN3, dac\u0103 avem o dependen\u021b\u0103 netrivial\u0103 X \u2192 A, X trebuie s\u0103 fie o supercheie pentru R sau A trebuie s\u0103 fie un atribut prim.",
                  "Ai r\u0103spuns corect! \xcen FN3, dac\u0103 avem o dependen\u021b\u0103 netrivial\u0103 X \u2192 A, X trebuie s\u0103 fie o supercheie pentru R sau A trebuie s\u0103 fie un atribut prim. Aceasta este defini\u021bia corect\u0103 a FN3.",
                ],
                46: [
                  "R\u0103spunsul t\u0103u este incorect. O rela\u021bie nu poate fi \xeen FN2 dac\u0103 nu este deja \xeen FN1, deoarece fiecare form\u0103 normal\u0103 successiv\u0103 presupune \xeendeplinirea condi\u021biilor formei anterioare.",
                  "R\u0103spunsul t\u0103u este incorect. Rela\u021bia este \xeen FN1, dar este de asemenea \u0219i \xeen FN2. FN1 elimin\u0103 redundan\u021bele prin asigurarea faptului c\u0103 toate atributele non-cheie sunt dependente complet de cheie. FN2 merge mai departe prin a se asigura c\u0103 nu exist\u0103 dependen\u021be par\u021biale.",
                  "Ai r\u0103spuns corect! Rela\u021bia este \xeen FN1 \u0219i FN2. \xcen FN1, toate atributele non-cheie sunt dependente complet de cheie. FN2 merge mai departe \u0219i asigur\u0103 c\u0103 nu exist\u0103 dependen\u021be par\u021biale \xeen rela\u021bie.",
                ],
                54: [
                  "Ai r\u0103spuns corect! Av\xe2nd \xeen vedere dependen\u021bele func\u021bionale, exist\u0103 trei chei candidate distincte pentru rela\u021bie: AB, AC, \u0219i AH.",
                  "R\u0103spunsul t\u0103u este incorect. Num\u0103rul de chei distincte ale rela\u021biei este 3, nu 2. Av\xe2nd \xeen vedere dependen\u021bele func\u021bionale, putem identifica AB, AC \u0219i AH ca chei candidate.",
                  "R\u0103spunsul t\u0103u este incorect. Num\u0103rul de chei distincte ale rela\u021biei este 3, nu 1. Av\xe2nd \xeen vedere dependen\u021bele func\u021bionale, putem identifica AB, AC \u0219i AH ca chei candidate.",
                ],
                55: [
                  "R\u0103spunsul t\u0103u este incorect. Rela\u021bia nu este nici \xeen FN3, nici \xeen FNBC. Avem o dependen\u021b\u0103 tranzitiv\u0103, B \u2192 D, care nu respect\u0103 FN3, \u0219i de asemenea H \u2192 C, care nu respect\u0103 FNBC.",
                  "R\u0103spunsul t\u0103u este incorect. Rela\u021bia nu este \xeen FN3. Exist\u0103 o dependen\u021b\u0103 tranzitiv\u0103, B \u2192 D, care nu respect\u0103 FN3.",
                  "Ai r\u0103spuns corect! Rela\u021bia nu este nici m\u0103car \xeen FN3. Acest lucru se datoreaz\u0103 faptului c\u0103 exist\u0103 o dependen\u021b\u0103 tranzitiv\u0103, B \u2192 D, care \xeencalc\u0103 FN3.",
                ],
                56: [
                  "R\u0103spunsul t\u0103u este incorect. Dependen\u021ba B \u2192 C se poate deduce din B \u2192 H \u0219i H \u2192 C.",
                  "Ai r\u0103spuns corect! Dependen\u021ba E \u2192 D nu se poate deduce din setul de dependen\u021be func\u021bionale dat.",
                  "R\u0103spunsul t\u0103u este incorect. Dependen\u021ba C \u2192 D se poate deduce din C \u2192 B \u0219i B \u2192 D.",
                ],
                57: [
                  "R\u0103spunsul t\u0103u este incorect. Descompunerea \u03c1 = (ABC, CDEH) nu p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale. De exemplu, B \u2192 H nu poate fi aplicat\u0103 \xeen niciuna dintre rela\u021bii.",
                  "R\u0103spunsul t\u0103u este incorect. Descompunerea \u03c1 = (ABH, CDE) nu p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale. De exemplu, C \u2192 B nu poate fi aplicat\u0103 \xeen niciuna dintre rela\u021bii.",
                  "Ai r\u0103spuns corect! Descompunerea \u03c1 = (AE, BCDH) p\u0103streaz\u0103 toate dependen\u021bele func\u021bionale.",
                ],
                58: [
                  "R\u0103spunsul t\u0103u este incorect. Descompunerea \u03c1 = (ABC, CDEH) nu are proprietatea de join f\u0103r\u0103 pierderi, deoarece nu exist\u0103 un atribut comun \xeentre cele dou\u0103 rela\u021bii care s\u0103 fie o cheie pentru vreuna dintre ele.",
                  "Ai r\u0103spuns corect! Descompunerea \u03c1 = (ABCE, BCHD) are proprietatea de join f\u0103r\u0103 pierderi. Aceasta se datoreaz\u0103 faptului c\u0103 BC este un atribut comun care este o cheie pentru a doua rela\u021bie.",
                  "R\u0103spunsul t\u0103u este incorect. Descompunerea \u03c1 = (ABCH, CDE) nu are proprietatea de join f\u0103r\u0103 pierderi. Atributul C comun nu este o cheie pentru a doua rela\u021bie.",
                ],
                59: [
                  "Ai r\u0103spuns corect! Descompunerea \u03c1 = (AE, BCDH) p\u0103streaz\u0103 dependen\u021bele func\u021bionale.",
                  "R\u0103spunsul t\u0103u este incorect. Descompunerea \u03c1 = (AE, BCDH) nu are proprietatea de join f\u0103r\u0103 pierderi.",
                  "R\u0103spunsul t\u0103u este incorect. De\u0219i descompunerea \u03c1 = (AE, BCDH) p\u0103streaz\u0103 dependen\u021bele func\u021bionale, nu are proprietatea de join f\u0103r\u0103 pierderi.",
                ],
                60: [
                  "Ai r\u0103spuns corect! \xcen sisteme NoSQL cu stocare cheie-valoare, opera\u021biile principale sunt primirea unei chei \u0219i returnarea unei liste de valori asociate.",
                  "R\u0103spunsul t\u0103u este incorect. Reunirea ie\u0219irilor func\u021biei Reduce este specific\u0103 modelului de programare MapReduce, nu sistemelor NoSQL cu stocare cheie-valoare.",
                  "R\u0103spunsul t\u0103u este incorect. \xcemp\u0103r\u021birea unei probleme \xeen subprobleme este o strategie general\u0103 de rezolvare a problemelor \u0219i nu este specific\u0103 sistemelor NoSQL cu stocare cheie-valoare.",
                ],
                61: [
                  "Ai r\u0103spuns corect! Atributele nu se pot ata\u0219a la ierarhii. \xcen modelul Entitate-Asociere, atributele sunt ata\u0219ate la entit\u0103\u021bi sau la asocieri, nu la ierarhii. Ierarhiile sunt folosite pentru a modela rela\u021bii de tipul \u201eeste-un\u201d \xeentre diferite tipuri de entit\u0103\u021bi.",
                  "Atributele pot fi ata\u0219ate la entit\u0103\u021bi. Fiecare entitate dintr-un model Entitate-Asociere poate avea unul sau mai multe atribute care definesc propriet\u0103\u021bi sau caracteristici ale acestei entit\u0103\u021bi.",
                  "Atributele pot fi ata\u0219ate la asocieri. Asocierile reprezint\u0103 rela\u021bii \xeentre dou\u0103 sau mai multe entit\u0103\u021bi \u0219i pot avea atribute proprii care descriu mai detaliat aceste rela\u021bii.",
                ],
                62: [
                  "Ai r\u0103spuns corect! Planificarea se refer\u0103 \xeentr-adev\u0103r la ordinea \xeen care sunt executa\u021bi de SGBD pa\u0219ii elementari ai unui set de tranzac\u021bii.",
                ],
                63: [
                  "Ai r\u0103spuns corect! D din abrevierea ACID se refer\u0103 la proprietatea de durabilitate, care garanteaz\u0103 c\u0103 odat\u0103 ce o tranzac\u021bie a fost angajat\u0103, ea va r\u0103m\xe2ne astfel, chiar \u0219i \xeen cazul unei c\u0103deri de sistem.",
                ],
                64: [
                  "Ai r\u0103spuns corect! I din abrevierea ACID se refer\u0103 la proprietatea de izolare, care asigur\u0103 c\u0103 execu\u021bia concurent\u0103 a tranzac\u021biilor are acela\u0219i rezultat ca \u0219i execu\u021bia lor secven\u021bial\u0103.",
                ],
                65: [
                  "Ai r\u0103spuns corect! Consisten\u021ba eventual\u0103 se refer\u0103 la conceptul c\u0103 toate schimb\u0103rile se vor propaga \xeen cele din urm\u0103 la toate \xeenregistr\u0103rile, aduc\xe2nd sistemul \xeentr-un stat de consisten\u021b\u0103.",
                ],
                66: [
                  "Ai r\u0103spuns corect! JSON \xeenseamn\u0103 JavaScript Object Notation \u0219i este un format de schimb de date u\u0219or de citit \u0219i de scris pentru oameni, dar u\u0219or de analizat \u0219i generat pentru ma\u0219ini.",
                ],
                67: [
                  "R\u0103spunsul 'Unara' nu este corect. Termenul 'unara' se refer\u0103 la o asociere cu o singur\u0103 ramur\u0103, dar \xeen \xeentrebare se vorbe\u0219te despre o asociere cu dou\u0103 ramuri.",
                  "R\u0103spunsul 'Binara' nu este corect. De\u0219i termenul 'binar' se refer\u0103 la o asociere cu dou\u0103 ramuri, \xeentrebarea se refer\u0103 la o asociere care poate avea ambele tipuri de ramuri, unare \u0219i binare.",
                  "R\u0103spunsul 'Ambele r\u0103spunsuri sunt corecte' este corect. De fapt, o asociere poate avea una sau dou\u0103 ramuri, astfel c\u0103 poate fi at\xe2t unar\u0103 c\xe2t \u0219i binar\u0103, \xeen func\u021bie de context.",
                ],
                68: [
                  "R\u0103spunsul 'Poate fi corect\u0103 sau gre\u0219it\u0103 \xeen func\u021bie de context' nu este corect. Diagrama este gre\u0219it\u0103 deoarece entit\u0103\u021bile INGINER \u0219i MUNCITOR nu pot fi fii ale entit\u0103\u021bii ANGAJAT f\u0103r\u0103 a avea un atribut de identificare unic, care s\u0103 le disting\u0103.",
                  "R\u0103spunsul 'Este gre\u0219it\u0103' este corect. Diagrama este gre\u0219it\u0103 deoarece entit\u0103\u021bile INGINER \u0219i MUNCITOR nu pot fi fii ale entit\u0103\u021bii ANGAJAT f\u0103r\u0103 a avea un atribut de identificare unic, care s\u0103 le disting\u0103.",
                  "R\u0103spunsul 'Este corect\u0103' nu este corect. Diagrama este gre\u0219it\u0103 deoarece entit\u0103\u021bile INGINER \u0219i MUNCITOR nu pot fi fii ale entit\u0103\u021bii ANGAJAT f\u0103r\u0103 a avea un atribut de identificare unic, care s\u0103 le disting\u0103.",
                ],
                69: [
                  "R\u0103spunsul '6' nu este corect. De\u0219i fiecare entitate are dou\u0103 atribute (identificare \u0219i descriere), trebuie s\u0103 ne amintim \u0219i de asocierile care vor avea atribute separate. Prin urmare, num\u0103rul total de atribute nu va fi 6.",
                  "R\u0103spunsul '9' este corect. Fiecare dintre cele 3 entit\u0103\u021bi are 2 atribute, rezult\xe2nd 6 atribute. Apoi, av\xe2nd \xeen vedere asocierile care se adaug\u0103 la tabele, avem 3 atribute suplimentare, ajung\xe2nd astfel la un total de 9 atribute.",
                  "R\u0103spunsul '10' nu este corect. Este posibil s\u0103 fi ad\u0103ugat gre\u0219it num\u0103rul de atribute rezultate din asocieri. Totalul corect este 9.",
                ],
                70: [
                  "R\u0103spunsul 'Macar o ramura obligatorie' nu este corect. Asocierile nu necesit\u0103 obligatoriu o ramur\u0103 obligatorie. Aceasta depinde de rela\u021bia specific\u0103 dintre entit\u0103\u021bi.",
                  "R\u0103spunsul 'Macar o ramura multi' nu este corect. Asocierile nu necesit\u0103 obligatoriu o ramur\u0103 multi. Aceasta depinde de rela\u021bia specific\u0103 dintre entit\u0103\u021bi.",
                  "R\u0103spunsul 'Ambele r\u0103spunsuri sunt gre\u0219ite' este corect. Niciuna dintre op\u021biunile 'Macar o ramura obligatorie' \u0219i 'Macar o ramura multi' nu sunt necesare pentru o asociere. Asocierile pot fi flexibile, \xeen func\u021bie de rela\u021bia specific\u0103 dintre entit\u0103\u021bi.",
                ],
                71: [
                  "Ai r\u0103spuns corect! La transformarea unei ierarhii de generalizare, criteriul de clasificare devine o coloan\u0103 la tat\u0103. Acest criteriu este folosit pentru a determina tipul fiec\u0103rei instan\u021be a entit\u0103\u021bii generale.",
                  "Nu este corect. La transformarea unei ierarhii de generalizare, criteriul de clasificare nu devine o coloan\u0103 la fiecare fiu. Acest criteriu este ata\u0219at tat\u0103lui, nu fiec\u0103rui fiu \xeen parte.",
                  "Nu este corect. La transformarea unei ierarhii de generalizare, criteriul de clasificare nu devine un tuplu. Criteriul de clasificare este reprezentat ca o coloan\u0103 \xeen tabela tat\u0103lui.",
                ],
                81: [
                  "R\u0103spunsul t\u0103u nu este corect. Multimea AB nu este cheie pentru rela\u021bia R. Atributele B \u0219i A nu determin\u0103 toate celelalte atribute ale rela\u021biei.",
                  "Ai r\u0103spuns corect! Multimea AB nu este cheie pentru rela\u021bia R. Atributele B \u0219i A nu determin\u0103 toate celelalte atribute ale rela\u021biei.",
                  "R\u0103spunsul t\u0103u nu este corect. Dac\u0103 o multime de atribute este cheie sau nu pentru o rela\u021bie nu depinde de context, ci de setul de dependen\u021be func\u021bionale asociat rela\u021biei.",
                ],
                82: [
                  "R\u0103spunsul \u201eAB \u2192 C\u201d este incorect. Uit\xe2ndu-ne la mul\u021bimea de dependen\u021be F, nu putem deduce c\u0103 AB implic\u0103 C. Din F, putem vedea c\u0103 A implic\u0103 B, \xeens\u0103 nu avem nicio dependen\u021b\u0103 direct\u0103 care s\u0103 ne arate c\u0103 AB implic\u0103 C. Mai mult, folosind regula de transitivitate, tot nu putem deduce dependen\u021ba AB \u2192 C.",
                  "R\u0103spunsul \u201eAC \u2192 B\u201d este corect. Din mul\u021bimea de dependen\u021be F, putem deduce c\u0103 A implic\u0103 B (A \u2192 B). De asemenea, din C \u2192 D \u0219i D \u2192 E, putem deduce c\u0103 C implic\u0103 E (C \u2192 E), iar E implic\u0103 C (E \u2192 C). Cu aceste informa\u021bii, putem folosi regula de transitivitate pentru a deduce c\u0103 AC implic\u0103 B (AC \u2192 B).",
                  "R\u0103spunsul \u201eED \u2192 B\u201d este incorect. Analiz\xe2nd mul\u021bimea de dependen\u021be F, nu exist\u0103 o cale prin care s\u0103 deducem c\u0103 ED implic\u0103 B. Avem E \u2192 C \u0219i D \u2192 E, \xeens\u0103 acestea nu ne ajut\u0103 s\u0103 stabilim o leg\u0103tur\u0103 \xeentre ED \u0219i B. Regula de transitivitate nu ne permite s\u0103 deducem dependen\u021ba ED \u2192 B din dependen\u021bele date.",
                ],
                83: [
                  "R\u0103spunsul \u201e1\u201d este incorect. Dac\u0103 analiz\u0103m mul\u021bimea de dependen\u021be F = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}, putem vedea c\u0103 exist\u0103 mai multe combina\u021bii de atribute care pot func\u021biona ca chei pentru rela\u021bia R. Cheile candidate sunt AC, AD \u0219i AE. Prin urmare, rela\u021bia R nu are doar o singur\u0103 cheie distinct\u0103.",
                  "R\u0103spunsul \u201e2\u201d este incorect. A\u0219a cum am men\u021bionat mai devreme, exist\u0103 trei combina\u021bii de atribute care pot func\u021biona ca chei pentru rela\u021bia R, \u0219i anume AC, AD \u0219i AE. Num\u0103rul de chei distincte este, prin urmare, mai mare de 2.",
                  "R\u0103spunsul \u201e3\u201d este corect. Analiz\xe2nd mul\u021bimea de dependen\u021be F = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}, putem identifica trei combina\u021bii de atribute care pot func\u021biona ca chei pentru rela\u021bia R: AC, AD \u0219i AE. Fiecare dintre aceste combina\u021bii de atribute poate identifica \xeen mod unic \xeenregistr\u0103rile \xeen rela\u021bia R, ceea ce \xeenseamn\u0103 c\u0103 exist\u0103 trei chei distincte.",
                ],
                84: [
                  "R\u0103spunsul t\u0103u nu este corect. Multimea {B, D, E} nu con\u021bine toate atributele prime ale lui R. Un atribut prim este un atribut care face parte dintr-o cheie a rela\u021biei.",
                  "R\u0103spunsul t\u0103u nu este corect. Multimea {A, B, C} nu con\u021bine toate atributele prime ale lui R. Un atribut prim este un atribut care face parte dintr-o cheie a rela\u021biei.",
                  "Ai r\u0103spuns corect! Multimea {A, C, D} con\u021bine toate atributele prime ale lui R. Un atribut prim este un atribut care face parte dintr-o cheie a rela\u021biei.",
                ],
                85: [
                  "Ai r\u0103spuns corect! Proiectia multimii de dependente F pe ABED contine dependentele {E\u2192D, D\u2192E}. Acestea sunt dependen\u021bele care implic\u0103 doar atribute din multimea ABED.",
                  "R\u0103spunsul t\u0103u nu este corect. Proiectia multimii de dependente F pe ABED nu contine dependenta A\u2192B, deoarece B nu face parte din multimea ABED.",
                  "R\u0103spunsul t\u0103u nu este corect. Proiectia multimii de dependente F pe ABED nu contine dependenta A\u2192E, deoarece aceast\u0103 dependen\u021b\u0103 nu exist\u0103 \xeen multimea de dependen\u021be F.",
                ],
                86: [
                  "R\u0103spunsul 'Doar JFP' nu este corect. Descompunerea \u03c3 = (AB, CDE) nu are proprietatea de a fi \xeen Forma Normal\u0103 Jordan (JFP), deoarece dependen\u021bele func\u021bionale nu sunt p\u0103strate \xeen totalitate. Pentru ca o descompunere s\u0103 fie \xeen JFP, aceasta trebuie s\u0103 satisfac\u0103 at\xe2t proprietatea de p\u0103strare a dependen\u021belor, c\xe2t \u0219i proprietatea f\u0103r\u0103 pierdere a informa\u021biei (Lossless Join).",
                  "R\u0103spunsul 'Doar p\u0103streaz\u0103 dependen\u021bele' este corect. \xcen descompunerea \u03c3 = (AB, CDE), toate dependen\u021bele func\u021bionale din F pot fi deduse din cele dou\u0103 submul\u021bimi, AB \u0219i CDE. Cu toate acestea, descompunerea nu este \xeen Forma Normal\u0103 Jordan (JFP) deoarece nu satisface \u0219i proprietatea f\u0103r\u0103 pierdere a informa\u021biei (Lossless Join).",
                  "R\u0103spunsul 'Ambele' nu este corect. De\u0219i descompunerea \u03c3 = (AB, CDE) p\u0103streaz\u0103 dependen\u021bele func\u021bionale, nu satisface proprietatea f\u0103r\u0103 pierdere a informa\u021biei (Lossless Join), deci nu poate fi considerat\u0103 a fi \xeen Forma Normal\u0103 Jordan (JFP). Pentru ca o descompunere s\u0103 fie \xeen JFP, aceasta trebuie s\u0103 satisfac\u0103 ambele propriet\u0103\u021bi.",
                ],
                87: [
                  "R\u0103spunsul t\u0103u este corect. Descompunerea \u03c1 = (AB, CE, DE, CD, AE) are propriet\u0103\u021bile JFP \u0219i p\u0103streaz\u0103 dependen\u021bele func\u021bionale. JFP \xeenseamn\u0103 c\u0103 fiecare dependen\u021b\u0103 din F poate fi aplicat\u0103 la una din sub scheme \u0219i nu genereaz\u0103 dependen\u021be noi. De asemenea, toate dependen\u021bele din F sunt prezente \u0219i dup\u0103 descompunere.",
                  "R\u0103spunsul t\u0103u este incorect. Aleg\xe2nd doar op\u021biunea \u201eDoar JFP\u201d nu este suficient\u0103 pentru a caracteriza corect descompunerea. Este adev\u0103rat c\u0103 descompunerea are proprietatea JFP, \xeens\u0103 ea de asemenea p\u0103streaz\u0103 \u0219i dependen\u021bele. Astfel, este necesar s\u0103 recunoa\u0219tem ambele propriet\u0103\u021bi pentru ca r\u0103spunsul s\u0103 fie corect.",
                  "R\u0103spunsul t\u0103u este incorect. Aleg\xe2nd doar op\u021biunea \u201eDoar p\u0103streaz\u0103 dependen\u021bele\u201d nu ofer\u0103 o descriere complet\u0103 a propriet\u0103\u021bilor descompunerii. Descompunerea p\u0103streaz\u0103 dependen\u021bele, dar are \u0219i proprietatea JFP. Trebuie s\u0103 se recunoasc\u0103 ambele propriet\u0103\u021bi pentru ca r\u0103spunsul s\u0103 fie complet \u0219i corect.",
                ],
              },
              D = {
                1: {
                  question: "Operatorul de mai sus are ca efect:",
                  options: [
                    { text: "Proiectia relatiei R dupa atributele din lista" },
                    {
                      text: "Ordonarea relatiei R dupa atributele din lista",
                      is_correct: !0,
                    },
                    { text: "Gruparea relatiei R dupa atributele din lista" },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>\u03c4</mi><msub><mrow><mo fence="true">(</mo><mi>R</mi><mo fence="true">)</mo></mrow><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mtext>&nbsp;</mtext><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>u</mi><mi>t</mi><msub><mi>e</mi><mrow></mrow></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\\tau\\left(R\\right)_{lista\\ atribute_{ }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1498em;vertical-align:-0.3998em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">\u03c4</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ib</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.143em;"><span style="top:-1.857em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.3998em;"><span></span></span></span></span></span></span></span></span></span></span>',
                },
                2: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\n\u03c1 = (AB, CE, DE, CD, AE)\nCare este cea mai puternica forma normala a lui \u03c1 (tinem cont ca FN1 < FN2 < FN3 < FNBC)",
                  options: [
                    { text: "FN2" },
                    { text: "FN3" },
                    { text: "FNBC", is_correct: !0 },
                  ],
                },
                3: {
                  question:
                    "Un join ca cel de mai sus pe doua relatii R si S implica efectuarea:",
                  options: [
                    { text: "Unei selectii pe reuniunea R si S" },
                    {
                      text: "Unui produs cartezian pe R si S urmat de o selectie cu conditia F",
                      is_correct: !0,
                    },
                    { text: "Unei intersectii pe R si S cu conditia F" },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mtext>&nbsp;</mtext><mo>&gt;</mo><mo>&lt;</mo><msub><mtext>&nbsp;</mtext><mi>F</mi></msub><mi>S</mi></mrow><annotation encoding="application/x-tex">R\\ &gt;&lt;\\ _FS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mspace">&nbsp;</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span>',
                },
                4: {
                  question: "Operatiile de mai sus sunt echivalente?",
                  options: [
                    {
                      text: "Da, deoarece reprezinta un semi-join",
                      is_correct: !0,
                    },
                    {
                      text: "Nu, pentru ca reprezinta metode diferite de join",
                    },
                    { text: "Da, deoarece reprezinta un join natural" },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>\u03c4</mi><msub><mtext>&nbsp;</mtext><mi>R</mi></msub><mtext>&nbsp;</mtext><mi>R</mi><mo>&gt;</mo><mo>&lt;</mo><mtext>&nbsp;</mtext><mi>S</mi><mtext>&nbsp;&nbsp;&nbsp;</mtext><mi>s</mi><mi>i</mi><mtext>&nbsp;</mtext><mi>R</mi><mtext>&nbsp;</mtext><mo>&gt;</mo><mo>&lt;</mo><mtext>&nbsp;</mtext><msub><mi>\u03c0</mi><mrow><mi>R</mi><mo>\u2229</mo><mi>S</mi><mtext>&nbsp;</mtext></mrow></msub><mrow><mo fence="true">(</mo><mi>S</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\\tau\\ _R\\ R&gt;&lt;\\ S\\ \\ \\ si\\ R\\ &gt;&lt;\\ \\pi_{R\\cap S\\ }\\left(S\\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">\u03c4</span><span class="mord"><span class="mspace">&nbsp;</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace">&nbsp;</span><span class="mspace">&nbsp;</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">\u03c0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">\u2229</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span>',
                },
                5: {
                  question:
                    "Daca tabela de angajati EMP are 14 linii iar valorile de pe coloana DEPTNO sunt 10, 20 si 30, atunci expresia de mai sus returneaza:",
                  options: [
                    { text: "Eroare" },
                    { text: "Maxim 3 linii" },
                    { text: "Maxim 14 linii", is_correct: !0 },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>\u03b3</mi><mrow><mi>E</mi><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>D</mi><mi>E</mi><mi>P</mi><mi>T</mi><mi>N</mi><mi>O</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>C</mi><mi>O</mi><mi>U</mi><mi>N</mi><mi>T</mi><mrow><mo fence="true">(</mo><mo>\u2217</mo><mo fence="true">)</mo></mrow></mrow></msub><mrow><mo fence="true">(</mo><mi>E</mi><mi>M</mi><mi>P</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\\gamma_{ENAME,\\ DEPTNO,\\ COUNT\\left(*\\right)}\\left(EMP\\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">\u03b3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">EN</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">ME</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">EPTNO</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">CO</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">NT</span><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mtight">\u2217</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">EMP</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span>',
                },
                6: {
                  question:
                    "Fie relatiile de mai sus, Joinul celor 2 relatii dupa conditia R.B=S.B are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/927775f0-b8bb-42bb-a75b-d1c99fdf95b9?w=600&h=600",
                  options: [
                    { text: "5 coloane" },
                    { text: "6 coloane", is_correct: !0 },
                    { text: "4 coloane" },
                  ],
                },
                7: {
                  question:
                    "Fie R = ABCDEF si\nF = {A\u2192B, CD\u2192A, BC\u2192D, AE\u2192F, CE\u2192D}.\nAtunci o cheie a lui R este:",
                  options: [
                    { text: "ABCE" },
                    { text: "DCE" },
                    { text: "CE", is_correct: !0 },
                  ],
                },
                8: {
                  question: "Cand e in FN3 si nu e in FNBC?",
                  options: [
                    {
                      text: "Pentru a fi in FN3 trebuie sa aiba un atribut prim sau X sa fie supercheie pentru R (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                9: {
                  question: "Ce e un join?",
                  options: [
                    {
                      text: "Produs cartezian urmat de un select (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                10: {
                  question: "Ce contin nodurile unui graf de strategie?",
                  options: [
                    {
                      text: "Nodurile sunt asimilate tabelelor si operatorilor: graful are un nod rezultat, fiind un nod tabela care reprezinta rezultatul interogarii si nodurile la care nu sosesc arcuri se numesc noduri de baza, iar celelalte noduri intermediare (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                11: {
                  question: "Regulile pentru a fi in FN4?",
                  options: [
                    {
                      text: "Este in FNBC si daca orice dependenta multivalorica netriviala X\u2192\u2192Y are in partea stanga o supercheie (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                12: {
                  question: "Regulile pentru a fi in FN5?",
                  options: [
                    {
                      text: "Dependenta jonctionala care reconstruieste schema originala este una triviala si fiecare relatie in dependenta jonctionala constituie cu toate atributele sale o supercheie a relatiei originale (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                13: {
                  question: "Ce fel de operator este Tau?",
                  options: [
                    {
                      text: "De sortare (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                14: {
                  question:
                    "Un join simplu pe 2 relatii R si S implica efectuarea:",
                  options: [
                    {
                      text: "Unui produs cartezian pe R si S urmat de o selectie cu conditia F",
                      is_correct: !0,
                    },
                    { text: "Unei selectii pe reuniunea R si S " },
                    { text: "Unei intersectii pe R si S cu conditia F" },
                  ],
                },
                15: {
                  question:
                    "Doua multimi de dependente functionale F si G sunt echivalente daca:",
                  options: [
                    { text: "G incluse sau egal in F+" },
                    { text: "F+ = G+", is_correct: !0 },
                    { text: "F = G" },
                  ],
                },
                16: {
                  question:
                    "Multimea de atribute X este cheie pentru relatia R daca:",
                  options: [
                    {
                      text: "X determina functional toate atributele relatiei R",
                    },
                    { text: "X este mutime minimala" },
                    { text: "Ambele conditii simultan", is_correct: !0 },
                  ],
                },
                17: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192B, B\u2192C, A\u2192C, D\u2192E}.\nAtunci o cheie a lui R este:",
                  options: [
                    { text: "AD", is_correct: !0 },
                    { text: "CD" },
                    { text: "ACD" },
                  ],
                },
                18: {
                  question:
                    "Fie R = ABCD\ncu multimea de dependente functionale\nF = {AB\u2192C, AB\u2192D, D\u2192A} si cheia AB.\nAtunci care din descompunerile urmatoare este in FNCB cu pastrarea proprietatii j.f.p?",
                  options: [
                    { text: "P = (AD, BCD)", is_correct: !0 },
                    { text: "P = (AB, BCD)" },
                    { text: "P = (ABC, CD)" },
                  ],
                },
                19: {
                  question:
                    "Fie relatia R = ABCDEF,\ncu multimea de dependente functionale\nF = {A\u2192B, A\u2192F, B\u2192E, D\u2192B, E\u2192A} si cheia CD.\nAtunci care dintre descompunerile urmatoare *NU* sunt in FN3 cu pastrarea dependentelor functionale si proprietate j.f.p?",
                  options: [
                    { text: "P = (ABF, BE, DB, EA, CD)" },
                    { text: "P = (AB, BCDEF)", is_correct: !0 },
                    { text: "P = (AB, BC, DEF, CD)" },
                  ],
                },
                20: {
                  question:
                    "Fie R = ABCDE\ncu multimea de dependente functionale\nF = {A\u2192B, A\u2192BC, BC\u2192DE, D\u2192E}.\nCare dintre urmatoarele descompuneri sunt in FN3 cu pastrarea dependentelor functionale?",
                  options: [
                    { text: "\u2374 = (ABC, BCDE)", is_correct: !0 },
                    { text: "\u2374 = (AB, BC, DE)" },
                    { text: "\u2374 = (AB, BCDE)" },
                  ],
                },
                21: {
                  question:
                    "Care dintre urmatoarele reguli de echivalenta sunt corecte?",
                  options: [
                    {
                      text: "sigmaf(E1-E2) = sigmaf(E1) - sigmaf(E2)",
                      is_correct: !0,
                    },
                    {
                      text: "sigmaf(E1-E2) = sigmaf(E1) (intersectat) sigmaf(E2)",
                    },
                    { text: "sigmaf(E1-E2) = sigmaf(E1) U sigmaf(E2)" },
                  ],
                },
                22: {
                  question:
                    "Intr-un graf de strategii nodurile sunt asimilate:",
                  options: [
                    {
                      text: "atat tabelelor cat si operatorilor",
                      is_correct: !0,
                    },
                    { text: "numai tabelelor " },
                    { text: "numai operatorilor" },
                  ],
                },
                23: {
                  question:
                    "Daca o subcerere SQL returneaza o pereche de coloane, atunci in clauza WHERE a cererii principale se poate folosi operatorul:",
                  options: [
                    {
                      text: "\u201cIN\u201d intre perechile de coloane din cererea principala si subcerere, specificate intre paranteze (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                    {
                      text: "\u201c=\u201d intre perechile de coloane din cererea principala si subcerere, specificate intre paranteze",
                    },
                    {
                      text: "Orice operator intre perechile de coloane din cererea principala si subcerere",
                    },
                  ],
                },
                24: {
                  question:
                    "Intr-un join de tip JOIN ... ON conditia de join se pune:",
                  options: [
                    {
                      text: "Numai pe coloanele de acelasi tip",
                      is_correct: !0,
                    },
                    { text: "Numai pe coloanele cu acelasi nume " },
                    { text: "Numai pe coloanele cu acelasi tip si nume" },
                  ],
                },
                25: {
                  question:
                    "Care dintre afirmatiile de mai jos sunt adevarate pt o baza de date NoSQL?",
                  options: [
                    {
                      text: "Permite duplicarea de date deoarece nu este normalizata",
                      is_correct: !0,
                    },
                    { text: "Permite procesarea pararela a datelor" },
                    { text: "Este recomandata pentru gestiunea documentelor" },
                  ],
                },
                26: {
                  question:
                    "Atributul unei relatii in Modelul Relational reprezinta:",
                  options: [
                    { text: "O proprietate a unei coloane;" },
                    { text: "O coloana a unei tabele;", is_correct: !0 },
                    { text: "Tipul unei coloane" },
                  ],
                },
                27: {
                  question:
                    "Consideram ca relatia\nTELEFOANE(ID_telefon, ID_furnizor, seria, pret_unitar) \nare cheia\n(ID_telefon, ID_furnizor)\nAnalizand dependentele functionale, care este cea mai buna forma normala in care se incadreaza aceasta relatie:",
                  options: [
                    { text: "FN2" },
                    { text: "FN1" },
                    { text: "FN3", is_correct: !0 },
                  ],
                },
                28: {
                  question:
                    "Daca o relatie R se descompune in mai multe relatii:",
                  options: [
                    {
                      text: "Relatia R nu poate fi refacuta niciodata prin join din relatiile rezultate din descompunere",
                    },
                    {
                      text: "Daca descompunerea este incorecta se pot pierde date si dependente din R prin descompunere",
                      is_correct: !0,
                    },
                    {
                      text: "Relatia R poate fi refacuta intotdeauna prin join din relatiile rezultate din descompunere",
                    },
                  ],
                },
                29: {
                  question:
                    "In calculul relational pe tupluri o cerere are ca rezultat:",
                  options: [
                    {
                      text: "Multimea tuplurilor care indeplinesc constrangerile de integritate",
                    },
                    {
                      text: "Multimea tuplurilor care au atribute intr-un domeniu",
                    },
                    {
                      text: "Multimea tuplurilor care verifica una sau mai multe formule",
                      is_correct: !0,
                    },
                  ],
                },
                30: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192B, A\u2192C, A\u2192D, D\u2192E}.\nAtunci o cheie a lui R este:",
                  options: [
                    { text: "A", is_correct: !0 },
                    { text: "ADE" },
                    { text: "AD" },
                  ],
                },
                31: {
                  question: "Multiset-urile reprezinta:",
                  options: [
                    {
                      text: "Multimi de date care contin valori duplicate",
                      is_correct: !0,
                    },
                    { text: "O relatie care are mai multe tupluri unicat" },
                    { text: "O relatie care contine tupluri duplicate" },
                  ],
                },
                32: {
                  question: "In Modelul Relational o cheie reprezinta:",
                  options: [
                    {
                      text: "Un identificator de unicitate pentru valorile nenule ale atributului respectiv",
                    },
                    {
                      text: "Un identificator unic numai pentru valorile atributului pe care este creata",
                    },
                    {
                      text: "O multime minimala de atribute care identifica unic fiecare tuplu al unei relatii",
                      is_correct: !0,
                    },
                  ],
                },
                33: {
                  question:
                    "Fie relatia R = ABCDEF,\ncu multimea de dependente functionale\nF = {A\u2192B, A\u2192C, A\u2192F, B\u2192E, D\u2192B, E\u2192A}.\nAtunci descompunerea\n\u2374 = (AB, BCD, AEF, CDE):",
                  options: [
                    {
                      text: "Nu se poate aplica algoritmul de verificare in acest caz",
                    },
                    {
                      text: "Nu pastreaza dependentele functionale pe F",
                      is_correct: !0,
                    },
                    { text: "Pastreaza dependentele functionale pe F" },
                  ],
                },
                34: {
                  question: "O relatie logica reprezinta:",
                  options: [
                    {
                      text: "O asociere dintre mai multe entitati",
                      is_correct: !0,
                    },
                    { text: "Legatura dintre atributele entitatii" },
                    { text: "O descriere a unui atribut" },
                  ],
                },
                35: {
                  question:
                    "Organizarea datelor sub forma de tabele este folosita in:",
                  options: [
                    { text: "Modelul ierarhic" },
                    { text: "Modelul relational", is_correct: !0 },
                    { text: "Ambele variante sunt corecte" },
                  ],
                },
                36: {
                  question:
                    "In modelul relational o formula \u2366 este compusa din:",
                  options: [
                    {
                      text: "Variabile tuplu, constante si operatori",
                      is_correct: !0,
                    },
                    { text: "Numai din variabile tuplu si constante" },
                    { text: "Numai din atributele unei relatii" },
                  ],
                },
                37: {
                  question:
                    "Operatorul de mai sus este folosit, conform definitiei, pentru: OBS: Y este simbolul gamma",
                  options: [
                    { text: "Gruparea relatiei R dupa atributele din lista" },
                    { text: "Utilizarea de functii la nivel de grup" },
                    { text: "Ambele variante sunt corecte", is_correct: !0 },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>Y</mi><mrow><mi>a</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>&nbsp;</mtext><mi>s</mi><mi>i</mi><mtext>&nbsp;</mtext><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>i</mi><mtext>&nbsp;</mtext></mrow></msub><mrow><mo fence="true">(</mo><mi>R</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_{aatribute\\ si\\ functii\\ }\\left(R\\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">aa</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">ib</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">ii</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span>',
                },
                38: {
                  question: "Modelul de date este descris de:",
                  options: [
                    { text: "Nivelul intern de organizare a datelor" },
                    { text: "Nivelul extern de acces la date" },
                    { text: "Nivelul conceptual al datelor", is_correct: !0 },
                  ],
                },
                39: {
                  question:
                    "Cheia unei relatii in Modelul Relational reprezinta?",
                  options: [
                    {
                      text: "O multime minimala de atribute care identifica in mod unic un tuplu",
                    },
                    { text: "O constrangere de integritate" },
                    { text: "Ambele variante sunt corecte", is_correct: !0 },
                  ],
                },
                40: {
                  question:
                    "Daca o relatie R se descompune in mai multe relatii, atunci relatiile obtinute din descompunere:",
                  options: [
                    {
                      text: "Pot avea atat atribute comune cat si diferite",
                      is_correct: !0,
                    },
                    { text: "Trebuie sa aiba obligatoriu atribute comune" },
                    { text: "Trebuie sa aiba obligatoriu atribute diferite" },
                  ],
                },
                41: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192B, B\u2192C, A\u2192C, D\u2192E}.\nAtunci inchiderea multimii de atribute D+ este:",
                  options: [
                    { text: "R" },
                    { text: "BE" },
                    { text: "DE", is_correct: !0 },
                  ],
                },
                42: {
                  question:
                    "Care regula de modelare este adevarata in modelul Entitate-Asociere:",
                  options: [
                    {
                      text: "Atributele unei entitati care au o asociere multi-unu cu o alta entitate vor fi reclasificate ca entitati",
                    },
                    {
                      text: "Atributele multivalorice trebuie reclasificate ca entitati",
                    },
                    { text: "Ambele variante sunt adevarate", is_correct: !0 },
                  ],
                },
                43: {
                  question:
                    "Rezultatul transformarii din modelul EA in MR pentru entitatile\nAUTORI(id_autor, nume, adresa)\nsi\nCARTI(id_carte, titlu, editura),\naflate intr-o relatie 1:N (1 pentru autori), este:",
                  options: [
                    {
                      text: "CARTI(id_carte,titlu,editura, id_autor), AUTORI(id_autor,nume,adresa)",
                      is_correct: !0,
                    },
                    {
                      text: "CARTI(id_carte,titlu,editura,id_autor), AUTORI(id_autor,nume,adresa, id_carte)",
                    },
                    {
                      text: "CARTI(id_carte,titlu, nume, editura), AUTORI(id_autor,nume,adresa)",
                    },
                  ],
                },
                44: {
                  question:
                    "Daca consideram ca relatia\nR = ABCD,\ncu\nF= {AB\u2192C, AB\u2192D, D\u2192A} are cheia unica AB,\natunci relatia este in forma normala FNBC ?",
                  options: [
                    {
                      text: "Da, deoarece D->A are in partea dreapta atributul prim A",
                    },
                    {
                      text: "Da, deoarece cheia este si supercheie a relatiei",
                    },
                    {
                      text: "Nu, deoarece D->A violeaza conditia de supercheie",
                      is_correct: !0,
                    },
                  ],
                },
                45: {
                  question:
                    "O relatie R este in FN3 daca si numai daca oricare ar fi o dependenta netriviala X \u2192 A din F atunci:",
                  options: [
                    { text: "X nu este o cheie pentru R" },
                    { text: "A nu este atribut prim" },
                    {
                      text: "A este atribut prim sau X este supercheie pentru R",
                      is_correct: !0,
                    },
                  ],
                },
                46: {
                  question:
                    "Daca consideram ca relatia\nTELEFOANE(cod_telefon, den_furniz, data_lansare, pret_unitar) are cheia cod_telefon,\natunci relatia este in forma normala: Alege\u021bi o op\u021biune:",
                  options: [
                    { text: "FN2 dar nu si in FN1" },
                    { text: "FN1 dar nu si in FN2" },
                    { text: "FN1 si FN2", is_correct: !0 },
                  ],
                },
                47: {
                  question: "Joinul natural al celor 2 relatii are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/13481e9a-d955-42d7-9688-e365372ae029?w=600&h=600",
                  options: [
                    { text: "2 tupluri" },
                    { text: "3 tupluri", is_correct: !0 },
                    { text: "4 tupluri" },
                  ],
                },
                48: {
                  question: "Joinul natural al celor 2 relatii are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/ea78ad33-384c-481e-aab6-2b4764cd064d?w=600&h=600",
                  options: [
                    { text: "3 coloane" },
                    { text: "6 coloane" },
                    { text: "5 coloane", is_correct: !0 },
                  ],
                },
                49: {
                  question:
                    "Joinul celor 2 relatii dupa conditia STUD.IdS = SPEC.Ids are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/32f85cf6-a206-4020-9b7e-241983f7b35e?w=600&h=600",
                  options: [
                    { text: "3 tupluri", is_correct: !0 },
                    { text: "4 tupluri" },
                    { text: "5 tupluri" },
                  ],
                },
                50: {
                  question:
                    "Joinul celor 2 relatii dupa conditia STUD.IdS = SPEC.Ids are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/8b949637-3249-4588-a321-a2c78a5f4453?w=600&h=600",
                  options: [
                    { text: "3 coloane" },
                    { text: "6 coloane", is_correct: !0 },
                    { text: "5 coloane" },
                  ],
                },
                51: {
                  question:
                    "Joinul extern stanga al STUD cu SPEC dupa conditia STUD.IdS = SPEC.Ids are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/cd94c494-4225-40d5-a411-899cd638a15b?w=600&h=600",
                  options: [
                    { text: "4 tupluri", is_correct: !0 },
                    { text: "3 tupluri" },
                    { text: "5 tupluri" },
                  ],
                },
                52: {
                  question:
                    "Joinul extern dreapta al STUD cu SPEC dupa conditia STUD.IdS = SPEC.Ids are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/2d302935-a1bf-4841-a343-101be2ba6cfd?w=600&h=600",
                  options: [
                    { text: "4 tupluri", is_correct: !0 },
                    { text: "3 tupluri" },
                    { text: "5 tupluri" },
                  ],
                },
                53: {
                  question:
                    "Joinul extern complet al STUD cu SPEC dupa conditia STUD.IdS = SPEC.Ids are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/713fb203-1f2f-4133-b4ab-b614195bfb8b?w=600&h=600",
                  options: [
                    { text: "4 tupluri" },
                    { text: "3 tupluri" },
                    { text: "5 tupluri", is_correct: !0 },
                  ],
                },
                54: {
                  question:
                    "Fie R = ABCDEH si\nF = {A\u2192E, B\u2192H, B\u2192D, C\u2192B, H\u2192C}.\nNumarul de chei distincte ale relatiei este:",
                  options: [
                    { text: "3", is_correct: !0 },
                    { text: "2" },
                    { text: "1" },
                  ],
                },
                55: {
                  question:
                    "Fie R = ABCDEH si\nF = {A\u2192E, B\u2192H, B\u2192D, C\u2192B, H\u2192C}.\nR este in formele normale:",
                  options: [
                    { text: "FN3 si FNBC" },
                    { text: "Doar FN3" },
                    { text: "Nici macar in FN3", is_correct: !0 },
                  ],
                },
                56: {
                  question:
                    "Fie R = ABCDEH si\nF = {A\u2192E, B\u2192H, B\u2192D, C\u2192B, H\u2192C}.\nCe dependenta nu se poate deduce din F:",
                  options: [
                    { text: "B \u2192 C" },
                    { text: "E \u2192 D", is_correct: !0 },
                    { text: "C \u2192 D" },
                  ],
                },
                57: {
                  question:
                    "Fie R = ABCDEH si\nF = {A\u2192E, B\u2192H, B\u2192D, C\u2192B, H\u2192C}.\nCare descompunere pastreaza dependentele",
                  options: [
                    { text: "\u03c1 = (ABC, CDEH)" },
                    { text: "\u03c1 = (ABH, CDE)" },
                    { text: "\u03c1 = (AE, BCDH)", is_correct: !0 },
                  ],
                },
                58: {
                  question:
                    "Fie R = ABCDEH si\nF = {A\u2192E, B\u2192H, B\u2192D, C\u2192B, H\u2192C}.\nCare descompunere are proprietatea de join fara pierderi",
                  options: [
                    { text: "\u03c1 = (ABC, CDEH)" },
                    { text: "\u03c1 = (ABCE, BCHD)", is_correct: !0 },
                    { text: "\u03c1 = (ABCH, CDE)" },
                  ],
                },
                59: {
                  question:
                    "Fie R = ABCDEH si\nF = {A\u2192E, B\u2192H, B\u2192D, C\u2192B, H\u2192C}.\nDescompunerea \u03c1 = (AE, BCDH):",
                  options: [
                    { text: "Pastreaza dependentele", is_correct: !0 },
                    { text: "Are Join fara pierderi" },
                    { text: "Ambele" },
                  ],
                },
                60: {
                  question:
                    "In sisteme NoSQL cu stocare cheie-valoare, operatiile principale sunt",
                  options: [
                    {
                      text: "Primeste o cheie si o lista de valori asociate si returneaza un numar de inregistrari",
                      is_correct: !0,
                    },
                    { text: "Reuneste iesirile functiei Reduce" },
                    { text: "Imparte o problema in subprobleme" },
                  ],
                },
                61: {
                  question: "Atributele nu se pot atasa:",
                  options: [
                    { text: "La ierarhii", is_correct: !0 },
                    { text: "La entitati" },
                    { text: "La asocieri" },
                  ],
                },
                62: {
                  question: "Termenul de planificare reprezinta:",
                  options: [
                    {
                      text: "Ordinea in care sunt executati de SGBD pasii elementari ai unui set de tranzactii (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                63: {
                  question:
                    "Litera D din abrevierea ACID se refera la proprietatea de:",
                  options: [
                    {
                      text: "durabilitate (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                64: {
                  question:
                    "Litera I din abrevierea ACID se refera la proprietatea de:",
                  options: [
                    {
                      text: "Izolare (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                65: {
                  question: "Consistenta eventuala presupune ca:",
                  options: [
                    {
                      text: "schimbarile se vor propaga in cele din urma la toate inregistrarile (era unica varianta in doc\ud83d\udd75)",
                      is_correct: !0,
                    },
                  ],
                },
                66: {
                  question: "JSON reprezinta:",
                  options: [
                    { text: "Java Script Object Notation", is_correct: !0 },
                  ],
                },
                67: {
                  question: "O asociere cu doua ramuri poate fi:",
                  options: [
                    { text: "Unara" },
                    { text: "Binara" },
                    { text: "Ambele raspunsuri sunt corecte", is_correct: !0 },
                  ],
                },
                68: {
                  question:
                    "O diagrama EA continand o ierarhie de incluziune cu tatal\nANGAJAT(IdA, Nume)\nsi fii\nINGINER(IdI, Specialitate, Vechime)\nsi\nMUNCITOR(IdM, Calificare)",
                  options: [
                    {
                      text: "Poate fi corecta sau gresita in functie de context",
                    },
                    { text: "Este gresita", is_correct: !0 },
                    { text: "Este corecta" },
                  ],
                },
                69: {
                  question:
                    "O diagrama contine 3 entitati E1, E2 si E3 avand fiecare un atribut de identificare si unul de descriere. Cele 3 entitati sunt parte a unei asocieri cu 4 ramuri, doua spre E1 si cate una spre E2 si E3. Dupa transformare numarul total de atribute din tabele este:",
                  options: [
                    { text: "6" },
                    { text: "9", is_correct: !0 },
                    { text: "10" },
                  ],
                },
                70: {
                  question: "O asociere trebuie sa aiba:",
                  options: [
                    { text: "Macar o ramura obligatorie" },
                    { text: "Macar o ramura multi" },
                    { text: "Ambele raspunsuri sunt gresite", is_correct: !0 },
                  ],
                },
                71: {
                  question:
                    "La transformarea unei ierarhii de generalizare, criteriul de clasificare devine:",
                  options: [
                    { text: "O coloana la tata", is_correct: !0 },
                    { text: "O coloana la fiecare fiu" },
                    { text: "Un tuplu (linie din tabela)" },
                  ],
                },
                72: {
                  question:
                    "Atunci joinul natural intre R si S va avea un numar de linii egal cu:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/97f76c6a-af33-4345-a6fd-86e788cf1d6d?w=600&h=600",
                  options: [
                    { text: "2" },
                    { text: "3", is_correct: !0 },
                    { text: "9" },
                  ],
                },
                73: {
                  question:
                    "Joinul de mai sus va avea un numar de coloane egal cu:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/3c1a9850-e747-45bd-96eb-ca004bbe3992?w=600&h=600",
                  options: [
                    { text: "4", is_correct: !0 },
                    { text: "5" },
                    { text: "6" },
                  ],
                },
                74: {
                  question:
                    "Fie R si S ca in imaginea de mai sus. Joinul dupa conditia R.B = S.B va avea un numar de linii egal cu:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/0f7b4784-093e-42f7-aec0-fa69e0b74211?w=600&h=600",
                  options: [
                    { text: "3" },
                    { text: "9", is_correct: !0 },
                    { text: "6" },
                  ],
                },
                75: {
                  question:
                    "Fie R si S ca in imaginea de mai sus. Joinul extern complet dupa conditia\n(R.B = S.B) and (R.C = S.C)\nva avea un numar de linii egal cu:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/7b6a3ae6-baa3-430f-bf44-9d3e9e5f7c3f?w=600&h=600",
                  options: [
                    { text: "4", is_correct: !0 },
                    { text: "3" },
                    { text: "5" },
                  ],
                },
                76: {
                  question:
                    "Fie R si S ca in imaginea de mai sus. Proiectia de sub imagine are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/bc680c18-bb59-471f-b3dd-cf971274f8c8?w=600&h=600",
                  options: [
                    { text: "3 linii" },
                    { text: "2 linii" },
                    { text: "1 linie", is_correct: !0 },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>\u03c0</mi><mrow><mi>A</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>B</mi></mrow></msub><mrow><mo fence="true">(</mo><mi>R</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\\pi_{A,\\ B}\\left(R\\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">\u03c0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span>',
                },
                77: {
                  question:
                    "Fie R si S ca in imaginea de mai sus. Joinul extern complet dupa conditia\n(R.B = S.B) and (R.C = S.C)\nva contine un numar de valori nule egal cu:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/a4d59f7c-687a-4a6f-8b8b-675aacab7cb3?w=600&h=600",
                  options: [
                    { text: "3", is_correct: !0 },
                    { text: "6" },
                    { text: "9" },
                  ],
                },
                78: {
                  question:
                    "Fie R si S ca in imaginea de mai sus. Atunci expresia de sub imagine, folosind operatori extinsi pe relatii va avea un numar de linii egal cu:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/44e83fe6-d6fe-4073-aa24-66f1e5617661?w=600&h=600",
                  options: [
                    { text: "3", is_correct: !0 },
                    { text: "4" },
                    { text: "9" },
                  ],
                  katex:
                    '<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>\u03b3</mi><mrow><mi>R</mi><mi mathvariant="normal">.</mi><mi>C</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mrow><mo fence="true">(</mo><mo>\u2217</mo><mo fence="true">)</mo></mrow><mtext>&nbsp;</mtext></mrow></msub><mrow><mo fence="true">(</mo><mi mathvariant="normal">\u03a0</mi><msub><mtext>&nbsp;</mtext><mrow><mi>A</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>C</mi></mrow></msub><mrow><mo fence="true">(</mo><mi>R</mi><mo fence="true">)</mo></mrow><mtext>&nbsp;</mtext><mo>\xd7</mo><mi mathvariant="normal">\u03a0</mi><msub><mtext>&nbsp;</mtext><mrow><mi>C</mi><mo separator="true">,</mo><mtext>&nbsp;</mtext><mi>D</mi></mrow></msub><mrow><mo fence="true">(</mo><mi>S</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\\gamma_{R.C,\\ Count\\left(*\\right)\\ }\\left(\\Pi\\ _{A,\\ C}\\left(R\\right)\\ \\times\\Pi\\ _{C,\\ D}\\left(S\\right)\\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">\u03b3</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mtight">\u2217</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">\u03a0</span><span class="mord"><span class="mspace">&nbsp;</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">\xd7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">\u03a0</span><span class="mord"><span class="mspace">&nbsp;</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mspace mtight"><span class="mtight">&nbsp;</span></span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">\u200b</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span>',
                },
                79: {
                  question:
                    "Pentru rezultatul anterior, suma valorilor din tabela rezultat este: (nu stiu care e rezultatul anterior, nu se poate afla)",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/c0ea07d3-3f02-4acd-8ff0-711a878269e0?w=600&h=600",
                  options: [
                    { text: "6" },
                    {
                      text: "15 (problemele mai bine le inveti din PDF)",
                      is_correct: !0,
                    },
                    { text: "17" },
                  ],
                },
                80: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nMultimea F este echivalenta cu\nG = {A\u2192B, C\u2192E, E\u2192D, D\u2192C}?",
                  options: [
                    { text: "Da", is_correct: !0 },
                    { text: "Nu" },
                    { text: "Depinde de context" },
                  ],
                },
                81: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nMultimea AB este cheie:",
                  options: [
                    { text: "Da" },
                    { text: "Nu", is_correct: !0 },
                    { text: "Depinde de context" },
                  ],
                },
                82: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nCare dependenta din cele de mai jos se poate deduce din F:",
                  options: [
                    { text: "AB \u2192 C" },
                    { text: "AC \u2192 B", is_correct: !0 },
                    { text: "ED \u2192 B" },
                  ],
                },
                83: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nCate chei distincte are R?",
                  options: [
                    { text: "1" },
                    { text: "2" },
                    { text: "3", is_correct: !0 },
                  ],
                },
                84: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nPrintre atributele prime ale lui R se numara si cele din multimea:",
                  options: [
                    { text: "{B, D, E}" },
                    { text: "{A, B, C}" },
                    { text: "{A, C, D}", is_correct: !0 },
                  ],
                },
                85: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nProiectia multimii de dependente F pe ABED contine dependentele",
                  options: [
                    { text: "{E \u2192 D, D \u2192 E}", is_correct: !0 },
                    { text: "{A \u2192 B, B \u2192 A}" },
                    { text: "{A \u2192 E, E \u2192 A}" },
                  ],
                },
                86: {
                  question:
                    "Fie R = ABCDE\nsi multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nDescompunerea \u03c3 = (AB, CDE) are proprietatile:",
                  options: [
                    { text: "Doar JFP" },
                    { text: "Doar pastreaza dependentele", is_correct: !0 },
                    { text: "Ambele" },
                  ],
                },
                87: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata\nF = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}.\nDescompunerea \u03c1 = (AB, CE, DE, CD, AE) are proprietatile:",
                  options: [
                    { text: "JFP si pastreaza dependentele", is_correct: !0 },
                    { text: "Doar JFP" },
                    { text: "Doar pastreaza dependentele" },
                  ],
                },
              },
              F = function () {
                var e = k[_];
                D[e] &&
                  w[e].forEach(function (t, a) {
                    D[e].options[a] && (D[e].options[a].feedback = t);
                  });
              },
              _ = 0,
              k = Object.keys(w);
            _ < k.length;
            _++
          )
            F();
          for (
            var B = D,
              O = {
                1: [
                  "Op\u021biunea nu este corect\u0103. \xcen modelul rela\u021bional, rela\u021biile (tabelurile) nu con\u021bin tupluri (r\xe2nduri) duplicate, acesta fiind un principiu fundamental al modelului.",
                  "Op\u021biunea nu este corect\u0103. Multiseturile (sau bagurile) pot con\u021bine tupluri (elemente) duplicate, spre deosebire de seturi, care con\u021bin doar elemente unice.",
                  "Op\u021biunea este corect\u0103. \xcentr-adev\u0103r, rela\u021biile \xeen modelul rela\u021bional nu con\u021bin tupluri duplicate, iar multiseturile pot con\u021bine tupluri unice \u0219i duplicate.",
                ],
                2: [
                  "Op\u021biunea este corect\u0103. O schem\u0103 \xeen modelul rela\u021bional reprezint\u0103 structura unei rela\u021bii, adic\u0103 define\u0219te numele \u0219i tipurile de date ale atributelor rela\u021biei.",
                  "Op\u021biunea nu este corect\u0103. Un domeniu de valori reprezint\u0103 setul de valori posibile pentru un anumit atribut, nu structura \xeentregii rela\u021bii.",
                  "Op\u021biunea nu este corect\u0103. Multimea tuplurilor unei rela\u021bii reprezint\u0103 con\u021binutul rela\u021biei, nu structura acesteia.",
                ],
                3: [
                  "Op\u021biunea nu este corect\u0103. Functia TO_DATE cu formatul 'YYYY' va returna doar anul datelor de examen, nu \xeentreaga dat\u0103 de examen pentru anul curent.",
                  "Op\u021biunea este corect\u0103. Functia TO_DATE cu formatul 'YYYY' va returna doar anul datelor de examen, form\xe2nd o list\u0103 cu numele, disciplina \u0219i anul de examen pentru fiecare student.",
                  "Op\u021biunea nu este corect\u0103. Cererea select nume, disciplina, to_date(data_examen, \u2018YYYY\u2019) va returna numele, disciplina \u0219i anul de examen pentru fiecare student, deci varianta a doua este corect\u0103.",
                ],
                4: [
                  "GPT4 zice ca e asta corecta si e strict impotriva variantei `tuplurilor unicat` - Proiec\u021bia unei rela\u021bii produce o nou\u0103 rela\u021bie care con\u021bine doar anumite atribute ale rela\u021biei originale \u0219i valorile asociate acestora. Este r\u0103spunsul corect!",
                  "Studentii au crezut ca e asta corecta. Vezi cealalta varianta - Opera\u021bia de proiec\u021bie asupra unei rela\u021bii returneaz\u0103 o rela\u021bie care con\u021bine doar tuplurile unice pentru atributele selectate.",
                  "Op\u021biunea nu este corect\u0103. Opera\u021bia de proiec\u021bie nu returneaz\u0103 tupluri duplicate. \xcen rezultatul proiec\u021biei, fiecare tuplu apare o singur\u0103 dat\u0103.",
                ],
                5: [
                  "Op\u021biunea nu este corect\u0103. A fi cheie sau supercheie a unei rela\u021bii nu garanteaz\u0103 c\u0103 rela\u021bia este \xeen FN3. Dependin\u021bele par\u021biale sau tranzitive pot \xeempiedica acest lucru.",
                  "Op\u021biunea nu este corect\u0103. Prezen\u021ba dependen\u021belor tranzitive poate \xeempiedica o rela\u021bie s\u0103 fie \xeen FN3, dar acest lucru nu este relevant \xeen acest caz.",
                  "Op\u021biunea este corect\u0103. Dac\u0103 o rela\u021bie are dependen\u021be par\u021biale (adic\u0103 dependen\u021be de un subset al cheii), atunci aceasta nu este \xeen forma normal\u0103 a treia (FN3).",
                ],
                6: [
                  "Op\u021biunea este corect\u0103. Scripturile care con\u021bin comenzi SQL se pot executa \xeen SQL*Plus dac\u0103 au extensia .sql sau .txt. Aceasta este o caracteristic\u0103 a multor medii de lucru SQL.",
                  "Op\u021biunea nu este corect\u0103. Doar extensia .sql nu este suficient\u0103, deoarece \u0219i fi\u0219ierele .txt pot fi executate \xeen SQL*Plus.",
                  "Op\u021biunea nu este corect\u0103. Doar extensia .txt nu este suficient\u0103, deoarece \u0219i fi\u0219ierele .sql pot fi executate \xeen SQL*Plus.",
                ],
                7: [
                  "Op\u021biunea nu este corect\u0103. Descompunerea este o alt\u0103 regul\u0103 de inferen\u021b\u0103 care nu se aplic\u0103 \xeen acest context.",
                  "Op\u021biunea este corect\u0103. Regula de pseudotranzitivitate spune c\u0103 dac\u0103 avem dou\u0103 dependen\u021be func\u021bionale X\u2192Y \u0219i YZ\u2192W, atunci putem deduce dependen\u021ba XZ\u2192W.",
                  "Op\u021biunea nu este corect\u0103. Reuniunea este o alt\u0103 regul\u0103 de inferen\u021b\u0103 care nu se aplic\u0103 \xeen acest context.",
                ],
                8: [
                  "Op\u021biunea nu este corect\u0103. Absen\u021ba dependen\u021belor par\u021biale nu este suficient\u0103 pentru a garanta c\u0103 o rela\u021bie este \xeen FN3. Este necesar \u0219i ca rela\u021bia s\u0103 fie \xeen FN2 \u0219i s\u0103 nu aib\u0103 dependen\u021be tranzitive.",
                  "Op\u021biunea este corect\u0103. O rela\u021bie este \xeen FN3 dac\u0103 este \xeen FN2 \u0219i nu con\u021bine dependen\u021be tranzitive.",
                  "Op\u021biunea nu este corect\u0103. O rela\u021bie nu poate fi \xeen FN3 dac\u0103 con\u021bine dependen\u021be par\u021biale, indiferent dac\u0103 este sau nu \xeen FN2.",
                ],
                9: [
                  "Op\u021biunea nu este corect\u0103. Dac\u0103 Y este parte a unei chei, atunci dependen\u021ba Y\u2192A nu este par\u021bial\u0103, ci total\u0103.",
                  "Op\u021biunea nu este corect\u0103. Dac\u0103 Y nu face parte dintr-o cheie a rela\u021biei, atunci nu putem concluziona c\u0103 dependen\u021ba Y\u2192A este tranzitiv\u0103. Ar trebui s\u0103 \u0219tim c\u0103 Y depinde de o cheie a rela\u021biei.",
                  "Op\u021biunea nu este corect\u0103. Niciuna dintre afirma\u021bii nu este adev\u0103rat\u0103.",
                ],
                10: [
                  "Op\u021biunea este corect\u0103. \xcen modelul rela\u021bional, o rela\u021bie reprezint\u0103 o submultime a unui produs cartezian ob\u021binut din alte rela\u021bii. Acest lucru reflect\u0103 faptul c\u0103 fiecare tuplu \xeentr-o rela\u021bie este o combina\u021bie de valori din domeniile atributelor.",
                  "Op\u021biunea nu este corect\u0103. O rela\u021bie nu este doar o multime de tupluri care \xeendeplinesc anumite constr\xe2ngeri de integritate. De\u0219i constr\xe2ngerile de integritate pot influen\u021ba care tupluri sunt valabile \xeentr-o rela\u021bie, ele nu definesc rela\u021bia \xeen sine.",
                  "Op\u021biunea nu este corect\u0103. O rela\u021bie nu este o multime a atributelor care au o leg\u0103tur\u0103 func\u021bional\u0103 \xeentre ele. De\u0219i o rela\u021bie poate include dependen\u021be func\u021bionale, acestea nu definesc rela\u021bia \xeen sine.",
                ],
                11: [
                  "Modelul de baz\u0103 de date obiect este utilizat \xeen programarea orientat\u0103 pe obiecte, deoarece stocheaz\u0103 datele sub forma obiectelor, care sunt instan\u021be ale claselor, a\u0219a cum este prezentat \xeen OOP. Acesta permite o manipulare mai eficient\u0103 a datelor complexe.",
                  "Modelul de baz\u0103 de date obiect-rela\u021bional este de asemenea utilizat \xeen programarea orientat\u0103 pe obiecte. Acest model combin\u0103 caracteristicile modelelor obiect \u0219i rela\u021bionale, permi\u021b\xe2nd o flexibilitate \u0219i eficien\u021b\u0103 mai mare \xeen gestionarea datelor.",
                  "Ambele modele de baze de date, obiect \u0219i obiect-rela\u021bional, sunt utilizate \xeen programarea orientat\u0103 pe obiecte. Aceste modele permit reprezentarea \u0219i manipularea eficient\u0103 a datelor complexe, care sunt specifice aplica\u021biilor orientate pe obiecte.",
                ],
                12: [
                  "Un join natural al dou\u0103 rela\u021bii se face pe coloanele care au acela\u0219i nume, acela\u0219i tip \u0219i valori egale. Aceasta este o opera\u021bie de combinare a dou\u0103 tabele bazat\u0103 pe egalitatea valorilor din coloanele comune.",
                  "Un join natural nu se face pe coloanele care au acelea\u0219i valori, indiferent de tip. Tipul datelor este important \xeen realizarea unui join natural, deci aceast\u0103 afirma\u021bie este incorect\u0103.",
                  "Un join natural nu se face pe coloanele care au acela\u0219i tip, indiferent de valori. Numele \u0219i valorile coloanelor sunt de asemenea importante \xeen realizarea unui join natural, deci aceast\u0103 afirma\u021bie este incorect\u0103.",
                ],
                13: [
                  "Notatia R\u22b20\u22b3LS nu se refer\u0103 la un join natural cu condi\u021bia L. Acesta este un simbol pentru un tip diferit de join.",
                  "Notatia R\u22b20\u22b3LS se refer\u0103 la un join extern. Un join extern returneaz\u0103 toate \xeenregistr\u0103rile dintr-o tabel\u0103 \u0219i unele \xeenregistr\u0103ri din cealalt\u0103 tabel\u0103. Dac\u0103 nu exist\u0103 nicio potrivire, rezultatul este NULL pe partea a doua a join-ului.",
                  "Notatia R\u22b20\u22b3LS nu se refer\u0103 la un semi-join. Semi-join este un tip diferit de join, care returneaz\u0103 doar valorile unice din prima tabel\u0103 care corespund celei de-a doua.",
                ],
                14: [
                  "Bazele de date NoSQL nu suport\u0103 opera\u021biile de normalizare. Normalizarea este specific\u0103 bazelor de date rela\u021bionale \u0219i scopul s\u0103u este de a reduce redundan\u021ba datelor \u0219i de a \xeembun\u0103t\u0103\u021bi integritatea datelor.",
                  "Bazele de date NoSQL nu sunt rela\u021bionale \u0219i de obicei nu folosesc scheme pentru modelarea datelor. Acestea suport\u0103 o mare varietate de modele de date, inclusiv document, perechi cheie-valoare, grafic \u0219i coloane.",
                  "Bazele de date NoSQL folosesc chei de identificare pentru reg\u0103sirea datelor. Fiecare element stocat \xeentr-o baz\u0103 de date NoSQL este asociat cu o cheie unic\u0103, care este utilizat\u0103 pentru a recupera datele.",
                ],
                15: [
                  "Dependen\u021ba tranzitiv\u0103 este o form\u0103 de dependen\u021b\u0103 func\u021bional\u0103 unde X determin\u0103 A indirect, prin intermediul unui set de atribute Y. Astfel, X nu este inclus \xeen nicio cheie a rela\u021biei R.",
                  "Dependen\u021ba redundant\u0103 nu este corect\u0103. Aceasta apare atunci c\xe2nd exist\u0103 dependen\u021be care pot fi derivate din altele \u0219i nu au leg\u0103tur\u0103 cu faptul c\u0103 X nu este inclus \xeen nicio cheie a rela\u021biei R.",
                  "Dependen\u021ba par\u021bial\u0103 se refer\u0103 la cazul \xeen care un atribut al rela\u021biei este func\u021bional dependent de o parte a cheii, nu de \xeentreaga cheie. Nu are leg\u0103tur\u0103 cu faptul c\u0103 X nu este inclus \xeen nicio cheie a rela\u021biei R.",
                ],
                16: [
                  "Primul pas \xeen normalizarea unei baze de date este eliminarea atributelor cu valori multiple. Aceasta este o parte important\u0103 a primei forme normale (1NF).",
                  "\xcen prima form\u0103 normal\u0103 (1NF), trebuie s\u0103 se elimine grupurile de atribute care se repet\u0103. Aceasta este o parte a procesului de normalizare a unei baze de date.",
                  "Pentru ca o rela\u021bie s\u0103 fie \xeen prima form\u0103 normal\u0103 (1NF), trebuie s\u0103 \xeendeplineasc\u0103 ambele condi\u021bii: s\u0103 nu con\u021bin\u0103 atribute cu valori multiple \u0219i s\u0103 nu aib\u0103 grupuri de atribute care se repet\u0103. Aceasta este defini\u021bia corect\u0103 a 1NF.",
                ],
                17: [
                  "Pentru ca o rela\u021bie s\u0103 fie \xeen a doua form\u0103 normal\u0103 (2NF), nu trebuie s\u0103 con\u021bin\u0103 dependen\u021be par\u021biale. Aceasta \xeenseamn\u0103 c\u0103 fiecare atribut care nu face parte din cheie trebuie s\u0103 fie dependent func\u021bional \xeen \xeentregime de cheie.",
                  "Afirma\u021bia c\u0103 o rela\u021bie este \xeen a doua form\u0103 normal\u0103 (2NF) dac\u0103 nu con\u021bine dependen\u021be tranzitive este incorect\u0103. Eliminarea dependen\u021belor tranzitive este parte a procesului de a trece la a treia form\u0103 normal\u0103 (3NF).",
                  "Afirma\u021bia c\u0103 o rela\u021bie este \xeen a doua form\u0103 normal\u0103 (2NF) dac\u0103 nu con\u021bine nici dependen\u021be par\u021biale, nici tranzitive, este incorect\u0103. Pentru 2NF, trebuie eliminat\u0103 doar dependen\u021ba par\u021bial\u0103. Dependenta tranzitiva se elimin\u0103 \xeen a treia form\u0103 normal\u0103 (3NF).",
                ],
                18: [
                  "Aceasta afirma\u021bie este incorect\u0103. O rela\u021bie este \xeen a doua form\u0103 normal\u0103 (2NF) dac\u0103 fiecare atribut care nu face parte din cheie este identificat de \xeentreaga cheie a rela\u021biei, nu doar o parte dintre atributele cheii.",
                  "Aceasta afirma\u021bie este corect\u0103. Pentru ca o rela\u021bie s\u0103 fie \xeen a doua form\u0103 normal\u0103 (2NF), fiecare atribut care nu face parte din cheie trebuie s\u0103 fie identificat de \xeentreaga cheie a rela\u021biei. Astfel, se evit\u0103 dependen\u021bele par\u021biale \u0219i se asigur\u0103 o mai bun\u0103 structurare a datelor.",
                  "Aceasta afirma\u021bie este incorect\u0103. O rela\u021bie nu este \xeen a doua form\u0103 normal\u0103 (2NF) dac\u0103 un atribut care nu face parte din cheie este identificat doar de o parte a cheii. Acest lucru duce la apari\u021bia dependen\u021belor par\u021biale, ceea ce este de evitat \xeen 2NF.",
                ],
                19: [
                  "Aceasta afirma\u021bie este incorect\u0103. Pentru ca o rela\u021bie s\u0103 fie \xeen a cincea form\u0103 normal\u0103 (5NF) sau Forma Normal\u0103 de Proiec\u021bie/Join, nu este suficient ca dependen\u021ba jonc\u021bional\u0103 care reconstituie schema R s\u0103 fie o dependen\u021b\u0103 jonc\u021bional\u0103 trivial\u0103. Exist\u0103 \u0219i alte condi\u021bii care trebuie \xeendeplinite.",
                  "Aceasta afirma\u021bie este incorect\u0103. Chiar dac\u0103 fiecare rela\u021bie \xeen dependen\u021ba jonc\u021bional\u0103 constituie o supercheie a rela\u021biei, aceasta nu garanteaz\u0103 c\u0103 rela\u021bia este \xeen a cincea form\u0103 normal\u0103 (5NF). Exist\u0103 \u0219i alte condi\u021bii care trebuie \xeendeplinite.",
                  "Ambele afirma\u021bii sunt corecte \u0219i necesare pentru ca o rela\u021bie s\u0103 fie \xeen a cincea form\u0103 normal\u0103 (5NF). Dependen\u021ba jonc\u021bional\u0103 care reconstituie schema R trebuie s\u0103 fie o dependen\u021b\u0103 jonc\u021bional\u0103 trivial\u0103 \u0219i fiecare rela\u021bie \xeen dependen\u021ba jonc\u021bional\u0103 trebuie s\u0103 constituie o supercheie a rela\u021biei.",
                ],
              },
              P = {
                1: {
                  question: "Care dintre urmatoarele afirmatii sunt corecte:",
                  options: [
                    { text: "Relatiile nu contin tupluri duplicate" },
                    {
                      text: "Multiseturile pot contine tupluri unicat si duplicate",
                    },
                    {
                      text: "Ambele afirmatii specificate la a si b sunt corecte",
                      is_correct: !0,
                    },
                  ],
                },
                2: {
                  question: "Ce reprezinta o schema in Modelul Relational",
                  options: [
                    { text: "Structura rela\u021biei", is_correct: !0 },
                    { text: "Un domeniul de valori" },
                    { text: "Multimea tuplurilor unei relatii" },
                  ],
                },
                3: {
                  question:
                    "Cererea select nume, disciplina, to_date(data_examen, \u2018YYYY\u2019) from catalog:",
                  options: [
                    {
                      text: "Va face o lista cu numele, disciplina si data de examen din anul curent, pentru fiecare student",
                    },
                    {
                      text: "Va face o lista cu numele, disciplina \u0219i anul de examen pentru fiecare student",
                      is_correct: !0,
                    },
                    { text: "Niciuna dintre variantele nu este corecta" },
                  ],
                },
                4: {
                  question:
                    "Operatia de proiectie asupra unei relatii are ca rezultat:",
                  options: [
                    {
                      text: "O relatie care contine unele atribute ale relatiei si valorile asignate lor",
                      is_correct: !0,
                    },
                    {
                      text: "O relatie care con\u021bine mul\u021bimea tuplurilor unicat din rela\u021bie",
                      is_correct: !0,
                    },
                    {
                      text: "O relatie care contine multimea tuplurilor duplicate din relatie",
                    },
                  ],
                },
                5: {
                  question:
                    "Consideram relatia TELEFOANE(ID_furnizor, serie_tel, pert_unitar) care are cheia (ID_telefon, ID_furnizor). Analizand dependentele functionale posibile, atunci relaria este in forma normala FN3?",
                  options: [
                    {
                      text: "Da, deoarece cheia este si supercheie a relatiei",
                    },
                    { text: "Nu, deoarece are dependente tranzitive" },
                    {
                      text: "Nu, deoarece are dependente par\u021biale",
                      is_correct: !0,
                    },
                  ],
                },
                6: {
                  question:
                    "Scripturile care contin comenzi SQL se pot executa in SQL*Plus daca au:",
                  options: [
                    { text: "extensia .sql sau .txt", is_correct: !0 },
                    { text: "extensia .sql" },
                    { text: "extensia .txt" },
                  ],
                },
                7: {
                  question:
                    "Daca X\u2192Y si YZ\u2192W atunci XZ\u2192W se obtine prin regula de:",
                  options: [
                    { text: "Descompunere" },
                    { text: "Pseudotranzitivitate", is_correct: !0 },
                    { text: "Reuniune" },
                  ],
                },
                8: {
                  question:
                    "Fie R o relatie si F multimea dependente functionale. R este in FN 3 daca:",
                  options: [
                    { text: "F nu contine dependente partiale" },
                    {
                      text: "R este \xeen FN2 \u0219i F nu con\u021bine dependente tranzitive",
                      is_correct: !0,
                    },
                    { text: "R este in FN2 si F contine dependente partiale" },
                  ],
                },
                9: {
                  question:
                    "Fie o dependenta functionala Y\u2192A a unei relatii, A nu face parte din cheie, atunci care afirmatie este adevarata:",
                  options: [
                    {
                      text: "Daca Y face parte dintr-o cheie a relatiei, atunci dependenta este partiala",
                    },
                    {
                      text: "Daca Y nu face parte dintr-o cheie a relatiei, atunci dependenta este tranzitiva",
                    },
                    {
                      text: "Ambele afirma\u021bii specificate a \u0219i b sunt adev\u0103rate",
                      is_correct: !0,
                    },
                  ],
                },
                10: {
                  question:
                    "In Modelul Rela\u021bional rela\u021bia reprezint\u0103:",
                  options: [
                    {
                      text: "O submultime a unui produs cartezian ob\u021binut din alte rela\u021bii",
                      is_correct: !0,
                    },
                    {
                      text: "Multimea tuplurilor care indeplinesc anumite constrangeri de integritate",
                    },
                    {
                      text: "Multimea atributelor unei relatii care au o legatura functionala intre eleEa",
                    },
                  ],
                },
                11: {
                  question:
                    "In programarea orientata pe obiecte se pot folosi urmatoarele modele de baze de date:",
                  options: [
                    { text: "Modelul obiect" },
                    { text: "Modelul obiect-relational" },
                    { text: "Ambele modele specificate", is_correct: !0 },
                  ],
                },
                12: {
                  question:
                    "Joinul natural a doua relatii se face pe coloanele:",
                  options: [
                    {
                      text: "Cu acela\u0219i nume, acela\u0219i tip \u0219i valori egale",
                      is_correct: !0,
                    },
                    { text: "Aceleasi valori, chiar si de tipuri diferite" },
                    { text: "De acelasi tip, indiferent de valori" },
                  ],
                },
                13: {
                  question: "Notatia R\u22b20\u22b3LS se foloseste pentru:",
                  options: [
                    { text: "Join natural cu conditia L" },
                    { text: "Join extern", is_correct: !0 },
                    { text: "Semi-join" },
                  ],
                },
                14: {
                  question: "O baza de date NoSQL:",
                  options: [
                    { text: "Poate suporta operatii de normalizare" },
                    {
                      text: "Nu este relationala dar foloseste scheme pt modelare",
                    },
                    {
                      text: "Foloseste chei de identificare pt regasirea datelor",
                      is_correct: !0,
                    },
                  ],
                },
                15: {
                  question:
                    "O dependenta functionala X\u2192A, in care X nu este inclusa in nicio cheie a relatiei R, se numeste:",
                  options: [
                    { text: "Dependenta tranzitiva", is_correct: !0 },
                    { text: "Dependenta redundanta" },
                    { text: "Dependenta partiala" },
                  ],
                },
                16: {
                  question: "O relatie R este in FN1 daca:",
                  options: [
                    { text: "Nu contine atribute cu valori multiple" },
                    {
                      text: "Nu exista atribute sau grupuri de atribute care se repeta",
                    },
                    {
                      text: "Ambele conditii trebuie \xeendeplinite simultan",
                      is_correct: !0,
                    },
                  ],
                },
                17: {
                  question:
                    "O relatie R este in FN2 daca, si numai daca, multimea de dependente functionale F:",
                  options: [
                    {
                      text: "Nu con\u021bine dependente par\u021biale",
                      is_correct: !0,
                    },
                    { text: "Nu contine dependente tranzitive" },
                    { text: "Ambele variante a si b sunt corecte" },
                  ],
                },
                18: {
                  question:
                    "O relatie R este in FN2 daca orice atribut al relatiei, care nu face parte din cheie:",
                  options: [
                    {
                      text: "Este identificat de intreaga cheiei sau o parte dintre atributele cheii",
                    },
                    {
                      text: "Este identificat de \xeentreaga cheie a rela\u021biei",
                      is_correct: !0,
                    },
                    {
                      text: "Este identificat de o parte dintre atributele cheii",
                    },
                  ],
                },
                19: {
                  question: "O relatie este in forma normala FN5:",
                  options: [
                    {
                      text: "Numai daca dependenta jonctionala care reconstituie schema R este o dependenta jonctionala triviala",
                    },
                    {
                      text: "Numai daca fiecare relatie in dependenta jonctionala constituie o supercheie a relatiei",
                    },
                    { text: "Ambele variante sunt corecte", is_correct: !0 },
                  ],
                },
              },
              I = function () {
                var e = T[L];
                P[e] &&
                  O[e].forEach(function (t, a) {
                    P[e].options[a] && (P[e].options[a].feedback = t);
                  });
              },
              L = 0,
              T = Object.keys(O);
            L < T.length;
            L++
          )
            I();
          for (
            var q = P,
              M = {
                1: [
                  "Aceasta este afirma\u021bia corect\u0103. Opera\u021bia de proiec\u021bie \u03c0s(G) \xeen contextul dependen\u021belor multivalorice se refer\u0103 la mul\u021bimea dependen\u021belor din G care au at\xe2t atributele din st\xe2nga c\xe2t \u0219i pe cele din dreapta incluse \xeen S.",
                  "Aceasta afirma\u021bie este incorect\u0103. Opera\u021bia de proiec\u021bie \u03c0s(G) nu se refer\u0103 doar la mul\u021bimea dependen\u021belor din G care au numai atributele din partea st\xe2ng\u0103 incluse \xeen S, ci \u0219i la atributele din dreapta.",
                  "Aceasta afirma\u021bie este incorect\u0103. Proiec\u021bia \u03c0s(G) nu se refer\u0103 doar la dependen\u021bele din G care au numai atributele din partea dreapt\u0103 incluse \xeen S. Atributele din st\xe2nga sunt de asemenea importante.",
                ],
                2: [
                  "Aceasta afirma\u021bie este par\u021bial corect\u0103. \xcenchiderea G+ a unei mul\u021bimi de dependen\u021be include dependen\u021bele func\u021bionale care sunt \xeen G sau pot fi ob\u021binute din G prin aplicarea axiomei \u0219i a regulilor. Cu toate acestea, nu acoper\u0103 \xeentreaga imagine.",
                  "Aceasta afirma\u021bie este par\u021bial corect\u0103. \xcenchiderea G+ a unei mul\u021bimi de dependen\u021be include dependen\u021bele multivalorice care sunt \xeen G sau pot fi ob\u021binute din G prin aplicarea axiomei \u0219i a regulilor. Totu\u0219i, aceasta nu reprezint\u0103 \xeentreaga situa\u021bie.",
                  "Aceasta afirma\u021bie este corect\u0103. \xcenchiderea G+ a unei mul\u021bimi de dependen\u021be include at\xe2t dependen\u021bele func\u021bionale c\xe2t \u0219i multivalorice care sunt \xeen G sau pot fi ob\u021binute din G prin aplicarea axiomei \u0219i a regulilor.",
                ],
                3: [
                  "Aceast\u0103 cerere SQL nu are o sintax\u0103 corect\u0103. Clauza WHERE nu poate fi utilizat\u0103 cu func\u021bii de agregare precum MAX(). Pentru a\u0219a ceva, trebuie utilizat\u0103 clauza HAVING.",
                  "Aceast\u0103 cerere SQL este incorect\u0103. Nu exist\u0103 o sintax\u0103 SQL care s\u0103 permit\u0103 utilizarea cuv\xe2ntului EXIST \xeen combina\u021bie cu o func\u021bie de agregare precum MAX() \xeen clauza WHERE.",
                  "Aceasta este sintaxa corect\u0103 pentru o cerere SQL. Func\u021bia de agregare MAX() este utilizat\u0103 corect cu clauza HAVING pentru a filtra rezultatele grup\u0103rilor efectuate de clauza GROUP BY.",
                ],
                4: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Pseudotranzitivitatea nu este implicat\u0103 \xeen generarea A \u2192\u2192 B din B \u2264 A. Pseudotranzitivitatea este o proprietate care implic\u0103 dependen\u021bele func\u021bionale \u0219i multivalorice simultan.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Augmentarea este o axioma care permite ad\u0103ugarea unor atribute at\xe2t pe partea st\xe2ng\u0103 c\xe2t \u0219i pe partea dreapt\u0103 a unei dependen\u021be. Aceasta nu este relevant\u0103 pentru generarea A \u2192\u2192 B din B \u2264 A.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Axioma de reflexivitate este implicat\u0103 \xeen generarea A \u2192\u2192 B din B \u2264 A. Conform acestei axiome, dac\u0103 un set de atribute B este un subset al unui set de atribute A, atunci A determin\u0103 B.",
                ],
                5: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 exist\u0103 o dependen\u021b\u0103 func\u021bional\u0103 A \u2192 B, atunci implicit exist\u0103 \u0219i o dependen\u021b\u0103 multivalorat\u0103 A \u2192\u2192 B. Dependen\u021ba multivalorat\u0103 este mai general\u0103 \u0219i include \u0219i dependen\u021bele func\u021bionale.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Dac\u0103 exist\u0103 o dependen\u021b\u0103 func\u021bional\u0103 A \u2192 B, nu rezult\u0103 automat c\u0103 B determin\u0103 A. Direc\u021bia dependen\u021bei conteaz\u0103.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Nu se poate presupune c\u0103 dac\u0103 A determin\u0103 func\u021bional B, atunci B determin\u0103 multivalorat A. Dependen\u021ba nu se inverseaz\u0103 pur \u0219i simplu.",
                ],
                6: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Regula de tranzitivitate nu este implicat\u0103 aici. Tranzitivitatea se aplic\u0103 c\xe2nd avem dou\u0103 dependen\u021be, A \u2192 B \u0219i B \u2192 C, pentru a genera o a treia, A \u2192 C.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Descompunerea este procesul invers, adic\u0103 dac\u0103 avem A \u2192\u2192 BC, putem ob\u021bine A \u2192\u2192 B \u0219i A \u2192\u2192 C.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 avem dependen\u021bele multivalorice A \u2192\u2192 B \u0219i A \u2192\u2192 C, atunci prin regula de reuniune putem ob\u021bine A \u2192\u2192 BC.",
                ],
                7: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Pentru ca o rela\u021bie s\u0103 fie \xeen FN2, nu trebuie s\u0103 existe dependen\u021be partiale. A\u0219adar, nu putem confirma c\u0103 rela\u021bia este \xeen FN2 doar conform defini\u021biei sale.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 rela\u021bia are dependen\u021be partiale, cum ar fi dac\u0103 'den_comp' sau 'den_furniz' depind doar de 'cod_comp' sau 'cod_furniz', respectiv, atunci aceasta nu este \xeen FN2.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. FN1 este un nivel inferior al normaliz\u0103rii. Pentru ca o rela\u021bie s\u0103 fie \xeen FN2, trebuie s\u0103 fie mai \xeent\xe2i \xeen FN1, dar acesta nu este motivul pentru care rela\u021bia nu este \xeen FN2.",
                ],
                8: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Operatorii = \u0219i != sunt folosi\u021bi pentru compararea unui singur rezultat cu o valoare, nu pentru o \xeentreag\u0103 subcerere SQL care returneaz\u0103 mai multe linii.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Operatorii IS \u0219i IS NOT sunt folosi\u021bi pentru a verifica dac\u0103 o valoare este NULL sau nu, nu sunt folosi\u021bi pentru a opera cu subcereri SQL care returneaz\u0103 mai multe linii.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Operatorii IN \u0219i NOT IN sunt folosi\u021bi pentru a verifica dac\u0103 un rezultat se afl\u0103 \xeen setul de rezultate returnat de o subcerere SQL, fiind potrivi\u021bi pentru cazul \xeen care subcererea returneaz\u0103 mai multe linii.",
                ],
                9: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103. \xcentr-o rela\u021bie multi-unu, descriptorul unei entit\u0103\u021bi se va modela ca entitate, mai degrab\u0103 dec\xe2t ca atribut. Acesta este un mod de reprezentare tipic pentru acest tip de rela\u021bie \xeen modelul Entitate-Asociere.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. De\u0219i exist\u0103 situa\u021bii \xeen care un descriptor ar putea fi modelat fie ca entitate, fie ca atribut, \xeentr-o rela\u021bie multi-unu, este mai tipic s\u0103 se modeleze ca entitate.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. \xcentr-o rela\u021bie multi-unu, este mai pu\u021bin tipic s\u0103 se modeleze descriptorul ca atribut. De obicei, descriptorul se va modela ca entitate.",
                ],
                10: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Multimile F \u0219i G sunt echivalente, deoarece fiecare dependen\u021b\u0103 din F poate fi ob\u021binut\u0103 din G \u0219i invers. Aceasta \xeenseamn\u0103 c\u0103 acelea\u0219i atribute pot fi determinate \xeen ambele cazuri.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Multimile F \u0219i G sunt echivalente, iar faptul c\u0103 unele dependen\u021be sunt exprimate \xeentr-o ordine diferit\u0103 \xeen G nu schimb\u0103 acest fapt.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Echivalen\u021ba \xeentre F \u0219i G nu depinde de context. Dac\u0103 toate dependen\u021bele din F pot fi ob\u021binute din G \u0219i invers, atunci F \u0219i G sunt echivalente.",
                ],
                11: [
                  "Mai e una corecta. Daca trebuie sa alegi o singura varianta, alege A \u2192\u2192 B.R\u0103spunsul t\u0103u este corect. Dependenta multivaloric\u0103 A \u2192\u2192 B este valid\u0103 \xeen contextul dat. Aceasta \xeenseamn\u0103 c\u0103, pentru o valoare fix\u0103 a atributului A, exist\u0103 mai multe valori posibile pentru atributul B. Dependen\u021ba multivaloric\u0103 valid\u0103 indic\u0103 faptul c\u0103 atributul A determin\u0103 \xeen mod multiplu atributul B.",
                  "R\u0103spunsul t\u0103u este incorect. B \u2192\u2192 C nu reprezint\u0103 o dependen\u021b\u0103 multivaloric\u0103 valid\u0103 \xeen contextul dat. O dependen\u021b\u0103 multivaloric\u0103 B \u2192\u2192 C ar \xeensemna c\u0103 pentru o valoare fix\u0103 a atributului B, exist\u0103 mai multe valori posibile pentru atributul C, ceea ce nu este cazul \xeen situa\u021bia descris\u0103.",
                  "Mai e una corecta. Daca trebuie sa alegi o singura varianta, alege A \u2192\u2192 B. R\u0103spunsul t\u0103u este corect. Dependenta multivaloric\u0103 A \u2192\u2192 C este de asemenea valid\u0103 \xeen contextul dat. Acest lucru \xeenseamn\u0103 c\u0103, pentru o valoare fix\u0103 a atributului A, exist\u0103 mai multe valori posibile pentru atributul C. Acest tip de dependen\u021b\u0103 indic\u0103 faptul c\u0103 atributul A determin\u0103 \xeen mod multiplu atributul C.",
                ],
                12: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Un rol \xeen modelul Entitate-Asociere nu este numele atribuit asocierii dintre dou\u0103 entit\u0103\u021bi. Rolul are de-a face cu semnifica\u021bia unei anumite ramuri a unei asocieri \xeentre entit\u0103\u021bi.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Un rol nu este o asociere \xeentre dou\u0103 entit\u0103\u021bi. Rolul are mai degrab\u0103 de-a face cu semnifica\u021bia pe care o are o anumit\u0103 ramur\u0103 a unei asocieri pentru o entitate \xeen parte.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, ai \xeen\u021beles corect ce reprezint\u0103 un rol \xeen modelul Entitate-Asociere. Un rol reprezint\u0103 semnifica\u021bia pe care o are o anumit\u0103 ramur\u0103 a unei asocieri pentru o entitate \xeen parte.",
                ],
                13: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, ai interpretat gre\u0219it utilizarea clauzei WHERE. WHERE nu poate fi folosit cu func\u021bii de agregare precum MAX.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Nu se poate utiliza clauza MAX \xeen cadrul unei clauze WHERE \u0219i nu se poate utiliza GROUP BY \xeen aceea\u0219i clauz\u0103 cu WHERE.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, \xeen\u021belegi cum func\u021bioneaz\u0103 clauza HAVING. Aceasta este utilizat\u0103 pentru a filtra rezultatele ob\u021binute dup\u0103 aplicarea unei func\u021bii de agregare, cum ar fi MAX, \xeen combina\u021bie cu clauza GROUP BY.",
                ],
                14: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, \xeen\u021belegi corect cum func\u021bioneaz\u0103 opera\u021biile JOIN \xeen SQL. \xcen acest caz, joinul va avea patru coloane, conform imaginii prezentate.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, ai interpretat gre\u0219it num\u0103rul de coloane rezultate \xeen urma opera\u021biei de JOIN. \xcen acest caz, num\u0103rul corect de coloane este patru, nu cinci.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, ai interpretat gre\u0219it num\u0103rul de coloane rezultate \xeen urma opera\u021biei de JOIN. \xcen acest caz, num\u0103rul corect de coloane este patru, nu \u0219ase.",
                ],
                15: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, \xeen\u021belegi corect ce reprezint\u0103 o dependen\u021b\u0103 func\u021bional\u0103. Orice dou\u0103 tupluri care au acelea\u0219i valori pe atributele X vor avea \u0219i acelea\u0219i valori pe atributele Y.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Faptul c\u0103 toate atributele care apar \xeen partea st\xe2ng\u0103 a oric\u0103rei dependen\u021be func\u021bionale sunt din X \u0219i Y nu define\u0219te o dependen\u021b\u0103 func\u021bional\u0103.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. O dependen\u021b\u0103 func\u021bional\u0103 nu se refer\u0103 la determinarea unui singur atribut din Y de c\u0103tre un atribut din X. Se refer\u0103 la determinarea tuturor valorilor din Y de c\u0103tre un set de valori din X.",
                ],
                16: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN4 nu accept\u0103 numai dependen\u021be multivalorice. Accept\u0103 at\xe2t dependen\u021be multivalorice, c\xe2t \u0219i dependen\u021be func\u021bionale.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN4 nu accept\u0103 numai dependen\u021be func\u021bionale. Accept\u0103 at\xe2t dependen\u021be multivalorice, c\xe2t \u0219i dependen\u021be func\u021bionale.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Dac\u0103 ai ales aceast\u0103 op\u021biune, ai \xeen\u021beles corect ce presupune o rela\u021bie care este \xeen forma normal\u0103 FN4. Aceasta accept\u0103 at\xe2t dependen\u021be multivalorice, c\xe2t \u0219i dependen\u021be func\u021bionale.",
                ],
                17: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103, dar nu este complet\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN4 este de asemenea \u0219i \xeen forma normal\u0103 FN3, dar nu este men\u021bionat\u0103 \u0219i prezen\u021ba \xeen forma normal\u0103 FNBC (Forma Normal\u0103 Boyce-Codd).",
                  "Aceast\u0103 afirma\u021bie este corect\u0103, dar nu este complet\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN4 este de asemenea \u0219i \xeen forma normal\u0103 FNBC (Forma Normal\u0103 Boyce-Codd), dar nu este men\u021bionat\u0103 \u0219i prezen\u021ba \xeen FN3.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103 \u0219i complet\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN4 este \u0219i \xeen forma normal\u0103 FN3 \u0219i FNBC. Ai \xeen\u021beles corect ierarhia formelor normale \xeen bazele de date.",
                ],
                18: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103, dar nu este complet\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN5 este de asemenea \u0219i \xeen forma normal\u0103 FN4, dar nu este men\u021bionat\u0103 \u0219i prezen\u021ba \xeen forma normal\u0103 FN3.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103, dar nu este complet\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN5 este de asemenea \u0219i \xeen forma normal\u0103 FN3, dar nu este men\u021bionat\u0103 \u0219i prezen\u021ba \xeen FN4.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103 \u0219i complet\u0103. O rela\u021bie care este \xeen forma normal\u0103 FN5 este \u0219i \xeen forma normal\u0103 FN4 \u0219i FN3. Ai \xeen\u021beles corect ierarhia formelor normale \xeen bazele de date.",
                ],
                19: [
                  "R\u0103spunsul \u201eFNBC\u201d este incorect deoarece se refer\u0103 numai la Forma Normal\u0103 Boyce-Codd. De\u0219i este adev\u0103rat c\u0103 \xeen Forma Normal\u0103 Boyce-Codd orice dependen\u021b\u0103 multivalorat\u0103 netrivial\u0103 X \u2192\u2192 Y trebuie s\u0103 aib\u0103 \xeen partea st\xe2ng\u0103 o supercheie, aceasta nu este singura form\u0103 normal\u0103 care \xeendepline\u0219te aceast\u0103 proprietate. Forma a patra normal\u0103 (4NF) are aceea\u0219i caracteristic\u0103.",
                  "R\u0103spunsul \u201eFN4\u201d este, de asemenea, incorect. Acesta se refer\u0103 la Forma a Patra Normal\u0103 (4NF), care, \xeentr-adev\u0103r, asigur\u0103 c\u0103 orice dependen\u021b\u0103 multivalorat\u0103 netrivial\u0103 X \u2192\u2192 Y are \xeen partea st\xe2ng\u0103 o supercheie. Cu toate acestea, acest lucru este, de asemenea, valabil \u0219i pentru Forma Normal\u0103 Boyce-Codd (BCNF). Prin urmare, a alege doar FN4 nu reflect\u0103 \xeen totalitate cerin\u021ba.",
                  "R \u0103spunsul \u201eFNBC \u0219i FN4\u201d este corect. Atunci c\xe2nd un schema de rela\u021bie R este \xeen Forma Normal\u0103 Boyce-Codd (BCNF), orice dependen\u021b\u0103 multivalorat\u0103 netrivial\u0103 X \u2192\u2192 Y are \xeen partea st\xe2ng\u0103 o supercheie. Aceea\u0219i proprietate este valabil\u0103 \u0219i pentru Forma a Patra Normal\u0103 (4NF). Prin urmare, o schema care \xeendepline\u0219te aceast\u0103 proprietate poate fi considerat\u0103 a fi at\xe2t \xeen BCNF, c\xe2t \u0219i \xeen 4NF (Ne-am orientat dupa asta in doc: Regulile pentru a fi in FN4? R: este in FNBC si daca orice dependenta multivalorica netriviala X->->Y are in partea stanga o supercheie)",
                ],
                20: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Subcererile SQL corelate nu se execut\u0103 doar atunci c\xe2nd sunt folosite \xeen clauza HAVING.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Subcererile SQL corelate nu se execut\u0103 o singur\u0103 dat\u0103 pentru toate liniile din cererea principal\u0103.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Subcererile SQL corelate se execut\u0103 pentru fiecare linie candidat din cererea principal\u0103, de aceea pot fi adesea mai lente dec\xe2t subcererile obi\u0219nuite.",
                ],
                21: [
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Regula proiec\u021biei pentru joinuri indic\u0103 c\u0103 pi_An(pi_Bk(RS)) = pi_An(RS), dac\u0103 An este inclus \xeen Bk.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Aceasta nu este regula corect\u0103 pentru proiec\u021bia unui join \xeen SQL.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Aceasta nu este regula corect\u0103 pentru proiec\u021bia unui join \xeen SQL.",
                ],
                22: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Selectul (proiec\u021bia) nu trebuie deplasat spre r\u0103d\u0103cin\u0103 \xeen arbore, ci spre frunze.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Selectul (proiec\u021bia) trebuie deplasat \xeen arbore spre frunze pentru a optimiza interogarea SQL.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Direc\u021bia de deplasare a selectului \xeen arbore nu depinde de caz. El trebuie \xeentotdeauna deplasat spre frunze.",
                ],
                23: [
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Inserarea datelor printr-un view nu este \xeentotdeauna posibil\u0103, chiar dac\u0103 se respect\u0103 tipurile de date declarate \xeen tabel\u0103.",
                  "Aceast\u0103 afirma\u021bie este corect\u0103. Inserarea datelor printr-un view este posibil\u0103 doar prin vederile create pe o singur\u0103 tabel\u0103, respect\xe2nd constr\xe2ngerile de integritate.",
                  "Aceast\u0103 afirma\u021bie este incorect\u0103. Un view poate fi folosit nu doar pentru vizualizarea datelor, dar \u0219i pentru inserarea datelor, \xeen anumite condi\u021bii.",
                ],
              },
              j = {
                1: {
                  question:
                    "Fie relatia R, G o multime de dependente multivalorice si o multime de atribute S \u2264 R Atunci \u03c0 reprezinta: \ud835\udc60 (\ud835\udc3a) Obs: Operatorul \u2264 se refera la incluziune",
                  options: [
                    {
                      text: "Multimea dependentelor din \ud835\udc3a care au atat atributele din stanga cat si pe cele din + dreapta incluse in S",
                      is_correct: !0,
                    },
                    {
                      text: "Multimea dependentelor din G care au numai atributele din partea stanga incluse in S",
                    },
                    {
                      text: "Multimea dependentelor din G care au numai atributele din partea dreapta incluse in S",
                    },
                  ],
                },
                2: {
                  question:
                    "Fie G o multime de dependente functionale si multivalorice pe o relatie R. Inchiderea G+ contine:",
                  options: [
                    {
                      text: "Multimea dependentelor functionale din G sau se pot obtine din G prin axiome si reguli",
                    },
                    {
                      text: "Multimea dependentelor multivalorice din G sau se pot obtine din G prin axiome si reguli",
                    },
                    {
                      text: "Ambele variante prezentate sunt adevarate",
                      is_correct: !0,
                    },
                  ],
                },
                3: {
                  question:
                    "Care dintre urmatoarele cereri SQL are o sintaxa corecta: ",
                  options: [
                    {
                      text: "Select job, max(salariu) from angajati_dep where max(salariu) > 1000 group by job",
                    },
                    {
                      text: "Select job, max(salariu) from angajati_dep where exist max(salariu) > 1000 group by job",
                    },
                    {
                      text: "Select job, max(salariu) from angajati_dep having max(salariu) > 1000 group by job",
                      is_correct: !0,
                      feedback: "",
                    },
                  ],
                },
                4: {
                  question:
                    "Daca B \u2264 A atunci A \u2192\u2192 B se obtine prin axioma de: Obs: Operatorul \u2264 se refera la incluziune",
                  options: [
                    { text: "Pseudotranzitivitate" },
                    { text: "Augumentare" },
                    { text: "Reflexivitate", is_correct: !0 },
                  ],
                },
                5: {
                  question:
                    "Daca avem dependenta functionala A \u2192 B atunci avem totdeauna dependenta valida:",
                  options: [
                    { text: "A \u2192\u2192 B", is_correct: !0 },
                    { text: "B \u2192 A" },
                    { text: "B \u2192\u2192 A" },
                  ],
                },
                6: {
                  question:
                    "Daca avem dependentele multivalorice A \u2192\u2192 B si A \u2192\u2192 C atunci A \u2192\u2192 BC se obtine prin regula de:",
                  options: [
                    { text: "Tranzitivitate" },
                    { text: "Descompunere" },
                    { text: "Reuniune", is_correct: !0 },
                  ],
                },
                7: {
                  question:
                    "Daca consideram ca relatia COMPONENTE(cod_comp, den_comp, cod_furniz, den_furniz, pret_unitar) are cheia (cod_comp,cod_furniz) atunci e in forma normala FN2:",
                  options: [
                    { text: "Da, conform definitiei" },
                    {
                      text: "Nu, pentru ca are dependente partiale ",
                      is_correct: !0,
                    },
                    { text: "Nu, pt ca nu este in FN1" },
                  ],
                },
                8: {
                  question:
                    "Daca o subcerere SQL returneaza o linie(minim doua coloane), in conditiile puse in clauza WHERE a cererii principale pe aceste linii se pot folosi operatorii: ",
                  options: [
                    { text: "= , !=" },
                    { text: "IS, IS NOT" },
                    { text: "IN, NOT IN", is_correct: !0 },
                  ],
                },
                9: {
                  question:
                    "Daca un descriptor al unei entitati este intr-o relatie multi-unu cu o alta entitate in modelul Entitate-Asociere, atunci:",
                  options: [
                    {
                      text: "Descriptorul se va modela ca entitate",
                      is_correct: !0,
                    },
                    {
                      text: "Descriptorul se va modela fie ca atribut, fie ca entitate, in functie de context",
                    },
                    { text: "Descriptorul se va modela ca atribut" },
                  ],
                },
                10: {
                  question:
                    "Fie R = ABCDE si multimea de dependente asociata F = {A\u2192B, D\u2192E, C\u2192D, E\u2192C}. Multimea F este echivalenta cu G = {A\u2192B, C\u2192E, E\u2192D, D\u2192C}",
                  options: [
                    { text: "Da", is_correct: !0 },
                    { text: "Nu" },
                    { text: "Depinde de context" },
                  ],
                },
                11: {
                  question:
                    "Fie relatia R = ABC si t1, t2, t3, t4 tupluri ale relatiei. Conform asignarilor din tabel pe relatia R avem urmatoarea dependenta multivalorica valida:",
                  options: [
                    { text: "A \u2192\u2192 B", is_correct: !0 },
                    { text: "B \u2192\u2192 C" },
                    { text: "A \u2192\u2192 C", is_correct: !0 },
                  ],
                  questionImage:
                    "https://media.quizizz.com/_mdserver/main/media/resource/gs/quizizz-media/quizzes/24e6bacd-7db0-4cfc-bed4-38d84ea26c0b-v2?w=600&h=600",
                },
                12: {
                  question: "In modelul EA un rol reprezinta:",
                  options: [
                    { text: "Numele atribuit asocierii dintre doua entitati" },
                    { text: "O asociere intre doua entitati" },
                    {
                      text: "O semnificatie a unei ramuri a asocierii realizata pe o singura entitate",
                      is_correct: !0,
                    },
                  ],
                },
                13: {
                  question:
                    "Intr-o cerere SELECT care din urmatoarele clauze este corecta:",
                  options: [
                    { text: "WHERE EXIST max(salariu) > 1000" },
                    { text: "WHERE max(salariu) > 1000 GROUP BY ..." },
                    {
                      text: "HAVING max(salariu) > 1000 GROUP BY ...",
                      is_correct: !0,
                    },
                  ],
                },
                14: {
                  question:
                    "Joinul anterior va avea un numar de coloane egal cu:",
                  options: [
                    {
                      text: "4 (nu se poate afla joinul anterior dar e 4)",
                      is_correct: !0,
                    },
                    { text: "5" },
                    { text: "6" },
                  ],
                  questionImage:
                    "https://media.quizizz.com/_mdserver/main/media/resource/gs/quizizz-media/quizzes/b6f1e35b-3f51-400e-8034-248c65a844dd-v2?w=600&h=600",
                },
                15: {
                  question:
                    "O multime de atribute X determina functional alta multime de atribute Y daca:",
                  options: [
                    {
                      text: "Oricare doua tupluri care au aceleasi valori pe atributele X atunci au aceleasi valori si pe atributele Y",
                      is_correct: !0,
                    },
                    {
                      text: "Toate atributele care apar in partea stanga a oricarei dependente functionale sunt din X si Y",
                    },
                    {
                      text: "Un atribut din X determina un singur atribut din Y",
                    },
                  ],
                },
                16: {
                  question:
                    "O relatie R care este in forma normala FN4 accepta:",
                  options: [
                    { text: "Numai dependente multivalorice" },
                    { text: "Numai dependente functionale" },
                    {
                      text: "Atat dependente multivalorice cat si dependente functionale",
                      is_correct: !0,
                    },
                  ],
                },
                17: {
                  question:
                    "O relatie R care este in forma normala FN4 este si in:",
                  options: [
                    { text: "Forma normala FN3" },
                    { text: "Forma normala FNBC" },
                    {
                      text: "Ambele variante prezentate la a si b sunt adevarate",
                      is_correct: !0,
                    },
                  ],
                },
                18: {
                  question:
                    "O relatie R care este in forma normala FN5 este si in:",
                  options: [
                    { text: "Forma normala FN4" },
                    { text: "Forma normala FN3" },
                    {
                      text: "Ambele variante prezentate la a si b sunt adevarate",
                      is_correct: !0,
                    },
                  ],
                },
                19: {
                  question:
                    "O schema de relatie R la care orice dependenta multivalorica netriviala X \u2192\u2192 Y are in partea stanga o supercheie, atunci este in forma normala:",
                  options: [
                    { text: "FNBC" },
                    { text: "FN4" },
                    { text: "FNBC si FN4", is_correct: !0 },
                  ],
                },
                20: {
                  question: "O subcerere SQL corelata se executa:",
                  options: [
                    { text: "Doar atunci cand este folosita in clauza HAVING" },
                    {
                      text: "O singura data pentru toate liniile din cererea principalaa",
                    },
                    {
                      text: "Pentru fiecare linie candidat din cererea principala",
                      is_correct: !0,
                    },
                  ],
                },
                21: {
                  question: "pi_An(pi_Bk(R*S)) =",
                  options: [
                    {
                      text: "pi_An(R*S) \u2192 An inclus in Bk",
                      is_correct: !0,
                    },
                    { text: "pi_Bk(R*S)" },
                    { text: "pi_(An U Bk) (R*S) (reuniune)" },
                  ],
                },
                22: {
                  question: "Select-ul (proiectia) trebuie deplasat in arbore:",
                  options: [
                    { text: "Spre radacina" },
                    { text: "Spre frunze", is_correct: !0 },
                    { text: "Depinde de caz" },
                  ],
                },
                23: {
                  question:
                    "Inserarea datelor intr-o tabela, prin intermediul unui view, se poate face:",
                  options: [
                    {
                      text: "Totdeauna, daca se respecta tipurile de date declarate in tabela",
                    },
                    {
                      text: "Numai prin vederile create pe o singura tabela, respectand constrangerile de integritate",
                      is_correct: !0,
                    },
                    {
                      text: " Niciodata, deoarece un view este folosit pt vizualizarea datelor",
                    },
                  ],
                },
              },
              U = function () {
                var e = Y[Q];
                j[e] &&
                  M[e].forEach(function (t, a) {
                    j[e].options[a] && (j[e].options[a].feedback = t);
                  });
              },
              Q = 0,
              Y = Object.keys(M);
            Q < Y.length;
            Q++
          )
            U();
          for (
            var H = j,
              X = {
                1: {
                  question:
                    "Operatorul lista_atribute \u03c4_lista_atribute (R) are ca efect:",
                  options: [
                    { text: "Proiectia relatiei R dupa atributele din lista" },
                    {
                      text: "Ordonarea relatiei R dupa atributele din lista",
                      is_correct: !0,
                    },
                    { text: "Gruparea relatiei R dupa atributele din lista" },
                  ],
                },
                2: {
                  question: "Un model de date reprezinta",
                  options: [
                    {
                      text: "Un ansamblu de reguli si concepte pentru descrierea structurii unei BD",
                      is_correct: !0,
                    },
                    { text: "O colectie de fisiere de date" },
                    { text: "O metoda de stocare a datelor pe suport fizic" },
                  ],
                },
                3: {
                  question: "Constrangerile de integritate reprezinta:",
                  options: [
                    {
                      text: "Verificarea automata a datelor in cazul operatiilor de inserare, stergere si modificare",
                      is_correct: !0,
                    },
                    {
                      text: "Metode de verificare a drepturilor de acces la date",
                    },
                    { text: "Ambele variante sunt corecte" },
                  ],
                },
                4: {
                  question: "O entitate a bazei de date reprezinta",
                  options: [
                    { text: "O asociere intre obiecte" },
                    {
                      text: "Un obiect al bazei de date care are o reprezentare unica",
                      is_correct: !0,
                    },
                    { text: "O clasificare a unor obiecte" },
                  ],
                },
                5: {
                  question:
                    "Daca X\u2192Y atunci si XZ\u2192YZ se obtine prin axioma de:",
                  options: [
                    { text: "Reflexivitate" },
                    { text: "Tranzitivitate" },
                    { text: "Augmentare", is_correct: !0 },
                  ],
                },
                6: {
                  question:
                    "Tabela\nCARTI(id_carte, titlu, id_autor, editura)\nse poate relationa cu\nAUTORI(id_autor, nume, adresa):",
                  options: [
                    {
                      text: "Da, dupa id_autor, daca in AUTORI este definita cheie primara sau cheie unica",
                      is_correct: !0,
                    },
                    {
                      text: "Da, dupa id_autor, cu conditia sa fie de acelasi tip in ambele tabele",
                    },
                    {
                      text: "Da, dupa id_autor, numai daca coloana este cheie primara in ambele tabele",
                    },
                  ],
                },
                7: {
                  question:
                    "Modelul Entitate-Asociere extins permite reprezentarea bazei de date prin:",
                  options: [
                    {
                      text: "Atribute, asocieri si constrangeri de integritate",
                    },
                    {
                      text: "Entitati, atribute ale entitatilor, asocieri si ierarhii",
                      is_correct: !0,
                    },
                    { text: "Entitati, ierarhii si chei" },
                  ],
                },
                8: {
                  question:
                    "Daca consideram ca o carte are un singur autor, rezultatul transformarii din modelul EA in MR pt entitatile\nCARTI(id_carte, titlu, editura)\nsi\nAUTORI(id_autor, nume, adresa)\neste:",
                  options: [
                    {
                      text: "CARTI(id_carte, titlu, editura, id_autor), AUTORI(id_autor, nume, adresa)",
                      is_correct: !0,
                    },
                    {
                      text: "CARTI(id_carte, titlu, editura, id_autor), AUTORI(id_autor, nume, adresa, id_carte)",
                    },
                    {
                      text: "CARTI(id_carte, titlu, editura), AUTORI(id_autor, nume, adresa, id_carte)",
                    },
                  ],
                },
                9: {
                  question:
                    "O coloana a unei tabele pe care se defineste o cheie FOREIGN KEY, se poate relationa cu:",
                  options: [
                    { text: "O coloana din alta tabela definita cheie unica" },
                    {
                      text: "O coloana din alta tabela definita cheie primara",
                    },
                    { text: "Ambele variante sunt corecte", is_correct: !0 },
                  ],
                },
                10: {
                  question:
                    "Fie relatia R\u2192ABCDE,\ncu multimea de dependente functionale\nF = {A\u2192B, AE\u2192C, D\u2192A, B\u2192D}.\nCare descompunere are proprietatea de join fara pierderi ?",
                  options: [
                    { text: "P = (ADE, BCE)" },
                    { text: "P = (ABD, ACE)", is_correct: !0 },
                    { text: "P = (ABC, DE)" },
                  ],
                },
                11: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192B, B\u2192C, A\u2192C, D\u2192E}.\nAtunci o cheie a lui R este:",
                  options: [
                    { text: "AD", is_correct: !0 },
                    { text: "CD" },
                    { text: "ACD" },
                  ],
                },
                12: {
                  question:
                    "Multimea de dependente functionale\nF = {AB\u2192CDE, D\u2192E}\nare forma canonica:",
                  options: [
                    { text: "{A\u2192B, A\u2192C, D\u2192E}" },
                    {
                      text: "{AB\u2192C, AB\u2192D, D\u2192E}",
                      is_correct: !0,
                    },
                    { text: "{AB\u2192C, AB\u2192E}" },
                  ],
                },
                13: {
                  question:
                    "F = {A\u2192B, A\u2192F, B\u2192E, D\u2192B, F\u2192A},\natunci\nP = (AB, DCD, DEF, CDE)\npastreaza dependentele functionale pe F ?",
                  options: [
                    { text: "Da" },
                    { text: "Nu", is_correct: !0 },
                    {
                      text: "Nu se poate aplica algoritmul de verificare in acest caz",
                    },
                  ],
                },
                14: {
                  question:
                    "Atunci cand o relatie R poate fi reconstruita fara pierderi din unele proiectii ale sale, se spune ca avem :",
                  options: [
                    { text: "O dependenta jonctionala", is_correct: !0 },
                    { text: "O dependenta multivalorica" },
                    { text: "O dependenta triviala" },
                  ],
                },
                15: {
                  question:
                    "Care dintre urmatoarele relatii de incluziune sunt adevarate:",
                  options: [
                    { text: "FN3 < FNBC < FN4" },
                    { text: "FN5 < FN4 < FNBC", is_correct: !0 },
                    { text: "FNBC < FN3 < FN4" },
                  ],
                },
                16: {
                  question:
                    "Daca X\u2192\u2192Y si WY\u2192\u2192Z, atunci WX\u2192\u2192Z - WY se obtine prin axioma de:",
                  options: [
                    { text: "Diferenta" },
                    { text: "Augmentare" },
                    { text: "Pseudotranzitivitate", is_correct: !0 },
                  ],
                },
                17: {
                  question: "Graful de strategii reprezinta :",
                  options: [
                    { text: "O metoda pt descompunerea schemelor de relatii" },
                    {
                      text: "O metoda pt studierea tehnicilor de optimizare a interogarilor",
                      is_correct: !0,
                    },
                    { text: "O metoda de reprezentare a bazei de date" },
                  ],
                },
                18: {
                  question: "O functie SQL de grup se poate folosi direct in:",
                  options: [
                    {
                      text: "Clauza WHERE a unei cereri SELECT, impreuna cu clauza GROUP BY",
                    },
                    {
                      text: "Clauza WHERE a unei cereri SELECT, fara a folosi subcereri",
                    },
                    {
                      text: "Clauza HAVING a unei cereri SELECT",
                      is_correct: !0,
                    },
                  ],
                },
                19: {
                  question:
                    "O cerere SELECT cu un join de tip OUTER JOIN... ON returneaza:",
                  options: [
                    {
                      text: "Numai liniile rezultate din corelarea liniilor cu valori nule pe coloanele de join",
                    },
                    {
                      text: "Numai liniile rezultate din corelarea liniilor cu valori nenule",
                    },
                    {
                      text: "Liniile rezultate din corelarea liniilor cu valori nule si nenule pe coloanele de join relatie",
                      is_correct: !0,
                    },
                  ],
                },
                20: {
                  question: "O baza de date SQL:",
                  options: [
                    { text: "Poate suporta operatii de normalizare" },
                    {
                      text: "Nu este relationala dar foloseste scheme pt modelare",
                    },
                    {
                      text: "Foloseste chei de identificare pt regasirea datelor",
                      is_correct: !0,
                    },
                  ],
                },
                21: {
                  question:
                    "Inserarea datelor intr-o tabela, prin intermediul unui view, se poate face:",
                  options: [
                    {
                      text: "Totdeauna, daca se respecta tipurile de date declarate in tabela",
                    },
                    {
                      text: "Numai prin vederile create pe o singura tabela, respectand constrangerile de integritate",
                      is_correct: !0,
                    },
                    {
                      text: "Niciodata, deoarece un view este folosit pt vizualizarea datelor",
                    },
                  ],
                },
                22: {
                  question: "Un atribut reprezinta:",
                  options: [
                    {
                      text: "o proprietate ce descrie o anumita caracteristica a unei entitati",
                      is_correct: !0,
                    },
                    { text: "un obiect al bd" },
                    { text: "o colectie de date" },
                  ],
                },
                23: {
                  question:
                    "Organizarea datelor sub forma unui graf orientat e folosita in:",
                  options: [
                    { text: "modelul ierarhic" },
                    { text: "modelul retea", is_correct: !0 },
                    {
                      text: "a - posibilitate. b - gresit (\ud83d\udd75 era corect retea dar nu stiu)",
                    },
                  ],
                },
                25: {
                  question: "",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/90743dea-d9dd-4247-a47a-ea93a7ff9c27?w=600&h=600",
                  options: [
                    { text: "C\u2192\u2192A" },
                    { text: "B\u2192\u2192C" },
                    { text: "A\u2192\u2192B", is_correct: !0 },
                  ],
                },
                24: {
                  question:
                    "Independenta logica a datelor se refera la posibilitatea de:",
                  options: [
                    {
                      text: "Schimbare a schemei externe fara modificarea schemelor interne",
                    },
                    {
                      text: "Schimbare a schemei conceptuale fara modificarea schemelor externe",
                      is_correct: !0,
                    },
                    {
                      text: "Schimbare a schemei interne fara modf schemelor conceptuale",
                    },
                  ],
                },
                26: {
                  question:
                    "Elementele unei relatii in Modelul Relational se numesc:",
                  options: [
                    { text: "Domenii" },
                    { text: "Atribute" },
                    { text: "Tupluri", is_correct: !0 },
                  ],
                },
                27: {
                  question:
                    "Schema unei relatii in Modelul Relational reprezinta:",
                  options: [
                    { text: "Structura unei tabele", is_correct: !0 },
                    { text: "O reprezentare schematica a relatiei" },
                    { text: "Un domeniu de valori pentru relatie" },
                  ],
                },
                28: {
                  question: "O cheie PRIMARY KEY a unei relatii NU accepta:",
                  options: [
                    { text: "Valori nule pe coloanele care o definesc" },
                    { text: "Valori duplicate pe coloanele care o definesc" },
                    { text: "Pe ambele", is_correct: !0 },
                  ],
                },
                29: {
                  question:
                    "Pentru a sterge date dintr-o coloana a unei tabele pe care este definita o FOREIGN KEY:",
                  options: [
                    {
                      text: "Se sterg mai intai datele de pe coloana din tabela cu care este relationata",
                    },
                    {
                      text: "Se sterg datele, apoi se sterg si datele de pe coloana din tabela cu care este relationata",
                    },
                    {
                      text: "Nu exista nicio restrictie in acest sens",
                      is_correct: !0,
                    },
                  ],
                },
                30: {
                  question:
                    "Modelul Entitate-Asociere clasic permite reprezentarea bazei de date prin:",
                  options: [
                    {
                      text: "Entitati, atribute ale entitatilor si asocieri",
                      is_correct: !0,
                    },
                    {
                      text: "Atribute, asocieri si constrangeri de integritate",
                    },
                    { text: "Entitati, atribute ale entitatilor si chei" },
                  ],
                },
                31: {
                  question:
                    "Care regula de modelare este adevarata in modelul Entitate-Asociere:",
                  options: [
                    {
                      text: "Entitatile au informatii descriptive iar atributele nu au",
                    },
                    {
                      text: "Atributele multivalorice trebuie reclasificate in entitati",
                    },
                    { text: "Ambele variante sunt adevarate", is_correct: !0 },
                  ],
                },
                32: {
                  question:
                    "Daca consideram ca o carte are un singur autor si un autor poate avea una sau mai multe carti, atunci entitatea\nAUTOR(id_autor, nume,adresa)\npoate avea o conectivitate cu entitatea\nCARTI(idcarte, id_autor, titlu, editura)\nde tipul:",
                  options: [
                    { text: "1:N", is_correct: !0 },
                    { text: "N:1 si N:N" },
                    { text: "1:1 si N:N" },
                  ],
                },
                33: {
                  question: "O dependenta functionala reprezinta:",
                  options: [
                    { text: "O descrirere a tipurilor de atribute" },
                    { text: "O legatura intre atribute", is_correct: !0 },
                    { text: "Ambele variante sunt adevarate" },
                  ],
                },
                34: {
                  question:
                    "Daca Y\u2282X atunci X\u2192Y se obtine prin axioma de:",
                  options: [
                    { text: "Reflexivitate", is_correct: !0 },
                    { text: "Tranzitivitate" },
                    { text: "Augmentare" },
                  ],
                },
                35: {
                  question:
                    "Daca X\u2192Y si X\u2192Z atunci X\u2192YZ se obtine prin regula de:",
                  options: [
                    { text: "Descompunere" },
                    { text: "Tranzitivitate" },
                    { text: "Reuniune", is_correct: !0 },
                  ],
                },
                36: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {AB\u2192CD, C\u2192DE}.\nAtunci R are o supercheie pe:",
                  options: [
                    { text: "AC" },
                    { text: "AB", is_correct: !0 },
                    { text: "BC" },
                  ],
                },
                37: {
                  question:
                    "O dependenta functionala X\u2192A, cu X strict inclusa intr-o cheie a relatiei R se numeste",
                  options: [
                    { text: "Dependenta partiala", is_correct: !0 },
                    { text: "Dependenta tranzitiva" },
                    { text: "Dependenta obtinuta prin descompunere" },
                  ],
                },
                38: {
                  question:
                    "Daca consideram ca relatia\nCOMPONENTE(cod_comp, den_comp, cod_furniz, den_furniz, pret_unitar)\nare cheia\n(cod_comp,cod_furniz)\natunci e in forma normala FN2:",
                  options: [
                    { text: "Da, conform definitiei" },
                    {
                      text: "Nu, pentru ca are dependente partiale",
                      is_correct: !0,
                    },
                    { text: "Nu, pentru ca nu este in FN1" },
                  ],
                },
                39: {
                  question:
                    "Fie relatia R = ABCDE,\ncu dependentele\nF={A\u2192B, B\u2192A, A\u2192C, D\u2192E}\nsi cheile AD si BD are atribute prime pe:",
                  options: [
                    { text: "A,D" },
                    { text: "A,B,D", is_correct: !0 },
                    { text: "B,C,E" },
                  ],
                },
                40: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192C, B\u2192A, C\u2192B, E\u2192D}.\nCate chei distincte are R?",
                  options: [
                    { text: "2" },
                    { text: "4" },
                    { text: "3", is_correct: !0 },
                  ],
                },
                41: {
                  question:
                    "Fie R = ABCD\nsi\nF = {A\u2192B, B\u2192C, C\u2192D, D\u2192A}\ncu cheile A, B, C si D.\nR este in forma normala :",
                  options: [
                    { text: "FNBC" },
                    { text: "FN3" },
                    {
                      text: "Ambele variante a si b sunt corecte",
                      is_correct: !0,
                    },
                  ],
                },
                42: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192C, B\u2192A, C\u2192B, E\u2192D}.\nProiectia multimii de dependente F pe ABED contine dependentele:",
                  options: [
                    { text: "{A\u2192B, B\u2192A}", is_correct: !0 },
                    { text: "{A\u2192B, E\u2192B}" },
                    { text: "Ambele variante a si b sunt gresite" },
                  ],
                },
                43: {
                  question:
                    "Fie R = ABCDE\nsi\nF = {A\u2192C, B\u2192A, C\u2192B, E\u2192D}.\nAtunci inchiderea multimii AC este:",
                  options: [
                    { text: "ABC", is_correct: !0 },
                    { text: "ABCE" },
                    { text: "ABCDE" },
                  ],
                },
                44: {
                  question:
                    "Fie relatiile R si S definite mai sus. Atunci joinul extern complet al celor doua relatii dupa conditia (R.A=S.A) and (R.B=S.B) are:",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/c52c320e-7589-4b1e-bccb-bbdf4ae9224c?w=900&h=900",
                  options: [
                    { text: "4 tupluri", is_correct: !0 },
                    { text: "3 tupluri" },
                    { text: "5 tupluri" },
                  ],
                },
                45: {
                  question:
                    "Pe coloanele care definesc o cheie PRIMARY KEY a unei relatii:",
                  options: [
                    {
                      text: "Nu se accepta valori nule si valori duplicate",
                      is_correct: !0,
                    },
                    { text: "Se accepta valori nule" },
                    {
                      text: "Nu se accepta valori duplicate dar accepta valori nule",
                    },
                  ],
                },
                46: {
                  question: "Ce face clauza check?",
                  options: [
                    {
                      text: "Forteaza valoarea unei coloane sa verifice o conditie prestabilita dupa ce se realizeaza conditia de join",
                      is_correct: !0,
                    },
                    {
                      text: "Forteaza valoarea unei linii sa verifice o conditie prestabilita dupa ce se realizeaza conditia de join",
                    },
                  ],
                },
                47: {
                  question:
                    "Dupa ce se realizeaza conditia de join, cu acelasi continut si nume al tabelului se poate modifica o tabela printr-un view?",
                  options: [
                    { text: "Da", is_correct: !0 },
                    { text: "Nu" },
                    { text: "Da, in anumite conditii" },
                  ],
                },
                48: {
                  question: "O relatie R aflata in forma normala FNBC:",
                  options: [
                    { text: "Este intotdeauna si in forma normala FN4" },
                    {
                      text: "Este intotdeauna si in forma normala FN3",
                      is_correct: !0,
                    },
                    { text: "Nicio varianta corecta" },
                  ],
                },
                49: {
                  question:
                    "Care din urmatoarele functii oracle sql poate fi folosita si cu alte tipuri de date decat cele numerice",
                  options: [
                    { text: "Stddev" },
                    { text: "Avg" },
                    { text: "Count", is_correct: !0 },
                  ],
                },
                50: {
                  question:
                    "Care afirmatie e adevarata despre subcererile Oracle SQL",
                  options: [
                    {
                      text: "Nu este obligatoriu ca subcererile sa fie incluse intre paranteze",
                    },
                    { text: "Subcererile pot fi ordonate" },
                    {
                      text: "Subcererile pot folosi functii de grup si clauza GROUP BY",
                      is_correct: !0,
                    },
                  ],
                },
                51: {
                  question:
                    "Fie relatia R = ABCDE,\ncu multimea de dependente functionale\nF = {A\u2192B, AE\u2192C, D\u2192A, B\u2192D}.\nCare descompunere pastreaza dependentele functionale:",
                  options: [
                    { text: "p = (ABC, AEC)" },
                    { text: "p = (BDA, CAE)", is_correct: !0 },
                    { text: "p = (ABE, ABD)" },
                  ],
                },
                52: {
                  question:
                    "Daca consideram ca relatia\nTELEFOANE(ID_telefon, ID_furnizor, seria, pret_unit)\nare cheia\n(ID_telefon, ID_furnizor)\natunci relatia este in forma normala FN3?",
                  options: [
                    { text: "Nu, deoarece are dependente tranzitive" },
                    { text: "Nu, deoarece are dependente partiale" },
                    {
                      text: "Da, deoarece cheia este si supercheie a relatiei",
                      is_correct: !0,
                    },
                  ],
                },
                53: {
                  question:
                    "O ierarhie de incluziune a unei entitati E in modelul EA implica ca:",
                  options: [
                    {
                      text: "O instanta a unei submultimi se poate regasi si in alte submultimi aflate in relatie de incluziune cu E.",
                      is_correct: !0,
                    },
                    {
                      text: "Fiecare instanta a unei submultimi a lui E se regaseste numai in acea submultime.",
                    },
                    {
                      text: "Orice instanta a unei submultimi a lui E trebuie sa se regaseasca in toate submultimile cat si in E.",
                    },
                  ],
                },
                54: {
                  question:
                    "La transformarea \xeen rela\u021bional, o asociere unara multi-multi devine:",
                  options: [
                    { text: "Coloana in tabela" },
                    { text: "Linia in tabela" },
                    { text: "Tabela", is_correct: !0 },
                  ],
                },
                55: {
                  question:
                    "Care din sistemele de gestiune urmatoare folosesc modelul de stocare a datelor orientate pe coloana:",
                  options: [
                    { text: "Oracle NoSql" },
                    { text: "MongoDB" },
                    { text: "Cassandra", is_correct: !0 },
                  ],
                },
                56: {
                  question:
                    "In Oracle SQL, subcererile NU pot fi utilizate in comanda:",
                  options: [
                    { text: "CREATE TABLE" },
                    { text: "DROP", is_correct: !0 },
                    { text: "INSERT" },
                  ],
                },
                57: {
                  question:
                    "Care din urmatoarele reguli de echivalenta sunt corecte in algebra relationala:",
                  options: [
                    {
                      text: "",
                      optionImage:
                        "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/78cb97a2-2401-4ac0-953a-47e7fb237f1a?w=900&h=900",
                    },
                    {
                      text: "",
                      is_correct: !0,
                      optionImage:
                        "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/ffccdffd-409e-4efb-9621-aa6af1e140ab?w=900&h=900",
                    },
                    {
                      text: "",
                      optionImage:
                        "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/ebf94d63-e456-480b-a2e2-666dc84d00a0?w=900&h=900",
                    },
                  ],
                },
                58: {
                  question:
                    "Fie relatia R = ABCDEF\nsi\nF = {A\u2192B, CD\u2192A, BC\u2192D, AE\u2192F, CE\u2192D}.\nAtunci o cheie a lui R este:",
                  options: [
                    { text: "CE", is_correct: !0 },
                    { text: "ABCE" },
                    { text: "ACE" },
                  ],
                },
                59: {
                  question:
                    "Independenta fizica a datelor se refera la posibilitatea de:",
                  options: [
                    {
                      text: "Schimbare a schemei fizice fara modificarea schemei conceptuale",
                    },
                    {
                      text: "Schimbare a schemei fizice fara modificarea schemelor externe",
                    },
                    { text: "Ambele variante sunt corecte", is_correct: !0 },
                  ],
                },
                60: {
                  question:
                    "Cand se creeaza in Oracle SQL o cheie primara (PRIMARY KEY), se creeaza automat:",
                  options: [
                    {
                      text: "O constrangere NOT NULL, o constrangere UNIQUE si un INDEX",
                      is_correct: !0,
                    },
                    { text: "Doar o constrangere NOT NULL" },
                    { text: "Doar o constrangere UNIQUE" },
                  ],
                },
                61: {
                  question:
                    "In procesul de transformare din modelul EA in modelul MR obtinem urmatoarele tipuri de relatii:",
                  options: [
                    { text: "Relatii provenite din entitati si asocieri " },
                    {
                      text: "Relatii provenite din entitati si atribute care sunt chei externe ",
                    },
                    { text: "Ambele variante sunt corecte", is_correct: !0 },
                  ],
                },
                62: {
                  question:
                    "In sisteme NoSQL cu stocare cheie-valoare, operatiile principale sunt:",
                  options: [
                    { text: "Insert, Update, Delete, Find" },
                    { text: "Insert, Fetch, Update, Delete", is_correct: !0 },
                    { text: "Load, Update, Delete, Search" },
                  ],
                },
                63: {
                  question: "O planificare reprezinta:",
                  options: [
                    {
                      text: "Ordinea in care scrise datele in tabelele bazei de date",
                    },
                    {
                      text: "Ordonarea tranzactiilor dupa operatiile pe care le executa",
                    },
                    {
                      text: "Ordinea in care sunt executati pasii elementari ai unui set de tranzactii",
                      is_correct: !0,
                    },
                  ],
                },
                64: {
                  question:
                    "Pentru a sterge date dintr-o tabela, care este relationata cu alta tabela pe care este definita o cheie FOREIGN KEY:",
                  options: [
                    {
                      text: "Se sterg datele, apoi se sterg si datele din tabela unde este definita cheia FOREIGN KEY",
                    },
                    {
                      text: "Se sterg mai intai datele relationate din tabela unde este definita cheia FOREIGN KEY",
                      is_correct: !0,
                    },
                    { text: "Nu exista nicio restrictie in acest sens" },
                  ],
                },
                65: {
                  question:
                    "Care dintre tipurile de baze de date urmatoare folosesc algoritmul MapReduce pentru prelucrarea datelor:",
                  options: [
                    { text: "Baze de date SQL" },
                    { text: "Baze de date NoSQL", is_correct: !0 },
                    { text: "Ambele tipuri prezentate" },
                  ],
                },
                66: {
                  question:
                    "In clauza HAVING a unei cereri Oracle SQL, daca se foloseste o subcerere care poate intoarce mai multe linii, operatorul SOME este sinonim cu operatorul:",
                  options: [
                    { text: "ANY", is_correct: !0 },
                    { text: "ALL" },
                    { text: "IN" },
                  ],
                },
                67: {
                  question:
                    "In Oracle SQL, intr-o cerere SELECT NU se poate utiliza o subcerere in clauza:",
                  options: [
                    { text: "HAVING" },
                    { text: "ORDER BY" },
                    { text: "GROUP BY", is_correct: !0 },
                  ],
                },
                68: {
                  question:
                    "Daca relatie este in FN3 atunci este intotdeauna si in FNBC ?",
                  options: [
                    { text: "Da, deoarece FN3 este inclusa in FNBC" },
                    {
                      text: "Nu, deoarece poate sa contina si dependente care nu au in partea stanga o supercheie",
                      is_correct: !0,
                    },
                    { text: "Da, deoarece FNBC este inclusa in FN3" },
                  ],
                },
                69: {
                  question: "NoSQL inseamna in acest moment:",
                  options: [
                    { text: "Not Only SQL", is_correct: !0 },
                    { text: "No SQL" },
                    { text: "No Old SQL" },
                  ],
                },
                70: {
                  question:
                    "Care dintre urmatoarele dependente multivalorice sunt triviale: Obs. Operatorul \u2264 se refera la incluziune",
                  options: [
                    {
                      text: "Numai dependentele X \u2192\u2192 Y unde Y \u2264 X",
                    },
                    {
                      text: "Numai dependentele X \u2192\u2192 Y pentru care X U Y = R",
                    },
                    { text: "Ambele sunt triviale", is_correct: !0 },
                  ],
                },
                71: {
                  question:
                    "Care dintre urmatoarele reguli de echivalenta sunt corecte in algebra relationala:",
                  options: [
                    {
                      text: "\u03c3 F (E1 \u22c3 E2) = \u03c3 F(E1) \u22c3 \u03c3 F(E2)",
                      is_correct: !0,
                    },
                    {
                      text: "\u03c3 F (E1 \u22c3 E2) = \u03c3 F(E1) \u22c2 \u03c3 F(E2)",
                    },
                    {
                      text: "\u03c3 F (E1 \u22c3 E2) = \u03c3 F(E1) \u22c8 \u03c3 F(E2)",
                    },
                  ],
                },
                72: {
                  question:
                    "Se poate utiliza in Oracle SQL o subcerere in clauza SELECT a unei cereri SELECT, daca:",
                  options: [
                    { text: "Subcererea intoarce o singura linie" },
                    { text: "Cererea intoarce o singura linie" },
                    {
                      text: "Subcererea intoarce o singura linie si o singura coloana",
                      is_correct: !0,
                    },
                  ],
                },
                73: {
                  question:
                    "Urmatoarea planificare R1(A); R1(B); W1(A); W1(B); W2(C); W2(B); W2(A); R2(C) este:",
                  options: [
                    {
                      text: "Neseriala, deoarece operatiile de scriere sunt intercalate cu operatiile de citire",
                    },
                    { text: "Neseriala, dar este serializabila" },
                    {
                      text: "Seriala, deoarece tranzactiile nu au pasi intercalati",
                      is_correct: !0,
                    },
                  ],
                },
                74: {
                  question:
                    "In oracle SQL, intr-o cerere SELECT cu subcerere pe tabela temporara, corelarea coloanelor se face pe clauza:",
                  options: [
                    { text: "Atat pe FROM cat si pe WHERE ale cererii" },
                    { text: "WHERE a cererii", is_correct: !0 },
                    { text: "FROM a cererii" },
                  ],
                },
                75: {
                  question:
                    "O ierarhie de generalizare a unei entitati E in modelul EA implica ca:",
                  options: [
                    {
                      text: "O instanta a unei submultimi se poate regasi si in alte submultimi aflate in relatie de generalizare cu E",
                    },
                    {
                      text: "Orice instanta a unei submultimi a lui E trebuie sa se regaseasca in toate submultimile cat si in E",
                    },
                    {
                      text: "Fiecare instanta a unei submultimi a lui E se regaseste numai in acea submultime si in E",
                      is_correct: !0,
                    },
                  ],
                },
                76: {
                  question: "I din ACID inseamna:",
                  options: [
                    { text: "Independenta" },
                    { text: "Inamovibilitate" },
                    { text: "Izolare", is_correct: !0 },
                  ],
                },
                77: {
                  question:
                    "Comanda: create view salarii as select job, avg(sal_ang+com_ang) from joburi group by job;",
                  options: [
                    {
                      text: "Va crea un view cu veniturile medii ale angajatilor care au primit comision",
                    },
                    {
                      text: "Va crea un view cu salariile medii pe fiecare job",
                    },
                    {
                      text: "Va genera o eroare de sintaxa din cauza formulei",
                      is_correct: !0,
                    },
                  ],
                },
                78: {
                  question:
                    "Conditia pentru a nu se pierde date prin descompunerea unei relatii R este ca:",
                  options: [
                    {
                      text: "Relatia R sa poata fi reconstruita prin orice metoda de join din relatiile rezultate, chiar daca apar date redundante",
                    },
                    {
                      text: "Relatia R sa poata fi reconstruita identic prin join-ul natural al relatiilor rezultate",
                      is_correct: !0,
                    },
                    {
                      text: "Relatia R nu mai poate fi refacuta din relatiile rezultate din descompunere",
                    },
                  ],
                },
                79: {
                  question:
                    "Dupa executia unei comenzi ROLLBACK se pot recupera:",
                  options: [
                    {
                      text: "Datele pierdute dupa stergerea din dictionar a tabelei",
                    },
                    {
                      text: "Datele dintr-o tabela sterse accidental",
                      is_correct: !0,
                    },
                    {
                      text: "Datele sterse accidental prin trunchierea tabelei",
                    },
                  ],
                },
                80: {
                  question:
                    "Daca o relatie R se descompune in mai multe relatii, atunci fiecare relatie din descompunere:",
                  options: [
                    {
                      text: "Va mosteni proiectia lui R pe multimea de atribute a relatiei rezultata din descompunere",
                      is_correct: !0,
                    },
                    {
                      text: "Fiecare relatie descompusa va mosteni toate datele relatiei R",
                    },
                    { text: "Ambele variante sunt corecte" },
                  ],
                },
                81: {
                  question:
                    "Daca se executa comanda DELETE pe o tabela, atunci datele se pot recupera:",
                  options: [
                    {
                      text: "Executand comanda SAVE, inainte de a inchide sesiunea de lucru",
                    },
                    { text: "Executand comanda COMMIT, apoi comanda ROLLBACK" },
                    {
                      text: "Executand comanda ROLLBACK, daca nu a fost executata comanda COMMIT dupa stergere",
                      is_correct: !0,
                    },
                  ],
                },
                82: {
                  question:
                    "Fie relatia R = ABCDEF,\ncu multimea de dependente functionale\nF = {A\u2192B, A\u2192F, Corect. B\u2192E, D\u2192B, E\u2192A}.\nAtunci descompunerea\np = (AB, BCD, AEF, CDE):",
                  options: [
                    { text: "Pastreaza dependentele functionale pe F" },
                    {
                      text: "Nu se poate aplica algoritmul de verificare in acest caz",
                    },
                    {
                      text: "Nu pastreaza dependentele functionale pe F",
                      is_correct: !0,
                    },
                  ],
                },
                83: {
                  question: "Comanda TRUNCATE din Oracle SQL:",
                  options: [
                    {
                      text: "Sterge toate inregistrarile dintr-o tabela",
                      is_correct: !0,
                    },
                    {
                      text: "Trunchiaza o data calendaristica la un format indicat",
                    },
                    { text: "Aproximeaza un numar zecimal fara a-l rotunji" },
                  ],
                },
                84: {
                  question:
                    "Urmatoarea planificare: R1(A); W2(A); W1(A); R2(A)",
                  options: [
                    {
                      text: "Nu este conflict-serializabila, deoarece graful de dependenta contine cicluri",
                      is_correct: !0,
                    },
                    {
                      text: "Nu este conflict-serializabila, deoarece operatille se executa pe acelasi articol ",
                    },
                    {
                      text: "Este conflict-serializabila, deoarece sunt intercalate operatii de scriere cu operatii ce citire",
                    },
                  ],
                },
                85: {
                  question:
                    "Multimea de atribute X este supercheie pentru relatia R daca:",
                  options: [
                    {
                      text: "X determina functional toate atributele relatiei R",
                      is_correct: !0,
                    },
                    { text: "X este o multime minimala" },
                    { text: "Ambele conditii sunt indeplinite" },
                  ],
                },
                86: {
                  question:
                    "Fie relatia R = ABCDEF,\ncu multimea de dependente functionale\nF = {A\u2192B, A\u2192F, B\u2192E, D\u2192B, E\u2192A} si cheia CD.\nAtunci care dintre descompunerile urmatoare sunt in FN3 cu pastrarea dependentelor functionale si proprietatea J.f.p. :",
                  options: [
                    { text: "p = (AB, BC, DEF, CD)" },
                    { text: "p = (AB, BCDEF)" },
                    { text: "p = (ABF, BE, DB, EA, CD)", is_correct: !0 },
                  ],
                },
                87: {
                  question: "Regulile de inferenta sunt folosite pentru:",
                  options: [
                    { text: "Reducerea numarului de dependete functionale" },
                    { text: "Descrierea asocierilor dintre entitati" },
                    {
                      text: "Deducerea altor dependente functionale pornind de la cele date",
                      is_correct: !0,
                    },
                  ],
                },
                88: {
                  question:
                    "Protocolul de blocare in 2 faze garanteaza serializabilitatea la executia simultana a:",
                  options: [
                    { text: "2 tranzactii" },
                    { text: "Unei singure tranzactii" },
                    { text: "Oricator tranzactii", is_correct: !0 },
                  ],
                },
                89: {
                  question: "",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/1f9440eb-7471-4183-9c7f-be9c0370ff12?w=600&h=600",
                  options: [
                    { text: "Da, deoarece reprezinta un join natural" },
                    {
                      text: "Nu, pentru ca reprezinta metode diferite de join",
                    },
                    {
                      text: "Da, deoarece reprezinta un semi-join",
                      is_correct: !0,
                    },
                  ],
                },
                90: {
                  question: "",
                  questionImage:
                    "https://quizizz.com/media/resource/gs/quizizz-media/quizzes/d3168120-b4c0-4eb2-9b49-f2103f5cff4e?w=600&h=600",
                  options: [
                    { text: "4 coloane" },
                    { text: "5 coloane" },
                    { text: "6 coloane", is_correct: !0 },
                  ],
                },
              },
              G = function () {
                var e = V[W];
                X[e] &&
                  R[e].forEach(function (t, a) {
                    X[e].options[a] && (X[e].options[a].feedback = t);
                  });
              },
              W = 0,
              V = Object.keys(R);
            W < V.length;
            W++
          )
            G();
          var $ = Object.keys(X).length;
          for (var J in B) B.hasOwnProperty(J) && (X[J + $] = B[J]);
          for (var K in (($ = Object.keys(X).length), q))
            q.hasOwnProperty(K) && (X[K + $] = q[K]);
          for (var Z in (($ = Object.keys(X).length), H))
            H.hasOwnProperty(Z) && (X[Z + $] = H[Z]);
          var ee = X,
            te = {
              Titlu: "Grile pregatire examen BD",
              An: "2023",
              Serie: "CA",
              Profesor: "Alexandru Boicea",
              Creat: "8 iunie 2023, 7PM",
              "Parti implicate": "Echipa BD, Seria CA 2020-2024, GPT4",
              Surse: [
                {
                  link: "https://quizizz.com/join/quiz/62a701397197e5001d0ff90b/start",
                  linkText: "Quizizz de la CC",
                },
                {
                  link: "https://quizizz.com/join/quiz/62a65dc556b7c6001dfa717d/start?studentShare=true",
                  linkText: "Quizizz de la Ilinca Strutu",
                },
                {
                  link: "https://quizizz.com/join/quiz/625c44049dee09001ea121f8/start?studentShare=true",
                  linkText: "Quizizz Partial",
                },
                {
                  link: "https://quizizz.com/join/quiz/644fad6a908ec8001d70722f/start?studentShare=true",
                  linkText: "Quizizz Partial 2",
                },
              ],
            };
          function ae(e) {
            for (var t = e.length - 1; t > 0; t--) {
              var a = Math.floor(Math.random() * (t + 1)),
                n = [e[a], e[t]];
              (e[t] = n[0]), (e[a] = n[1]);
            }
          }
          var ne = function (t) {
            var a = t.quizIndex,
              n = t.quizMaxIndex,
              i = t.question,
              r = t.katex,
              l = t.options,
              o = t.questionImage,
              u = t.resetSignal,
              c = s((0, e.useState)(null), 2),
              d = c[0],
              p = c[1],
              m = s((0, e.useState)(!1), 2),
              f = m[0],
              g = m[1],
              h = s((0, e.useState)(!1), 2),
              b = h[0],
              v = h[1],
              x = (0, e.useRef)(null);
            (0, e.useEffect)(
              function () {
                p(null), g(!1);
              },
              [u]
            );
            return (0, C.jsxs)("div", {
              className: "quiz",
              ref: x,
              children: [
                o &&
                  (0, C.jsx)("img", {
                    className: "question",
                    style: {
                      maxWidth: "100%",
                      maxHeight: "60vh",
                      objectFit: "contain",
                    },
                    src: o,
                    alt: "da eroare react daca nu scriu nimic aici...",
                  }),
                r &&
                  (0, C.jsx)("span", {
                    className: "question",
                    dangerouslySetInnerHTML: { __html: r },
                    style: { overflowX: "auto" },
                  }),
                i &&
                  (0, C.jsxs)("h3", {
                    className: "question",
                    style: { whiteSpace: "pre-wrap" },
                    children: [
                      (0, C.jsx)("span", {
                        style: { marginRight: "10px" },
                        children: i,
                      }),
                      (0, C.jsx)("span", {
                        className: "info-icon",
                        onClick: function (e) {
                          v(!0);
                        },
                        children: "".concat(a + 1, "/").concat(n),
                      }),
                    ],
                  }),
                l.map(function (e, t) {
                  return (0, C.jsxs)(
                    "button",
                    {
                      className: "option ".concat(
                        f && d === t
                          ? e.is_correct
                            ? "correct"
                            : "incorrect"
                          : ""
                      ),
                      onClick: function () {
                        return (function (e, t) {
                          d === t ? (g(!1), p(null)) : (p(t), g(!0)),
                            x.current &&
                              x.current.scrollIntoView({
                                behavior: "smooth",
                                block: "start",
                              });
                        })(0, t);
                      },
                      children: [
                        d === t &&
                          (0, C.jsx)("span", {
                            className: e.is_correct ? "checkmark" : "crossed",
                            children: e.is_correct ? "\u2713" : "\u2717",
                          }),
                        e.optionImage &&
                          (0, C.jsx)("img", {
                            style: { maxWidth: "100%", maxHeight: "90vh" },
                            src: e.optionImage,
                            alt: "da eroare react daca nu scriu nimic aici...",
                          }),
                        e.text,
                      ],
                    },
                    t
                  );
                }),
                null !== d &&
                  l[d] &&
                  l[d].feedback &&
                  (0, C.jsx)("p", {
                    className: "feedback",
                    children: l[d].feedback,
                  }),
                b &&
                  (0, C.jsx)(N, {
                    question: i,
                    content: l,
                    onClose: function () {
                      v(!1);
                    },
                  }),
              ],
            });
          };
          var ie = function () {
            var t = s((0, e.useState)(Object.values(ee)), 2),
              a = t[0],
              n = (t[1], s((0, e.useState)(Object.values(ee)), 2)),
              i = n[0],
              r = n[1],
              l = s(
                (0, e.useState)({ start: 1, end: Object.keys(ee).length }),
                2
              ),
              u = l[0],
              c = l[1],
              d = function () {
                var e = u.start,
                  t = u.end,
                  n = JSON.parse(JSON.stringify(a.slice(e - 1, t)));
                ae(n),
                  n.forEach(function (e) {
                    return ae(e.options);
                  }),
                  r(n);
              };
            (0, e.useEffect)(function () {
              d();
            }, []);
            var p = function (e) {
              c(
                9 === e
                  ? { start: 181, end: Object.keys(a).length }
                  : { start: 20 * e + 1, end: 20 * (e + 1) }
              );
            };
            return (
              (0, e.useEffect)(
                function () {
                  d();
                },
                [u]
              ),
              (0, C.jsxs)("div", {
                className: "App",
                children: [
                  (0, C.jsx)(S, { context: te }),
                  (0, C.jsxs)("div", {
                    className: "infoBox",
                    style: { marginTop: "0" },
                    children: [
                      (0, C.jsx)("div", {
                        className: "question",
                        children: "Setul de intrebari(optional)",
                      }),
                      (0, C.jsxs)("div", {
                        className: "pagination-buttons",
                        children: [
                          Array.from({ length: 9 }).map(function (e, t) {
                            return (0, C.jsx)(
                              "button",
                              {
                                className: "page-button",
                                onClick: function () {
                                  return p(t);
                                },
                                children: ""
                                  .concat(20 * t + 1, " - ")
                                  .concat(20 * t + 20),
                              },
                              t
                            );
                          }),
                          (0, C.jsx)("button", {
                            className: "page-button wide-button",
                            onClick: function () {
                              return p(9);
                            },
                            children: "181 - Last",
                          }),
                        ],
                      }),
                    ],
                  }),
                  i.map(function (e, t) {
                    return (0,
                    C.jsx)(ne, o(o({ quizIndex: t, quizMaxIndex: i.length }, e), {}, { resetSignal: Date.now() }), t);
                  }),
                  (0, C.jsx)("button", {
                    className: "try-again",
                    onClick: function () {
                      d(),
                        document.querySelector(".infoBox").scrollIntoView({
                          behavior: "smooth",
                          block: "start",
                        });
                    },
                    children: "Incearca din nou",
                  }),
                ],
              })
            );
          };
          t.createRoot(document.getElementById("root")).render(
            (0, C.jsx)(e.StrictMode, { children: (0, C.jsx)(ie, {}) })
          );
        })();
      })();
      //# sourceMappingURL=main.d4ebf292.js.map
    </script>
  </body>
</html>
